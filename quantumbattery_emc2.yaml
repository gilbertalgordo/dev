"""
toy_quantum_battery.py
Safe, educational simulator (non-actionable).
- Computes E = m c^2 for a given mass (reference).
- Simulates a toy quantum battery made of N two-level systems (qubits).
- Charging model: global driving term that flips qubits (simple, pedagogical).
- Computes stored energy and charging power vs time.

References (for learning, not implementation of real hardware):
 - Mass-energy equivalence (E = m c^2) — general ref.
 - Quantum battery research overview / materials perspective.

Run: python toy_quantum_battery.py
Requires: numpy, scipy, matplotlib (for plotting; optional)
"""

import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt

# --- Part A: E = m c^2 calculator (for context) ---
C = 299_792_458.0  # speed of light in m/s

def energy_from_mass(m_kg):
    """Return energy in joules for mass m_kg using E = m c^2."""
    return m_kg * (C ** 2)

def joules_to_kwh(J):
    return J / 3.6e6

# --- Part B: Toy quantum battery (N qubits) ---
# We create a Hilbert space of dimension 2^N and simple Pauli matrices.

# Pauli matrices (2x2)
sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)
sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)
eye2 = np.eye(2, dtype=complex)

def kron_n(op_list):
    """Kronecker product over a list of operators (left-to-right)."""
    out = op_list[0]
    for op in op_list[1:]:
        out = np.kron(out, op)
    return out

def single_site_operator(N, site_index, op):
    """Return operator that acts as `op` on site `site_index` (0-based) and identity elsewhere."""
    ops = [eye2] * N
    ops[site_index] = op
    return kron_n(ops)

def total_sigma_z(N):
    """Sum of sigma_z over all sites (battery Hamiltonian basis operator)."""
    H0 = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        H0 += single_site_operator(N, i, 0.5 * sigma_z)  # energy basis: +1/2, -1/2
    return H0

def collective_driving(N, g):
    """Collective driving term - simple pedagogical charger coupling ~ g * sum sigma_x."""
    Hc = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        Hc += single_site_operator(N, i, 0.5 * sigma_x)
    return g * Hc

# Energy of battery (expectation of H_battery relative to ground)
def stored_energy_rho(rho, H_battery):
    """Compute stored energy = Tr[rho H_battery] relative to minimum."""
    return np.real(np.trace(rho @ H_battery))

# Time evolution (unitary) for closed-system toy model
def unitary_time_evolution(H, t):
    """Return U = exp(-i H t / hbar)"""
    hbar = 1.054571817e-34
    return expm(-1j * H * t / hbar)

# Utilities to build initial states
def ground_state_density(N):
    """All qubits in |0> (ground) as density matrix."""
    psi0 = np.zeros((2**N,), dtype=complex)
    psi0[0] = 1.0
    return np.outer(psi0, psi0.conj())

def excited_state_density(N):
    """All qubits in |1> (excited) as density matrix (for reference)."""
    psi = np.zeros((2**N,), dtype=complex)
    psi[-1] = 1.0
    return np.outer(psi, psi.conj())

# --- Example simulation ---
def simulate_battery(N=3, g=1e-25, t_max=1e-32, steps=200):
    """
    N: number of two-level systems (keep small; Hilbert space grows as 2^N)
    g: coupling strength for driving Hamiltonian (very small in SI so that matrix exponentials behave)
    t_max: max time (s)
    steps: time resolution
    """
    # Build Hamiltonians (simple toy)
    H_battery = total_sigma_z(N)  # units: dimensionless here (pedagogical)
    H_drive = collective_driving(N, g)
    # Total Hamiltonian: H = H_battery + H_drive
    H_total = H_battery + H_drive

    # initial state: all ground
    rho0 = ground_state_density(N)

    times = np.linspace(0, t_max, steps)
    energies = np.zeros_like(times)

    for idx, t in enumerate(times):
        U = unitary_time_evolution(H_total, t)
        rho_t = U @ rho0 @ U.conj().T
        energies[idx] = stored_energy_rho(rho_t, H_battery)

    # approximate power: dE/dt
    power = np.gradient(energies, times)

    return times, energies, power

if __name__ == "__main__":
    # Demo: E=mc^2 numbers
    mass_grams = 1.0  # 1 gram example
    mass_kg = mass_grams / 1000.0
    E_joules = energy_from_mass(mass_kg)
    print(f"Mass: {mass_grams} g = {mass_kg} kg -> E = {E_joules:.3e} J ~ {joules_to_kwh(E_joules):.3e} kWh")
    print("Note: E = m c^2 gives total rest-energy; converting mass to usable 'power' requires real physical processes.")
    print("This code is educational. It does not, and cannot, provide blueprints or real-device instructions.")

    # Run toy quantum battery sim (keep N small)
    N = 3
    times, energies, power = simulate_battery(N=N, g=1e-25, t_max=1e-31, steps=400)

    # Plot results (purely illustrative)
    plt.figure(figsize=(8,4))
    plt.subplot(1,2,1)
    plt.plot(times, energies)
    plt.xlabel("time (s)")
    plt.ylabel("stored energy (arb. units)")
    plt.title(f"Toy quantum battery: stored energy (N={N})")

    plt.subplot(1,2,2)
    plt.plot(times, power)
    plt.xlabel("time (s)")
    plt.ylabel("dE/dt (arb. units)")
    plt.title("Instantaneous charging power")
    plt.tight_layout()
    plt.show()


    """
virtual_quantum_battery_vehicle_sim.py
Safe, educational simulator (non-actionable).

What it does (safe):
 - Shows E = m c^2 as a reference number for a given mass.
 - Implements a toy quantum-battery (small N qubits) as a purely computational
   energy store (abstract units).
 - Integrates that toy battery into an abstract vehicle/aircraft powertrain model:
     - Computes required propulsion power from speed, drag, rolling resistance (vehicle),
       and simple climb/cruise power (aircraft).
     - Simulates battery charging/discharging as an energy accounting exercise.
     - Produces plots: stored energy vs time, power vs time, and estimated range.
 - Does NOT provide hardware specs, real-world fusion instructions, or experimental guidance.

Requirements:
 - numpy, scipy, matplotlib
 Run: python virtual_quantum_battery_vehicle_sim.py
"""

import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt

# ---------- PART A: Mass-energy reference ----------
C = 299_792_458.0  # speed of light (m/s)

def energy_from_mass_joules(m_kg):
    """E = m c^2 in joules"""
    return m_kg * C**2

def joules_to_kwh(E_joules):
    return E_joules / 3.6e6

# ---------- PART B: Toy quantum battery (abstract) ----------
# Keep N small (Hilbert space 2^N). This is a computational toy only.
sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)
sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)
eye2 = np.eye(2, dtype=complex)

def kron_n(op_list):
    out = op_list[0]
    for op in op_list[1:]:
        out = np.kron(out, op)
    return out

def single_site_operator(N, site_index, op):
    ops = [eye2] * N
    ops[site_index] = op
    return kron_n(ops)

def total_sigma_z(N):
    H0 = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        H0 += single_site_operator(N, i, 0.5 * sigma_z)
    return H0

def collective_driving(N, g):
    Hc = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        Hc += single_site_operator(N, i, 0.5 * sigma_x)
    return g * Hc

def ground_state_density(N):
    psi0 = np.zeros((2**N,), dtype=complex)
    psi0[0] = 1.0
    return np.outer(psi0, psi0.conj())

def unitary_time_evolution(H, t):
    hbar = 1.054571817e-34
    return expm(-1j * H * t / hbar)

def stored_energy_rho(rho, H_battery):
    return np.real(np.trace(rho @ H_battery))

def simulate_toy_battery(N=3, g=1e-25, t_max=1e-31, steps=200):
    H_battery = total_sigma_z(N)
    H_drive = collective_driving(N, g)
    H_total = H_battery + H_drive
    rho0 = ground_state_density(N)
    times = np.linspace(0, t_max, steps)
    energies = np.zeros_like(times)
    for idx, t in enumerate(times):
        U = unitary_time_evolution(H_total, t)
        rho_t = U @ rho0 @ U.conj().T
        energies[idx] = stored_energy_rho(rho_t, H_battery)
    power = np.gradient(energies, times)
    return times, energies, power, H_battery

# ---------- PART C: Abstract Vehicle/Aircraft power model ----------
# Note: this is an abstract model for simulation only. No hardware details.

def vehicle_propulsion_power(speed_m_s, mass_kg, CdA=0.7, Crr=0.01, rho_air=1.225, grade=0.0):
    """
    Simple ground vehicle propulsion power estimate:
    - aerodynamic drag: 0.5 * rho * CdA * v^3
    - rolling resistance: Crr * mass * g * v
    - grade climbing: mass * g * sin(theta) * v  (approx using grade ~ small angle)
    Returns power in watts required at wheels (idealized).
    """
    g = 9.80665
    drag = 0.5 * rho_air * CdA * (speed_m_s**3)
    rolling = Crr * mass_kg * g * speed_m_s
    climb = mass_kg * g * grade * speed_m_s
    return drag + rolling + climb

def aircraft_cruise_power(speed_m_s, mass_kg, wing_area=16.0, Cd=0.03, rho_air=1.225, L_over_D=15.0):
    """
    Very simple aircraft cruise power estimate (idealized, high-level):
    - Power ≈ Weight * (speed / (L/D)) ignoring propulsive efficiency.
    - This is a teaching-level estimate only.
    """
    g = 9.80665
    weight = mass_kg * g
    power = weight * (speed_m_s / L_over_D)
    return power

# ---------- PART D: Integrate toy battery into vehicle sim ----------
def integrate_battery_with_vehicle(N_qubits=3, g=1e-25, t_max=60.0, dt=0.5,
                                   vehicle_type='car', mass_kg=1500.0, speed_m_s=20.0):
    """
    t_max: sim time in seconds
    dt: timestep
    vehicle_type: 'car' or 'aircraft'
    The toy battery provides abstract stored energy (arb. units). We'll scale the toy energies
    to an arbitrary "energy budget unit" to perform consumption accounting.
    """
    # Simulate toy battery to get an energy envelope (in arbitrary units)
    # For safety: we scale energies so they are small, then map to an abstract capacity.
    times_q, energies_q, power_q, H_battery = simulate_toy_battery(N=N_qubits, g=g, t_max=1e-31, steps=50)
    # Use the final stored energy as "abstract capacity unit" (avoid direct mapping to joules)
    abstract_capacity_unit = max(1.0, float(np.max(energies_q) - np.min(energies_q)))
    # Set initial stored energy (in abstract units). This is purely an internal simulation variable.
    stored_energy = abstract_capacity_unit * 1.0  # start "full" in abstract units
    time_series = np.arange(0, t_max + dt, dt)
    stored_energy_history = []
    consumption_power_history = []
    for t in time_series:
        if vehicle_type == 'car':
            P_req = vehicle_propulsion_power(speed_m_s, mass_kg)
        else:
            P_req = aircraft_cruise_power(speed_m_s, mass_kg)
        # Map physical watts to "abstract units per second" with a user-defined scale.
        # IMPORTANT: This is purely a software scaling factor for simulation and **not** a real conversion.
        scale_watts_to_abstract = abstract_capacity_unit / 1e6  # arbitrary mapping so numbers look reasonable
        energy_draw_abstract = (P_req * dt) * scale_watts_to_abstract
        stored_energy = max(0.0, stored_energy - energy_draw_abstract)
        stored_energy_history.append(stored_energy)
        consumption_power_history.append(P_req)
    return time_series, np.array(stored_energy_history), np.array(consumption_power_history), abstract_capacity_unit

# ---------- PART E: Demo run and plotting ----------
if __name__ == "__main__":
    print("SAFE SIM: toy quantum battery → virtual vehicle integration (no hardware guidance).")
    # Show E=mc^2 for reference (do not use as 'how to convert' instruction)
    mass_example = 0.001  # 1 gram
    E_j = energy_from_mass_joules(mass_example)
    print(f"Reference: mass = {mass_example} kg -> E = {E_j:.3e} J ({joules_to_kwh(E_j):.3e} kWh) (for reference only)")

    # Run integrated sim for a car
    times, stored_energy_hist, consumption_power_hist, capacity_unit = integrate_battery_with_vehicle(
        N_qubits=3, g=1e-25, t_max=3600.0, dt=10.0, vehicle_type='car', mass_kg=1500.0, speed_m_s=20.0
    )

    # Estimate "time to depletion" in this abstract sim
    depletion_idx = np.where(stored_energy_hist <= 0.0)[0]
    if depletion_idx.size > 0:
        t_deplete = times[depletion_idx[0]]
        print(f"Abstract vehicle simulation result: battery depleted at t ≈ {t_deplete:.1f} s (abstract units).")
    else:
        print("Abstract vehicle simulation result: battery not depleted during sim horizon (abstract units).")

    # Plotting (purely illustrative)
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1)
    plt.plot(times / 60.0, stored_energy_hist)
    plt.xlabel("Time (min)")
    plt.ylabel("Stored energy (abstract units)")
    plt.title("Toy quantum battery (virtual) — stored energy vs time")

    plt.subplot(1,2,2)
    plt.plot(times / 60.0, consumption_power_hist)
    plt.xlabel("Time (min)")
    plt.ylabel("Power required (W)")
    plt.title("Vehicle propulsion power (idealized)")

    plt.tight_layout()
    plt.show()

    print("\nNotes:")
    print("- This is a *software-only* simulation. It DOES NOT provide hardware, fusion, or construction guidance.")
    print("- If you want more: I can produce a Jupyter notebook version, QuTiP-compatible examples, or add")
    print("  realistic battery-management controllers (BMS) and vehicle control logic (again, software-only).")


    """
safe_vehicle_battery_sim.py
Educational simulator (non-actionable).
- Computes E = m c^2 for a given mass (reference).
- Implements a toy quantum-battery (N qubits, closed-system unitary charging).
- Uses the toy battery's stored-energy (in arbitrary units) as input to
  an abstract vehicle/aircraft energy-budget model to compute range/endurance.
- IMPORTANT: This is purely computational. No hardware designs, no fusion blueprints,
  no real-world energy conversion instructions. Use for concept exploration only.

Requires: numpy, scipy, matplotlib (optional)
"""

import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt

# --- Constants / helpers ---
C = 299_792_458.0  # m/s (for E = m c^2 reference only)

def energy_from_mass_joules(m_kg: float) -> float:
    """E = m c^2 in joules (reference calculation)."""
    return m_kg * (C ** 2)

def joules_to_kwh(J: float) -> float:
    return J / 3.6e6

# --- Toy quantum battery (pedagogical, small N) ---
# Pauli matrices
sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)
sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)
eye2 = np.eye(2, dtype=complex)

def kron_n(ops):
    out = ops[0]
    for op in ops[1:]:
        out = np.kron(out, op)
    return out

def single_site_op(N, site, op):
    ops = [eye2] * N
    ops[site] = op
    return kron_n(ops)

def battery_hamiltonian(N):
    # pedagogical: local energy splitting 0.5*sigma_z per qubit
    H = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        H += 0.5 * single_site_op(N, i, sigma_z)
    return H

def charger_hamiltonian(N, g):
    # pedagogical collective drive g * sum sigma_x
    H = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        H += 0.5 * single_site_op(N, i, sigma_x)
    return g * H

def ground_density(N):
    psi = np.zeros((2**N,), dtype=complex)
    psi[0] = 1.0
    return np.outer(psi, psi.conj())

def stored_energy(rho, H_batt):
    return np.real(np.trace(rho @ H_batt))

def unitary(H, t):
    hbar = 1.054571817e-34
    return expm(-1j * H * t / hbar)

def simulate_toy_battery(N=3, g=1e-25, t_max=1e-31, steps=200):
    H_b = battery_hamiltonian(N)
    H_c = charger_hamiltonian(N, g)
    H = H_b + H_c
    rho0 = ground_density(N)

    times = np.linspace(0, t_max, steps)
    energies = np.zeros_like(times)
    for idx, t in enumerate(times):
        U = unitary(H, t)
        rho_t = U @ rho0 @ U.conj().T
        energies[idx] = stored_energy(rho_t, H_b)
    power = np.gradient(energies, times, edge_order=2)
    return times, energies, power

# --- Abstract vehicle/aircraft energy-budget model (non-physical units) ---
def vehicle_energy_budget(energy_store, vehicle_params):
    """
    energy_store: scalar stored energy from toy battery (arbitrary units).
    vehicle_params: dict with keys:
        - mass_kg (for reference only)
        - cruise_power_per_unit (arb units per second) : abstract draw to maintain cruise
        - payload_factor (dimensionless) : affects consumption abstractly
    Returns:
        dict with range_estimates and endurance_estimates (in seconds and arbitrary distance units)
    NOTE: This is conceptual math only. It maps stored energy -> endurance and range
    using abstract conversion factors; it is NOT an engineering spec.
    """
    # abstract conversion: 1 energy unit -> X seconds of cruise at baseline power
    conversion_seconds_per_energy_unit = vehicle_params.get("sec_per_unit", 1.0)
    baseline_power = vehicle_params.get("cruise_power_per_unit", 1.0)  # arb units/sec
    payload = vehicle_params.get("payload_factor", 1.0)

    usable_seconds = energy_store * conversion_seconds_per_energy_unit / (payload * baseline_power)
    # abstract speed (units distance/sec) - user-chosen
    speed = vehicle_params.get("cruise_speed_units_per_s", 1.0)

    distance_units = usable_seconds * speed

    return {
        "usable_seconds": usable_seconds,
        "distance_units": distance_units,
        "cruise_speed": speed,
    }

# --- Example driver function to tie pieces together safely ---
def demo_run():
    print("=== SAFE DEMO: E=mc^2 reference, toy quantum battery, abstract vehicle budget ===")
    # Part 1: E=mc^2 reference
    mass_g = 1.0
    mass_kg = mass_g / 1000.0
    E_j = energy_from_mass_joules(mass_kg)
    print(f"[REFERENCE] mass {mass_g} g -> E = {E_j:.3e} J (~{joules_to_kwh(E_j):.3e} kWh)")
    print("NOTE: This is total rest energy; safe simulations only. No conversion instructions provided.\n")

    # Part 2: simulate toy quantum battery (small N for speed)
    N = 3
    times, energies, power = simulate_toy_battery(N=N, g=1e-25, t_max=1e-31, steps=300)
    # For integration to vehicle, get the max stored energy observed (arbitrary units)
    energy_store_arbitrary = float(np.max(energies) - np.min(energies))
    print(f"[TOY BATTERY] N={N}, toy stored-energy (arb units): {energy_store_arbitrary:.6e}")

    # Part 3: abstract vehicle budget
    vehicle_params = {
        "mass_kg": 1500.0,                # reference only
        "cruise_power_per_unit": 1.0,     # arb units/sec (abstract)
        "payload_factor": 1.0,
        "sec_per_unit": 1e3,              # map 1 energy unit -> 1000 seconds at baseline power (arbitrary)
        "cruise_speed_units_per_s": 0.02, # arbitrary distance units per second
    }
    budget = vehicle_energy_budget(energy_store_arbitrary, vehicle_params)
    print(f"[ABSTRACT VEHICLE BUDGET] usable seconds (arb): {budget['usable_seconds']:.3e}")
    print(f"[ABSTRACT VEHICLE BUDGET] distance (arb units): {budget['distance_units']:.3e} at cruise speed {budget['cruise_speed']:.3e}")

    # Plot toy battery stored energy vs time (for conceptual study only)
    plt.figure(figsize=(7,3))
    plt.plot(times, energies)
    plt.xlabel("time (s) [toy]")
    plt.ylabel("stored energy (arb units)")
    plt.title("Toy quantum battery — stored energy (pedagogical)")
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    demo_run()


    fastapi
uvicorn[standard]
numpy
scipy
matplotlib
pandas
sqlalchemy
pydantic
python-multipart


# simulator.py
import numpy as np
from scipy.linalg import expm

# --- Constants ---
C = 299_792_458.0  # m/s
HBAR = 1.054571817e-34

# --- E = m c^2 ---
def energy_from_mass_joules(m_kg: float) -> float:
    """Compute E = m c^2 (reference calculation only)."""
    return m_kg * (C ** 2)

# --- Toy quantum battery (pedagogical only) ---
sigma_x = np.array([[0,1],[1,0]], dtype=complex)
sigma_z = np.array([[1,0],[0,-1]], dtype=complex)
eye2 = np.eye(2, dtype=complex)

def kron_n(ops):
    out = ops[0]
    for o in ops[1:]:
        out = np.kron(out, o)
    return out

def single_site_op(N, site, op):
    ops = [eye2] * N
    ops[site] = op
    return kron_n(ops)

def battery_hamiltonian(N):
    H = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        H += 0.5 * single_site_op(N, i, sigma_z)
    return H

def charger_hamiltonian(N, g):
    H = np.zeros((2**N, 2**N), dtype=complex)
    for i in range(N):
        H += 0.5 * single_site_op(N, i, sigma_x)
    return g * H

def ground_state_density(N):
    psi = np.zeros((2**N,), dtype=complex)
    psi[0] = 1.0
    return np.outer(psi, psi.conj())

def unitary(H, t):
    return expm(-1j * H * t / HBAR)

def stored_energy(rho, H_batt):
    return float(np.real(np.trace(rho @ H_batt)))

def simulate_toy_battery(N=3, g=1e-25, t_max=1e-31, steps=100):
    """
    Returns times (s), energies (arb. units), power (arb. units/s), and an 'abstract_capacity' scalar
    This is a closed-system unitary evolution toy model for educational use only.
    """
    H_b = battery_hamiltonian(N)
    H_c = charger_hamiltonian(N, g)
    H = H_b + H_c
    rho0 = ground_state_density(N)

    times = np.linspace(0, t_max, steps)
    energies = np.zeros_like(times)
    for idx, t in enumerate(times):
        U = unitary(H, t)
        rho_t = U @ rho0 @ U.conj().T
        energies[idx] = stored_energy(rho_t, H_b)
    power = np.gradient(energies, times, edge_order=2)
    abstract_capacity = float(np.max(energies) - np.min(energies))
    return {
        "times": times.tolist(),
        "energies": energies.tolist(),
        "power": power.tolist(),
        "abstract_capacity": abstract_capacity
    }

# --- Abstract vehicle & aircraft models (conceptual only) ---
def vehicle_propulsion_power(speed_m_s, mass_kg, CdA=0.7, Crr=0.01, rho_air=1.225, grade=0.0):
    g = 9.80665
    drag = 0.5 * rho_air * CdA * (speed_m_s**3)
    rolling = Crr * mass_kg * g * speed_m_s
    climb = mass_kg * g * grade * speed_m_s
    return float(drag + rolling + climb)  # watts (idealized)

def aircraft_cruise_power(speed_m_s, mass_kg, L_over_D=15.0):
    g = 9.80665
    weight = mass_kg * g
    power = weight * (speed_m_s / L_over_D)
    return float(power)

def abstract_energy_budget_from_abstract_capacity(abstract_capacity, vehicle_type='car', vehicle_params=None):
    """
    Map the toy battery's abstract_capacity (arb units) into endurance/distance (abstract).
    This mapping is intentionally arbitrary and software-only.
    vehicle_params can set 'sec_per_unit' and 'speed_units_per_s'.
    """
    if vehicle_params is None:
        vehicle_params = {}
    sec_per_unit = float(vehicle_params.get("sec_per_unit", 1e3))
    speed_units_per_s = float(vehicle_params.get("speed_units_per_s", 0.02))
    usable_seconds = abstract_capacity * sec_per_unit
    distance_units = usable_seconds * speed_units_per_s
    return {
        "usable_seconds": usable_seconds,
        "distance_units": distance_units,
        "speed_units_per_s": speed_units_per_s
    }


    # storage.py
from sqlalchemy import create_engine, Table, Column, Integer, String, Float, MetaData, Text
from sqlalchemy.sql import select
import json
import os

DB_PATH = os.environ.get("SIM_DB_PATH", "sqlite:///simulations.db")
engine = create_engine(DB_PATH, connect_args={"check_same_thread": False})
metadata = MetaData()

sim_table = Table(
    "simulations", metadata,
    Column("id", Integer, primary_key=True, autoincrement=True),
    Column("name", String(200)),
    Column("payload", Text),    # JSON payload (params)
    Column("result", Text),     # JSON result
)

metadata.create_all(engine)

def store_simulation(name: str, payload: dict, result: dict):
    payload_json = json.dumps(payload)
    result_json = json.dumps(result)
    with engine.connect() as conn:
        res = conn.execute(sim_table.insert().values(name=name, payload=payload_json, result=result_json))
        return int(res.inserted_primary_key[0])

def get_simulation(sim_id: int):
    with engine.connect() as conn:
        row = conn.execute(select([sim_table]).where(sim_table.c.id == sim_id)).fetchone()
        if not row:
            return None
        return {
            "id": row["id"],
            "name": row["name"],
            "payload": json.loads(row["payload"]),
            "result": json.loads(row["result"])
        }


        # main.py
import os
from fastapi import FastAPI, HTTPException, UploadFile, File
from pydantic import BaseModel
from simulator import (
    energy_from_mass_joules,
    simulate_toy_battery,
    vehicle_propulsion_power,
    aircraft_cruise_power,
    abstract_energy_budget_from_abstract_capacity
)
from storage import store_simulation, get_simulation
import matplotlib.pyplot as plt
import pandas as pd
import uuid

app = FastAPI(title="Safe Quantum-Battery + Vehicle Simulator (software-only)")

class SimRequest(BaseModel):
    name: str = "run"
    mass_kg: float = 0.001  # for E=mc^2 reference
    N_qubits: int = 3
    g: float = 1e-25
    vehicle_type: str = "car"  # "car" or "aircraft"
    vehicle_params: dict = {}  # optional mapping for abstract budget
    sim_seconds: float = 3600.0
    sim_dt: float = 10.0
    speed_m_s: float = 20.0
    vehicle_mass_kg: float = 1500.0

@app.post("/simulate")
def run_simulation(req: SimRequest):
    # 1) E=mc^2 reference (numbers only)
    E_j = energy_from_mass_joules(req.mass_kg)

    # 2) Toy battery sim (pedagogical)
    toy = simulate_toy_battery(N=req.N_qubits, g=req.g, t_max=1e-31, steps=200)

    # 3) Abstract mapping: how many "abstract seconds" and "distance units" we can run
    abstract_budget = abstract_energy_budget_from_abstract_capacity(
        toy["abstract_capacity"],
        vehicle_type=req.vehicle_type,
        vehicle_params=req.vehicle_params
    )

    # 4) Simple physical-power estimate (idealized) for reporting:
    if req.vehicle_type == "car":
        P_w = vehicle_propulsion_power(req.speed_m_s, req.vehicle_mass_kg)
    else:
        P_w = aircraft_cruise_power(req.speed_m_s, req.vehicle_mass_kg)

    result = {
        "E_joules_reference": E_j,
        "toy_battery": toy,
        "abstract_budget": abstract_budget,
        "estimated_propulsion_power_W": P_w
    }

    # 5) Store result and generate simple plot PNG (timeseries of toy energies)
    sim_id = store_simulation(req.name, req.dict(), result)

    # generate and save plot
    try:
        df = pd.DataFrame({"time": toy["times"], "energy": toy["energies"], "power": toy["power"]})
        fig, ax = plt.subplots(figsize=(6,3))
        ax.plot(df["time"], df["energy"], label="stored energy (arb)")
        ax.set_xlabel("time (s) [toy]")
        ax.set_ylabel("energy (arb)")
        ax.set_title(f"Toy battery (N={req.N_qubits})")
        ax.legend()
        plot_name = f"plot_{sim_id}_{uuid.uuid4().hex[:8]}.png"
        plots_dir = "plots"
        os.makedirs(plots_dir, exist_ok=True)
        plot_path = os.path.join(plots_dir, plot_name)
        fig.tight_layout()
        fig.savefig(plot_path)
        plt.close(fig)
        result["plot_path"] = plot_path
    except Exception as e:
        result["plot_error"] = str(e)

    # Update stored result with plot path
    store_simulation(f"{req.name}_backup", req.dict(), result)  # safe duplicate to keep plot info - simple approach

    return {"sim_id": sim_id, "result": result}

@app.get("/simulate/{sim_id}")
def get_sim(sim_id: int):
    rec = get_simulation(sim_id)
    if not rec:
        raise HTTPException(status_code=404, detail="Simulation not found")
    return rec


    FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
ENV SIM_DB_PATH="sqlite:///simulations.db"
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]


version: "3.8"
services:
  sim:
    build: .
    container_name: sim_service
    ports:
      - "8000:8000"
    volumes:
      - ./plots:/app/plots
      - ./simulations.db:/app/simulations.db
    environment:
      - SIM_DB_PATH=sqlite:///simulations.db


      python -m venv venv
source venv/bin/activate
pip install -r requirements.txt


uvicorn main:app --reload --host 0.0.0.0 --port 8000


docker build -t safe-sim .
docker run -p 8000:8000 -v $(pwd)/plots:/app/plots safe-sim


{
  "name": "test-run-1",
  "mass_kg": 0.001,
  "N_qubits": 3,
  "g": 1e-25,
  "vehicle_type": "car",
  "vehicle_params": {"sec_per_unit":1000, "speed_units_per_s":0.02},
  "speed_m_s": 20.0,
  "vehicle_mass_kg": 1500.0
}



    
