<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Glass Effect</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="background-content">
        <h1>Welcome to the Future!</h1>
        <p>This is some content behind the liquid glass panel.</p>
        <div class="shape red"></div>
        <div class="shape blue"></div>
        <div class="shape green"></div>
    </div>

    <div class="liquid-glass-panel">
        <h2>Liquid Glass Panel</h2>
        <p>This panel uses CSS to simulate Apple's new Liquid Glass design language.</p>
        <button>Learn More</button>
    </div>

    <script src="script.js"></script>
</body>
</html>



body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(135deg, #6dd5ed, #2193b0); /* Example vibrant background */
    overflow: hidden; /* Hide overflowing background shapes */
    position: relative;
}

.background-content {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    z-index: 1; /* Ensure background content is behind the glass */
}

.shape {
    position: absolute;
    border-radius: 50%;
    filter: blur(50px); /* Blurry background shapes */
    opacity: 0.7;
    animation: float 20s infinite ease-in-out;
}

.red {
    width: 200px;
    height: 200px;
    background-color: rgba(255, 0, 100, 0.6);
    top: 10%;
    left: 15%;
    animation-delay: 0s;
}

.blue {
    width: 250px;
    height: 250px;
    background-color: rgba(0, 100, 255, 0.6);
    bottom: 5%;
    right: 10%;
    animation-delay: 5s;
}

.green {
    width: 180px;
    height: 180px;
    background-color: rgba(0, 255, 50, 0.6);
    top: 60%;
    left: 5%;
    animation-delay: 10s;
}

@keyframes float {
    0% { transform: translate(0, 0); }
    50% { transform: translate(20px, 30px); }
    100% { transform: translate(0, 0); }
}


.liquid-glass-panel {
    /* Core Glassmorphism properties */
    background: rgba(255, 255, 255, 0.15); /* Semi-transparent white */
    backdrop-filter: blur(20px) saturate(180%); /* Key blur effect and saturation */
    -webkit-backdrop-filter: blur(20px) saturate(180%); /* For Safari compatibility */
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle translucent border */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); /* Soft shadow */

    /* Panel styling */
    padding: 40px;
    color: white;
    text-align: center;
    max-width: 400px;
    z-index: 2; /* Ensure panel is above background content */
    position: relative; /* For the pseudo-element shine */
    overflow: hidden; /* Important for containing the shine effect */

    /* Subtle "shine" or "light refraction" effect */
    &::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.1) 0%,
            rgba(255, 255, 255, 0.0) 50%,
            rgba(255, 255, 255, 0.1) 100%
        );
        pointer-events: none; /* Allows clicks to pass through */
        border-radius: inherit; /* Inherit panel's border-radius */
    }
}

.liquid-glass-panel h2 {
    margin-top: 0;
    font-size: 2em;
    font-weight: 600;
}

.liquid-glass-panel p {
    font-size: 1.1em;
    line-height: 1.6;
    margin-bottom: 30px;
}

.liquid-glass-panel button {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 12px 25px;
    border-radius: 10px;
    font-size: 1em;
    cursor: pointer;
    transition: background 0.3s ease, border 0.3s ease, transform 0.2s ease;
    backdrop-filter: blur(5px); /* Add blur to the button itself */
    -webkit-backdrop-filter: blur(5px);
}

.liquid-glass-panel button:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
}

/* JavaScript hover effect styles (optional, could be done with :hover in CSS) */
.liquid-glass-panel.hovered {
    transform: scale(1.01);
    box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45);
}



document.addEventListener('DOMContentLoaded', () => {
    const liquidGlassPanel = document.querySelector('.liquid-glass-panel');

    // Basic hover effect for a subtle "pop"
    liquidGlassPanel.addEventListener('mouseenter', () => {
        liquidGlassPanel.classList.add('hovered');
    });

    liquidGlassPanel.addEventListener('mouseleave', () => {
        liquidGlassPanel.classList.remove('hovered');
    });

    // You could add more complex effects here, like
    // parallax based on mouse movement, though true
    // "liquid" distortion would require SVG filters
    // or WebGL/Canvas for performance and realism.
});



mkdir liquid-glass-server
cd liquid-glass-server
npm init -y
npm install express



const express = require('express');
const path = require('path');
const app = express();
const port = 3000;

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Basic route for the home page
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Start the server
app.listen(port, () => {
    console.log(`Node.js server running at http://localhost:${port}`);
    console.log(`Serving front-end assets for 'Liquid Glass' simulation.`);
});



It's crucial to understand that "Apple Liquid Glass" is a software design language and aesthetic, not a physical material or a feature you can directly "code" in Node.js in the way you might process data or build an API.
Apple's Liquid Glass effect, as described in their documentation, involves:
 * Real-time rendering: It dynamically reflects and refracts its surroundings.
 * Fluidity and transformation: It responds to content and context, and elements can fluidly morph.
 * Adaptation to light/dark modes: The material intelligently adapts to the environment.
 * Reaction to device movement: Specular highlights react to tilt and motion.
 * Integration with system frameworks: Standard UI components automatically adopt this material.
Node.js is a server-side runtime environment for JavaScript. It's excellent for:
 * Building web servers (APIs, static file serving)
 * Database interactions
 * Backend logic
 * Command-line tools
 * Automation scripts
Node.js is NOT designed for:
 * Directly rendering advanced real-time graphical user interfaces (GUIs) in a browser. That's the domain of front-end JavaScript (HTML, CSS, Canvas, WebGL).
 * Performing real-time pixel manipulation for complex visual effects on a client's screen. This is handled by the client's browser or native operating system rendering engine.
What Node.js could do in relation to "Liquid Glass" (indirectly):
While Node.js can't create the visual effect on a user's screen, it could be part of a pipeline that enables or pre-processes assets for such an effect:
 * Serve front-end assets: Node.js (with Express.js or similar) can serve the HTML, CSS, JavaScript (including WebGL libraries like Three.js, Babylon.js, or Pixi.js) that would implement the Liquid Glass effect in the user's browser.
 * Image/Video Processing (for pre-rendering or dynamic backgrounds): You could use Node.js with libraries like sharp or ffmpeg-fluent to:
   * Pre-process images (e.g., apply blurs, color adjustments) that might be used as backgrounds for the "glass" effect.
   * Generate short video clips with animated backgrounds that the front-end can play.
 * Data Generation for Simulations: If you were building a highly complex, physics-based fluid simulation (which is what "liquid" implies), Node.js could potentially run the heavy-duty calculations to generate data points or textures for that simulation, which are then passed to the front-end (WebGL) for rendering. This is highly specialized.
 * WebSocket for Real-time Interaction: If your "Liquid Glass" effect needed to react to real-time events from a server (e.g., live data affecting the "fluidity"), Node.js with WebSockets (ws library or Socket.IO) could send those updates to the browser.
Example: Node.js serving a "Liquid Glass" (glassmorphism) web page
This example shows Node.js serving the kind of HTML/CSS/JS that I provided in the previous response, demonstrating its role as a server.
1. Project Setup:
Create a new directory:
mkdir liquid-glass-server
cd liquid-glass-server
npm init -y
npm install express

2. server.js (Node.js Express Server):
const express = require('express');
const path = require('path');
const app = express();
const port = 3000;

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Basic route for the home page
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Start the server
app.listen(port, () => {
    console.log(`Node.js server running at http://localhost:${port}`);
    console.log(`Serving front-end assets for 'Liquid Glass' simulation.`);
});

3. public/ directory:
Create a public directory inside your liquid-glass-server folder.
Place the index.html, style.css, and script.js files (from my previous response) inside this public directory.
File Structure:
liquid-glass-server/
├── node_modules/
├── public/
│   ├── index.html
│   ├── style.css
│   └── script.js
├── server.js
└── package.json

4. Run the Server:
node server.js

Now, open your web browser and go to http://localhost:3000. You will see the "Liquid Glass" (glassmorphism) effect rendered by your browser, served by your Node.js application.
If you really want to push "advanced graphics" with Node.js (for server-side rendering or pre-computation):
This goes beyond typical UI effects and into areas like:
 * Offscreen Canvas / Headless WebGL: Using libraries like headless-gl (StackGL) or node-canvas you could render graphics on the server (without a visible window) and then save them as images or video frames. This is useful for generating static assets or video, not for real-time interactive UI.
   * node-canvas: For 2D canvas operations. You could simulate fluid-like patterns by drawing and manipulating pixels.
   * headless-gl (StackGL) / node-webgl: For server-side WebGL rendering. This allows you to run Three.js or Babylon.js scenes on the server to generate complex 3D graphics or fluid simulations as images/frames. This is very advanced and resource-intensive.
Example (Conceptual - requires much more setup): Server-side Fluid Simulation Frame Generation
This is a highly simplified conceptual example. A real fluid simulation would involve complex physics (Navier-Stokes equations) and a rendering loop.
// This is HIGHLY conceptual and simplified.
// A real implementation would require a dedicated fluid simulation library
// and a WebGL/Canvas rendering engine on the server.

const { createCanvas } = require('canvas'); // For 2D canvas, or a headless WebGL library
const fs = require('fs');
// const Three = require('three'); // If using headless WebGL with Three.js
// const gl = require('headless-gl'); // If using headless WebGL

// Function to simulate a single frame of "liquid glass" effect
// In a real scenario, this would involve physics calculations and rendering.
function generateLiquidGlassFrame(frameNumber) {
    const width = 800;
    const height = 600;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Simulate background content (e.g., a gradient that would be blurred)
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, `hsl(${frameNumber * 5 % 360}, 70%, 50%)`);
    gradient.addColorStop(1, `hsl(${(frameNumber * 5 + 90) % 360}, 70%, 50%)`);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Simulate the "liquid glass" panel
    ctx.filter = 'blur(15px) saturate(1.8)'; // Apply blur for glass effect
    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; // Semi-transparent white
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;

    const panelX = width / 2 - 150;
    const panelY = height / 2 - 100;
    const panelWidth = 300;
    const panelHeight = 200;
    const borderRadius = 20;

    // Draw rounded rectangle for the panel
    ctx.beginPath();
    ctx.moveTo(panelX + borderRadius, panelY);
    ctx.lineTo(panelX + panelWidth - borderRadius, panelY);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY, panelX + panelWidth, panelY + borderRadius);
    ctx.lineTo(panelX + panelWidth, panelY + panelHeight - borderRadius);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY + panelHeight, panelX + panelWidth - borderRadius, panelY + panelHeight);
    ctx.lineTo(panelX + borderRadius, panelY + panelHeight);
    ctx.quadraticCurveTo(panelX, panelY + panelHeight, panelX, panelY + panelHeight - borderRadius);
    ctx.lineTo(panelX, panelY + borderRadius);
    ctx.quadraticCurveTo(panelX, panelY, panelX + borderRadius, panelY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Reset filter for text/other elements
    ctx.filter = 'none';
    ctx.fillStyle = 'white';
    ctx.font = '30px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Liquid Glass', width / 2, height / 2 - 20);
    ctx.font = '16px sans-serif';
    ctx.fillText(`Frame: ${frameNumber}`, width / 2, height / 2 + 20);


    // Save the frame as an image
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(path.join(__dirname, 'frames', `frame_${String(frameNumber).padStart(3, '0')}.png`), buffer);
    console.log(`Generated frame ${frameNumber}`);
}

const path = require('path');
const framesDir = path.join(__dirname, 'frames');

// Create frames directory if it doesn't exist
if (!fs.existsSync(framesDir)) {
    fs.mkdirSync(framesDir);
}

const numFrames = 30; // Generate 30 frames
for (let i = 0; i < numFrames; i++) {
    generateLiquidGlassFrame(i);
}

console.log(`\nGenerated ${numFrames} PNG frames in '${framesDir}'.`);
console.log('You can use FFmpeg to combine them into a video:');
console.log(`ffmpeg -framerate 10 -i ${framesDir}/frame_%03d.png -c:v libx264 -pix_fmt yuv420p output_liquid_glass.mp4`);

To run this conceptual example:
 * npm install canvas (You might need to install build-essential on Linux or Xcode Command Line Tools on macOS for canvas to compile).
 * Save the above code as generate_frames.js.
 * Run node generate_frames.js.
 * It will create PNG images in a frames/ directory.
 * Install FFmpeg on your system.
 * Run the FFmpeg command provided in the console output to create a video from the frames.
Conclusion:
While Node.js is powerful for backend operations, it's not the tool for directly rendering advanced, real-time "Liquid Glass" UI effects on the client side. That's the domain of browser-based technologies like WebGL, HTML Canvas, and advanced CSS, often powered by libraries like Three.js or Babylon.js. Node.js's role would be in serving these client-side assets or potentially pre-processing visual elements on the server for later client-side consumption.



node server.js


// This is HIGHLY conceptual and simplified.
// A real implementation would require a dedicated fluid simulation library
// and a WebGL/Canvas rendering engine on the server.

const { createCanvas } = require('canvas'); // For 2D canvas, or a headless WebGL library
const fs = require('fs');
// const Three = require('three'); // If using headless WebGL with Three.js
// const gl = require('headless-gl'); // If using headless WebGL

// Function to simulate a single frame of "liquid glass" effect
// In a real scenario, this would involve physics calculations and rendering.
function generateLiquidGlassFrame(frameNumber) {
    const width = 800;
    const height = 600;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Simulate background content (e.g., a gradient that would be blurred)
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, `hsl(${frameNumber * 5 % 360}, 70%, 50%)`);
    gradient.addColorStop(1, `hsl(${(frameNumber * 5 + 90) % 360}, 70%, 50%)`);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Simulate the "liquid glass" panel
    ctx.filter = 'blur(15px) saturate(1.8)'; // Apply blur for glass effect
    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; // Semi-transparent white
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;

    const panelX = width / 2 - 150;
    const panelY = height / 2 - 100;
    const panelWidth = 300;
    const panelHeight = 200;
    const borderRadius = 20;

    // Draw rounded rectangle for the panel
    ctx.beginPath();
    ctx.moveTo(panelX + borderRadius, panelY);
    ctx.lineTo(panelX + panelWidth - borderRadius, panelY);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY, panelX + panelWidth, panelY + borderRadius);
    ctx.lineTo(panelX + panelWidth, panelY + panelHeight - borderRadius);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY + panelHeight, panelX + panelWidth - borderRadius, panelY + panelHeight);
    ctx.lineTo(panelX + borderRadius, panelY + panelHeight);
    ctx.quadraticCurveTo(panelX, panelY + panelHeight, panelX, panelY + panelHeight - borderRadius);
    ctx.lineTo(panelX, panelY + borderRadius);
    ctx.quadraticCurveTo(panelX, panelY, panelX + borderRadius, panelY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Reset filter for text/other elements
    ctx.filter = 'none';
    ctx.fillStyle = 'white';
    ctx.font = '30px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Liquid Glass', width / 2, height / 2 - 20);
    ctx.font = '16px sans-serif';
    ctx.fillText(`Frame: ${frameNumber}`, width / 2, height / 2 + 20);


    // Save the frame as an image
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(path.join(__dirname, 'frames', `frame_${String(frameNumber).padStart(3, '0')}.png`), buffer);
    console.log(`Generated frame ${frameNumber}`);
}

const path = require('path');
const framesDir = path.join(__dirname, 'frames');

// Create frames directory if it doesn't exist
if (!fs.existsSync(framesDir)) {
    fs.mkdirSync(framesDir);
}

const numFrames = 30; // Generate 30 frames
for (let i = 0; i < numFrames; i++) {
    generateLiquidGlassFrame(i);
}

console.log(`\nGenerated ${numFrames} PNG frames in '${framesDir}'.`);
console.log('You can use FFmpeg to combine them into a video:');
console.log(`ffmpeg -framerate 10 -i ${framesDir}/frame_%03d.png -c:v libx264 -pix_fmt yuv420p output_liquid_glass.mp4`);



npx create-react-app react-liquid-glass-demo
cd react-liquid-glass-demo
npm start



/* src/components/GlassPanel/GlassPanel.module.css */
.glassPanel {
    /* Core Glassmorphism properties */
    background: rgba(255, 255, 255, 0.15); /* Semi-transparent white */
    backdrop-filter: blur(20px) saturate(180%); /* Key blur effect and saturation */
    -webkit-backdrop-filter: blur(20px) saturate(180%); /* For Safari compatibility */
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle translucent border */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); /* Soft shadow */

    /* Layout and content styling */
    padding: 40px;
    color: white;
    text-align: center;
    max-width: 400px;
    position: relative;
    overflow: hidden; /* Important for containing the shine effect */
    transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Add transition for hover */

    /* Subtle "shine" or "light refraction" effect */
    &::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.1) 0%,
            rgba(255, 255, 255, 0.0) 50%,
            rgba(255, 255, 255, 0.1) 100%
        );
        pointer-events: none; /* Allows clicks to pass through */
        border-radius: inherit; /* Inherit panel's border-radius */
    }
}

.glassPanel:hover {
    transform: translateY(-5px); /* Lift effect on hover */
    box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45); /* Enhanced shadow on hover */
}

.title {
    margin-top: 0;
    font-size: 2em;
    font-weight: 600;
}

.description {
    font-size: 1.1em;
    line-height: 1.6;
    margin-bottom: 30px;
}

.actionButton {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 12px 25px;
    border-radius: 10px;
    font-size: 1em;
    cursor: pointer;
    transition: background 0.3s ease, border 0.3s ease, transform 0.2s ease;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

.actionButton:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
}



// src/components/GlassPanel/GlassPanel.jsx
import React from 'react';
import styles from './GlassPanel.module.css';

const GlassPanel = ({ title, description, buttonText, onButtonClick, children }) => {
    return (
        <div className={styles.glassPanel}>
            {title && <h2 className={styles.title}>{title}</h2>}
            {description && <p className={styles.description}>{description}</p>}
            {children} {/* Render children passed into the component */}
            {buttonText && (
                <button className={styles.actionButton} onClick={onButtonClick}>
                    {buttonText}
                </button>
            )}
        </div>
    );
};

export default GlassPanel;



/* src/App.css */
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    min-height: 100vh;
    background: linear-gradient(135deg, #6dd5ed, #2193b0); /* Example vibrant background */
    overflow: hidden;
    display: flex; /* Use flexbox for centering */
    justify-content: center;
    align-items: center;
    position: relative;
}

.background-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    z-index: 1;
    pointer-events: none; /* Allows clicks to pass through to elements below if any */
}

.shape {
    position: absolute;
    border-radius: 50%;
    filter: blur(50px);
    opacity: 0.7;
    animation: float 20s infinite ease-in-out;
    pointer-events: none; /* Ensures shapes don't interfere with interaction */
}

.red {
    width: 200px;
    height: 200px;
    background-color: rgba(255, 0, 100, 0.6);
    top: 10%;
    left: 15%;
    animation-delay: 0s;
}

.blue {
    width: 250px;
    height: 250px;
    background-color: rgba(0, 100, 255, 0.6);
    bottom: 5%;
    right: 10%;
    animation-delay: 5s;
}

.green {
    width: 180px;
    height: 180px;
    background-color: rgba(0, 255, 50, 0.6);
    top: 60%;
    left: 5%;
    animation-delay: 10s;
}

@keyframes float {
    0% { transform: translate(0, 0); }
    50% { transform: translate(20px, 30px); }
    100% { transform: translate(0, 0); }
}



// src/App.js
import React from 'react';
import './App.css'; // Import global CSS for background
import GlassPanel from './components/GlassPanel/GlassPanel';

function App() {
    const handleButtonClick = () => {
        alert('Button Clicked!');
    };

    return (
        <div className="App">
            <div className="background-container">
                <h1>Welcome to the Future!</h1>
                <p>This is some content behind the liquid glass panel.</p>
                <div className="shape red"></div>
                <div className="shape blue"></div>
                <div className="shape green"></div>
            </div>

            <GlassPanel
                title="Advanced Liquid Glass"
                description="This React component simulates Apple's new Liquid Glass design language using CSS Glassmorphism."
                buttonText="Explore Features"
                onButtonClick={handleButtonClick}
            >
                {/* You can pass any JSX children here */}
                <p style={{ fontSize: '0.9em', color: 'rgba(255,255,255,0.7)' }}>
                    Experience the fluidity and depth.
                </p>
            </GlassPanel>
        </div>
    );
}

export default App;



npm install liquid-glass-react
# or
yarn add liquid-glass-react



import React, { useRef } from 'react';
import LiquidGlass from 'liquid-glass-react'; // Import the library
import './App.css'; // Keep the background styling from before

function App() {
    const containerRef = useRef(null); // Ref for a container to track mouse movement

    return (
        <div className="App">
            <div className="background-container" ref={containerRef}>
                {/* Background content and shapes as before */}
                <h1>Welcome to the Future!</h1>
                <p>This is some content behind the liquid glass panel.</p>
                <div className="shape red"></div>
                <div className="shape blue"></div>
                <div className="shape green"></div>
            </div>

            {/* Use the LiquidGlass component */}
            <LiquidGlass
                displacementScale={100} // Intensity of the distortion effect
                blurAmount={0.0625} // Amount of blur (0 to 1)
                saturation={140} // Saturation of the background behind the glass
                aberrationIntensity={2} // Chromatic aberration
                elasticity={0.35} // How much it stretches towards the mouse
                cornerRadius={32} // Border radius
                mode="polar" // Different displacement map modes: "standard", "polar", "prominent", "shader"
                overLight={false} // Adjusts glass darkness for light backgrounds
                // mouseContainer={containerRef} // Optional: make glass respond to mouse over a larger area
                style={{
                    position: 'absolute', // Position the glass panel over the background
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    zIndex: 2, // Ensure it's above the background
                }}
            >
                <div style={{ padding: '40px', textAlign: 'center', color: 'white' }}>
                    <h2 style={{ marginTop: 0, fontSize: '2em', fontWeight: 600 }}>
                        Real Liquid Glass Effect
                    </h2>
                    <p style={{ fontSize: '1.1em', lineHeight: 1.6, marginBottom: '30px' }}>
                        Powered by a specialized React library, this effect comes much closer to Apple's vision.
                    </p>
                    <button
                        style={{
                            background: 'rgba(255, 255, 255, 0.2)',
                            border: '1px solid rgba(255, 255, 255, 0.3)',
                            color: 'white',
                            padding: '12px 25px',
                            borderRadius: '10px',
                            fontSize: '1em',
                            cursor: 'pointer',
                            transition: 'background 0.3s ease, border 0.3s ease',
                            backdropFilter: 'blur(5px)', // Can apply a subtle backdrop-filter to the button itself
                            WebkitBackdropFilter: 'blur(5px)',
                        }}
                        onClick={() => alert('Library button clicked!')}
                    >
                        See It In Action
                    </button>
                </div>
            </LiquidGlass>
        </div>
    );
}

export default App;



npm install three @react-three/fiber @react-three/drei



// src/components/LiquidGlassCanvas/LiquidGlassCanvas.jsx
import React, { useRef, Suspense } from 'react';
import { Canvas, useFrame, extend } from '@react-three/fiber';
import { softShadows, OrbitControls } from '@react-three/drei';
import * as THREE from 'three'; // Import Three.js directly for custom materials/shaders

// Extend Three.js with custom shader material (this is a placeholder for a complex shader)
// You would write a GLSL shader to achieve true refraction and distortion.
class LiquidGlassMaterial extends THREE.ShaderMaterial {
    constructor() {
        super({
            uniforms: {
                uTexture: { value: null }, // This would be the texture of the background
                uMouse: { value: new THREE.Vector2(0, 0) },
                uTime: { value: 0 },
                uDistortionScale: { value: 0.5 },
                uChromaticAberration: { value: 0.05 }
                // ... more uniforms for refraction, color shifts, etc.
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                uniform vec2 uMouse;
                uniform float uTime;
                uniform float uDistortionScale;
                uniform float uChromaticAberration;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    // Simple distortion based on mouse and time (placeholder for complex liquid physics)
                    vec2 distortedUv = uv + sin(uv.x * 10.0 + uTime * 0.5) * uDistortionScale * 0.02
                                        + cos(uv.y * 8.0 + uTime * 0.7) * uDistortionScale * 0.03;

                    // Chromatic aberration (simple approximation)
                    vec3 colorR = texture2D(uTexture, distortedUv + vec2(uChromaticAberration, 0.0)).rgb;
                    vec3 colorG = texture2D(uTexture, distortedUv).rgb;
                    vec3 colorB = texture2D(uTexture, distortedUv - vec2(uChromaticAberration, 0.0)).rgb;

                    vec3 finalColor = vec3(colorR.r, colorG.g, colorB.b);

                    // Add a slight tint and transparency
                    gl_FragColor = vec4(finalColor * 0.9, 0.8); // Example: slightly darker, 80% opaque
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
    }
}
extend({ LiquidGlassMaterial });

// Function to render the background texture (e.g., a screenshot of the DOM)
const captureBackgroundAsTexture = async (element) => {
    // This is a complex task. You'd typically use libraries like html2canvas
    // or specifically design your scene for a dynamic background.
    // For a true Liquid Glass, you'd feed the live rendering of what's behind
    // into this texture.
    return new Promise(resolve => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = element.offsetWidth;
        tempCanvas.height = element.offsetHeight;
        const ctx = tempCanvas.getContext('2d');
        // Simplistic: Draw a dummy background for demonstration
        ctx.fillStyle = 'blue';
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        ctx.font = 'bold 40px Arial';
        ctx.fillStyle = 'yellow';
        ctx.fillText('BG Content', 50, 100);

        const texture = new THREE.CanvasTexture(tempCanvas);
        resolve(texture);
    });
};


// The actual glass mesh
function GlassMesh({ backgroundRef }) {
    const meshRef = useRef();
    const materialRef = useRef();
    const textureRef = useRef(null); // Ref to store the background texture

    // Capture initial background texture
    React.useEffect(() => {
        if (backgroundRef.current) {
            captureBackgroundAsTexture(backgroundRef.current).then(texture => {
                textureRef.current = texture;
                if (materialRef.current) {
                    materialRef.current.uniforms.uTexture.value = texture;
                }
            });
        }
    }, [backgroundRef]);

    useFrame((state) => {
        if (materialRef.current) {
            materialRef.current.uniforms.uTime.value = state.clock.getElapsedTime();
            // Optional: update mouse uniform for interaction
            // materialRef.current.uniforms.uMouse.value.set(state.mouse.x, state.mouse.y);
        }
    });

    return (
        <mesh ref={meshRef}>
            <planeGeometry args={[5, 3]} /> {/* A simple plane for the glass */}
            <liquidGlassMaterial ref={materialRef} />
        </mesh>
    );
}

softShadows(); // For better shadows (requires lights)

const LiquidGlassCanvas = ({ backgroundRef }) => {
    return (
        <Canvas
            style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                zIndex: 2, // Layer above background
                pointerEvents: 'none', // Allow interaction with content below if needed
            }}
            camera={{ position: [0, 0, 5], fov: 75 }}
        >
            <Suspense fallback={null}>
                <ambientLight intensity={0.5} />
                <pointLight position={[10, 10, 10]} intensity={1} castShadow />
                <GlassMesh backgroundRef={backgroundRef} />
            </Suspense>
            {/* <OrbitControls /> Uncomment for debugging/moving camera */}
        </Canvas>
    );
};

export default LiquidGlassCanvas;



// src/App.js
import React, { useRef } from 'react';
import './App.css';
import LiquidGlassCanvas from './components/LiquidGlassCanvas/LiquidGlassCanvas';

function App() {
    const backgroundRef = useRef(null); // Ref for the background container

    return (
        <div className="App">
            <div className="background-container" ref={backgroundRef}>
                <h1>Welcome to the Future!</h1>
                <p>This is some content behind the liquid glass panel.</p>
                <div className="shape red"></div>
                <div className="shape blue"></div>
                <div className="shape green"></div>
            </div>

            {/* This is where the WebGL canvas will render the glass effect */}
            {/* You'd typically overlay this on top of your actual UI that provides the "background" to be distorted */}
            <LiquidGlassCanvas backgroundRef={backgroundRef} />

            {/* Example of content that would appear *above* the liquid glass (e.g., buttons, text) */}
            <div style={{ position: 'absolute', zIndex: 3, color: 'white', padding: '20px', textAlign: 'center' }}>
                <h2>Interactive WebGL Glass</h2>
                <p>This is content rendered *over* the WebGL liquid glass effect.</p>
                <button
                    style={{
                        background: 'rgba(255, 255, 255, 0.2)',
                        border: '1px solid rgba(255, 255, 255, 0.3)',
                        color: 'white',
                        padding: '12px 25px',
                        borderRadius: '10px',
                        fontSize: '1em',
                        cursor: 'pointer',
                        transition: 'background 0.3s ease, border 0.3s ease',
                        backdropFilter: 'blur(5px)',
                        WebkitBackdropFilter: 'blur(5px)',
                    }}
                    onClick={() => alert('WebGL overlay button clicked!')}
                >
                    Interact Here
                </button>
            </div>
        </div>
    );
}

export default App;



import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QLabel, QVBoxLayout, QPushButton,
    QGraphicsBlurEffect, QFrame
)
from PyQt6.QtGui import QColor, QFont, QPainter, QPixmap
from PyQt6.QtCore import Qt, QSize, QPropertyAnimation, QEasingCurve

class GlassPanel(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        # Set a semi-transparent background
        self.setStyleSheet("""
            QFrame {
                background-color: rgba(255, 255, 255, 60); /* White with 60/255 opacity */
                border-radius: 20px;
                border: 1px solid rgba(255, 255, 255, 70); /* Subtle translucent border */
                /* For a subtle shine, you'd typically layer QWidgets or use QPainter */
            }
            QPushButton {
                background-color: rgba(255, 255, 255, 80); /* Slightly more opaque for button */
                border: 1px solid rgba(255, 255, 255, 100);
                border-radius: 10px;
                color: white;
                padding: 12px 25px;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 120);
                border: 1px solid rgba(255, 255, 255, 150);
            }
            QLabel {
                color: white;
            }
        """)
        self.setGraphicsEffect(self.create_shadow_effect())

        self.layout = QVBoxLayout(self)
        self.layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.setContentsMargins(40, 40, 40, 40)
        self.layout.setSpacing(20)

        title_label = QLabel("Liquid Glass Panel (PyQt)")
        title_label.setFont(QFont("Arial", 24, QFont.Weight.Bold))
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        desc_label = QLabel("This Python GUI simulates a glassmorphism effect using PyQt6 styling and effects. True background blur (backdrop-filter) is complex.")
        desc_label.setFont(QFont("Arial", 12))
        desc_label.setWordWrap(True)
        desc_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        info_label = QLabel("Interact with the elements inside!")
        info_label.setFont(QFont("Arial", 10))
        info_label.setStyleSheet("color: rgba(255, 255, 255, 180);")
        info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        button = QPushButton("Learn More")
        button.clicked.connect(self.on_button_click)

        # Apply a blur effect directly to the content inside the panel
        # This is NOT a backdrop-filter, but blurs the elements within this widget.
        # For a true backdrop-filter, you'd need to capture the background dynamically.
        blur_effect = QGraphicsBlurEffect(self)
        blur_effect.setBlurRadius(5) # Smaller blur for internal elements

        # You can apply this blur to individual widgets or a container holding them
        # For this example, we'll just show it conceptually.
        # title_label.setGraphicsEffect(blur_effect) # This blurs the text itself

        self.layout.addWidget(title_label)
        self.layout.addWidget(desc_label)
        self.layout.addWidget(info_label)
        self.layout.addWidget(button)

        # Basic hover animation for the panel itself
        self.animation = QPropertyAnimation(self, b"pos")
        self.animation.setDuration(200)
        self.animation.setEasingCurve(QEasingCurve.Type.EaseOutQuad)

    def create_shadow_effect(self):
        shadow = QGraphicsBlurEffect(self)
        shadow.setBlurRadius(30)
        shadow.setXOffset(0)
        shadow.setYOffset(8)
        return shadow

    def enterEvent(self, event):
        # Move slightly up on hover
        self.animation.setStartValue(self.pos())
        self.animation.setEndValue(self.pos() - Qt.QPoint(0, 5))
        self.animation.start()
        super().enterEvent(event)

    def leaveEvent(self, event):
        # Move back on leave
        self.animation.setStartValue(self.pos())
        self.animation.setEndValue(self.pos() + Qt.QPoint(0, 5))
        self.animation.start()
        super().leaveEvent(event)

    def on_button_click(self):
        print("Learn More button clicked!")
        # You can add more interactive elements here, e.g., show a dialog

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Python Liquid Glass Demo (PyQt)")
        self.setGeometry(100, 100, 800, 600)
        self.setMinimumSize(600, 400)

        # Set a background for the main window that the glass panel can "blur"
        # For real backdrop-filter, the background would need to be dynamic
        # or you'd capture the screen behind.
        self.setStyleSheet("""
            MainWindow {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                            stop:0 #6dd5ed, stop:1 #2193b0);
            }
        """)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.glass_panel = GlassPanel(self)
        self.main_layout.addWidget(self.glass_panel)

        # Add some background elements (purely visual for context)
        # These won't be blurred by the QGraphicsBlurEffect on GlassPanel itself
        # unless you render them to an offscreen buffer and then blur that.
        self.bg_label1 = QLabel("Background Element 1")
        self.bg_label1.setStyleSheet("color: rgba(255,255,255,0.3); font-size: 36px; font-weight: bold;")
        self.bg_label1.setAlignment(Qt.AlignmentFlag.TopLeft)
        self.bg_label1.setGeometry(50, 50, 300, 50) # Absolute positioning for background elements

        self.bg_label2 = QLabel("Background Element 2")
        self.bg_label2.setStyleSheet("color: rgba(255,255,255,0.2); font-size: 48px; font-weight: bold;")
        self.bg_label2.setAlignment(Qt.AlignmentFlag.BottomRight)
        self.bg_label2.setGeometry(self.width() - 350, self.height() - 100, 300, 50)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())



from kivy.app import App
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.properties import BoundedNumericProperty, ListProperty
from kivy.graphics import Color, Rectangle, RenderContext
from kivy.core.window import Window
from kivy.clock import Clock

# Custom Shader for Frosted Glass Effect
# This is a basic fragment shader that applies a blur effect to the background texture.
# For true "liquid" distortion and refraction, the shader would be far more complex,
# involving displacement maps, normal mapping, and advanced lighting calculations.
KV_SHADER_V = """
#version 100
attribute vec2 uv;
attribute vec2 position;
uniform mat4 modelview_mat;
uniform mat4 projection_mat;
void main() {
    gl_Position = projection_mat * modelview_mat * vec4(position.xy, 0.0, 1.0);
    v_uv = uv;
}
"""

KV_SHADER_F = """
#version 100
precision lowp float;
uniform sampler2D tex_coords;
uniform float blur_radius;
uniform vec2 resolution;
uniform float saturation;

// Function to convert RGB to HSL, adjust saturation, then back to RGB
vec3 setSaturation(vec3 color, float sat) {
    float l = dot(vec3(0.2126, 0.7152, 0.0722), color);
    return mix(vec3(l), color, sat);
}

void main() {
    // This shader works by sampling the background texture multiple times
    // around the current pixel to simulate a blur.
    // For a more efficient blur, you'd use a Gaussian blur algorithm or
    // pre-render blurred textures.

    vec4 sum = vec4(0.0);
    float total_weight = 0.0;
    float step_x = blur_radius / resolution.x;
    float step_y = blur_radius / resolution.y;

    for (float x = -blur_radius; x <= blur_radius; x += 1.0) {
        for (float y = -blur_radius; y <= blur_radius; y += 1.0) {
            float dist = sqrt(x*x + y*y);
            if (dist > blur_radius) continue;

            float weight = 1.0 - (dist / blur_radius); // Simple linear weight
            sum += texture2D(tex_coords, v_uv + vec2(x * step_x, y * step_y)) * weight;
            total_weight += weight;
        }
    }

    vec4 blurred_color = sum / total_weight;

    // Apply saturation (optional, but part of glassmorphism)
    blurred_color.rgb = setSaturation(blurred_color.rgb, saturation);

    // Add slight tint and control transparency
    gl_FragColor = vec4(blurred_color.rgb * 0.9, 0.7); // Darken slightly, 70% opacity
}
"""

class FrostedGlassWidget(FloatLayout):
    blur_radius = BoundedNumericProperty(5.0, min=0.0, max=20.0)
    saturation = BoundedNumericProperty(1.5, min=0.0, max=2.5) # 1.0 is original, >1.0 for more saturation
    _background_texture = None

    def __init__(self, **kwargs):
        self.canvas = RenderContext(use_parent_projection=True)
        self.canvas.shader.vs = KV_SHADER_V
        self.canvas.shader.fs = KV_SHADER_F
        super().__init__(**kwargs)
        self.canvas.shader.uniforms['resolution'] = [float(Window.width), float(Window.height)]
        self.bind(size=self._update_resolution, pos=self._update_resolution)

        # Force redrawing to capture background
        Clock.schedule_interval(self._capture_background, 0.05) # Capture every 50ms (can be optimized)

        with self.canvas.before:
            self.fbo_color = Color(1, 1, 1, 1)
            self.fbo_rect = Rectangle()

        self.bind(blur_radius=self._update_shader_uniforms)
        self.bind(saturation=self._update_shader_uniforms)
        self._update_shader_uniforms()

    def _update_resolution(self, *args):
        self.canvas.shader.uniforms['resolution'] = [float(Window.width), float(Window.height)]

    def _update_shader_uniforms(self, *args):
        self.canvas.shader.uniforms['blur_radius'] = self.blur_radius
        self.canvas.shader.uniforms['saturation'] = self.saturation

    def _capture_background(self, dt):
        # This is a simplified way to capture the background.
        # Kivy's FBO (Framebuffer Object) system is more robust for this.
        # We're essentially taking a "screenshot" of the region behind this widget.
        # This is very inefficient for complex scenes or frequent updates.

        # Save current buffer
        # This part is highly dependent on Kivy's internal rendering.
        # A more robust solution might involve rendering the entire scene to an FBO,
        # then applying the glass shader to a region of that FBO.
        # For simplicity, we'll mimic a basic texture pass.

        if Window.render_context:
            # Get the current window texture
            self.canvas.shader.uniforms['tex_coords'] = Window.render_context.default_texture

        # The actual blurring happens in the shader, sampling this texture.

    def on_size(self, instance, value):
        self.fbo_rect.size = value
        self._update_resolution()

    def on_pos(self, instance, value):
        self.fbo_rect.pos = value
        self._update_resolution()


class LiquidGlassApp(App):
    def build(self):
        root = FloatLayout(
            size_hint=(1, 1),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            canvas_before=self.set_background_gradient() # Set a background for the app
        )

        # Add some background elements
        root.add_widget(Label(
            text="Welcome to the Future!",
            font_size='48sp',
            color=(1, 1, 1, 0.6),
            pos_hint={'x': 0.1, 'y': 0.7},
            size_hint=(0.8, 0.2)
        ))
        root.add_widget(Label(
            text="Python Kivy Glass Demo",
            font_size='32sp',
            color=(1, 1, 1, 0.4),
            pos_hint={'x': 0.2, 'y': 0.1},
            size_hint=(0.6, 0.2)
        ))


        # The Glass Panel
        glass_panel = FrostedGlassWidget(
            size_hint=(0.6, 0.5),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            blur_radius=10.0,
            saturation=1.8 # Increased saturation for glassmorphism
        )

        # Content inside the glass panel
        glass_content_layout = BoxLayout(
            orientation='vertical',
            padding=40,
            spacing=20,
            size_hint=(1, 1)
        )
        glass_content_layout.add_widget(Label(
            text="Liquid Glass UI",
            font_size='36sp',
            bold=True,
            color=(1, 1, 1, 1)
        ))
        glass_content_layout.add_widget(Label(
            text="This panel simulates a frosted glass effect using Kivy's graphics and custom shaders.",
            font_size='16sp',
            halign='center',
            text_size=(glass_panel.width - 80, None), # Adjust text width
            color=(1, 1, 1, 0.9)
        ))
        glass_content_layout.add_widget(Button(
            text="Explore Kivy",
            size_hint=(0.5, None),
            height='48dp',
            pos_hint={'center_x': 0.5},
            background_normal='',
            background_color=(1, 1, 1, 0.2), # Semi-transparent button
            color=(1, 1, 1, 1)
        ))
        glass_panel.add_widget(glass_content_layout)

        root.add_widget(glass_panel)
        return root

    def set_background_gradient(self):
        # Create a background gradient for the entire window
        with self.root.canvas.before:
            Color(0.43, 0.83, 0.93, 1) # Start color
            Rectangle(pos=self.root.pos, size=self.root.size)
            Color(0.13, 0.57, 0.69, 1) # End color
            Rectangle(pos=self.root.pos, size=self.root.size)

if __name__ == '__main__':
    LiquidGlassApp().run()



#pragma once
#include <glad/glad.h>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>

class Shader {
public:
    unsigned int ID;

    Shader(const char* vertexPath, const char* fragmentPath) {
        // 1. Retrieve the vertex/fragment source code from filePath
        std::string vertexCode;
        std::string fragmentCode;
        std::ifstream vShaderFile;
        std::ifstream fShaderFile;

        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        try {
            vShaderFile.open(vertexPath);
            fShaderFile.open(fragmentPath);
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vShaderFile.close();
            fShaderFile.close();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
        } catch (std::ifstream::failure& e) {
            std::cout << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ: " << e.what() << std::endl;
        }
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();

        // 2. Compile shaders
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];

        // Vertex Shader
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, NULL);
        glCompileShader(vertex);
        checkCompileErrors(vertex, "VERTEX");

        // Fragment Shader
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, NULL);
        glCompileShader(fragment);
        checkCompileErrors(fragment, "FRAGMENT");

        // Shader Program
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        checkCompileErrors(ID, "PROGRAM");

        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }

    void use() {
        glUseProgram(ID);
    }

    void setMat4(const std::string& name, const float* value) const {
        glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, value);
    }
    void setInt(const std::string& name, int value) const {
        glUniform1i(glGetUniformLocation(ID, name.c_str()), value);
    }
    void setFloat(const std::string& name, float value) const {
        glUniform1f(glGetUniformLocation(ID, name.c_str()), value);
    }
    void setVec2(const std::string& name, float x, float y) const {
        glUniform2f(glGetUniformLocation(ID, name.c_str()), x, y);
    }

private:
    void checkCompileErrors(unsigned int shader, std::string type) {
        int success;
        char infoLog[1024];
        if (type != "PROGRAM") {
            glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
            if (!success) {
                glGetShaderInfoLog(shader, 1024, NULL, infoLog);
                std::cout << "ERROR::SHADER_COMPILATION_ERROR of type: " << type << "\n" << infoLog << "\n -- --------------------------------------------------- -- " << std::endl;
            }
        } else {
            glGetProgramiv(shader, GL_LINK_STATUS, &success);
            if (!success) {
                glGetProgramInfoLog(shader, 1024, NULL, infoLog);
                std::cout << "ERROR::PROGRAM_LINKING_ERROR of type: " << type << "\n" << infoLog << "\n -- --------------------------------------------------- -- " << std::endl;
            }
        }
    }
};


#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoords;

out vec2 TexCoords;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    TexCoords = aTexCoords;
}



#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D screenTexture;      // The texture of the background scene (from FBO)
uniform sampler2D displacementMap;    // Optional: for liquid-like distortion
uniform vec2 resolution;              // Screen resolution
uniform float time;                   // For animation
uniform float blurRadius;             // Controls blur intensity
uniform float refractionIndex;        // Simulated IOR (Index of Refraction)
uniform float chromaticAberration;    // For color fringing

// Simple Gaussian blur kernel (approximation, real blur uses multiple passes)
float gaussian[9] = float[](
    1.0/16.0, 2.0/16.0, 1.0/16.0,
    2.0/16.0, 4.0/16.0, 2.0/16.0,
    1.0/16.0, 2.0/16.0, 1.0/16.0
);

// Function to apply a basic blur by sampling nearby pixels
vec4 applyBlur(sampler2D tex, vec2 coords, vec2 texelSize, float radius) {
    vec4 sum = vec4(0.0);
    float count = 0.0;
    for (int x = -2; x <= 2; ++x) {
        for (int y = -2; y <= 2; ++y) {
            vec2 offset = vec2(float(x), float(y)) * texelSize * radius;
            sum += texture(tex, coords + offset);
            count += 1.0;
        }
    }
    return sum / count;
}

// Function to simulate simple refraction based on a 'normal' perturbation
vec2 refractUV(vec2 uv, vec2 normal, float ior) {
    // This is a very simplistic refraction, not physically accurate Snell's Law
    // For true refraction, you'd calculate the ray direction and sample the environment.
    vec2 refracted = uv + normal * (1.0 - ior) * 0.05; // Adjust scale for effect
    return refracted;
}


void main()
{
    vec2 texelSize = 1.0 / resolution;
    vec2 currentUV = TexCoords;

    // --- 1. Basic Distortion / Liquid Motion (Optional, requires displacementMap) ---
    // For a more dynamic 'liquid' feel, you'd animate the displacementMap
    // or generate noise for it.
    // vec2 displacement = texture(displacementMap, currentUV + time * 0.01).rg * 2.0 - 1.0;
    // currentUV += displacement * 0.05 * sin(time * 2.0); // Simple wobble

    // --- 2. Blur the background ---
    vec4 blurredColor = applyBlur(screenTexture, currentUV, texelSize, blurRadius);

    // --- 3. Simple Refraction (Simulated) ---
    // For true refraction, you'd calculate incident ray, surface normal, and use Snell's Law.
    // Here, we'll just perturb UVs. A procedural normal could be based on noise.
    vec2 pseudoNormal = vec2(
        sin(currentUV.x * 20.0 + time * 0.5) * 0.1,
        cos(currentUV.y * 15.0 + time * 0.7) * 0.1
    );
    vec2 refractedUV = refractUV(currentUV, pseudoNormal, refractionIndex);
    vec4 refractedColor = texture(screenTexture, refractedUV);

    // --- 4. Chromatic Aberration (Simplified) ---
    vec4 finalColor;
    if (chromaticAberration > 0.0) {
        vec3 colorR = texture(screenTexture, refractedUV + vec2(chromaticAberration, 0.0) * texelSize).rgb;
        vec3 colorG = texture(screenTexture, refractedUV).rgb;
        vec3 colorB = texture(screenTexture, refractedUV - vec2(chromaticAberration, 0.0) * texelSize).rgb;
        finalColor = vec4(colorR.r, colorG.g, colorB.b, 1.0);
    } else {
        finalColor = refractedColor;
    }

    // --- 5. Combine and Add Translucency / Tint ---
    // Blend blurred and refracted effects. Real liquid glass might blend based on angle.
    // Add a slight white tint and transparency, like real glass.
    FragColor = mix(blurredColor, finalColor, 0.6); // Blend factor
    FragColor.rgb *= 1.05; // Slightly lighten/tint
    FragColor.a = 0.8;    // Overall transparency (alpha)

    // Optional: Add a subtle specular highlight (requires lighting setup)
    // For dynamic highlights, you'd need light positions and surface normals.
    // vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0)); // Example light direction
    // float spec = pow(max(dot(reflect(lightDir, vec3(0,0,1)), vec3(0,0,1)), 0.0), 32.0); // Simple spec
    // FragColor.rgb += vec3(spec * 0.3);
}



#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include "Shader.h" // Your custom Shader class

// Function declarations
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// Screen dimensions
const unsigned int SCR_WIDTH = 1280;
const unsigned int SCR_HEIGHT = 720;

// Quad vertices for rendering the "glass" panel
float quadVertices[] = {
    // positions   // texCoords
    -1.0f,  1.0f,  0.0f, 1.0f,
    -1.0f, -1.0f,  0.0f, 0.0f,
     1.0f, -1.0f,  1.0f, 0.0f,

    -1.0f,  1.0f,  0.0f, 1.0f,
     1.0f, -1.0f,  1.0f, 0.0f,
     1.0f,  1.0f,  1.0f, 1.0f
};

int main() {
    // GLFW: initialize and configure
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Required on Mac
#endif

    // GLFW window creation
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Liquid Glass C++", NULL, NULL);
    if (window == NULL) {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // GLAD: load all OpenGL function pointers
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    // Configure global OpenGL state
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // For transparency

    // Build and compile our shader program
    Shader glassShader("liquid_glass.vert", "liquid_glass.frag");
    Shader backgroundShader("background.vert", "background.frag"); // For rendering background elements

    // Setup screen quad VAO
    unsigned int quadVAO, quadVBO;
    glGenVertexArrays(1, &quadVAO);
    glGenBuffers(1, &quadVBO);
    glBindVertexArray(quadVAO);
    glBindBuffer(GL_ARRAY_BUFFER, quadVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));

    // --- Framebuffer configuration ---
    unsigned int framebuffer;
    glGenFramebuffers(1, &framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

    // Create a color attachment texture
    unsigned int textureColorbuffer;
    glGenTextures(1, &textureColorbuffer);
    glBindTexture(GL_TEXTURE_2D, textureColorbuffer);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, 0);

    // Create a renderbuffer object for depth and stencil attachment (optional)
    unsigned int rbo;
    glGenRenderbuffers(1, &rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT); // Use a single renderbuffer object for both
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // Attach it
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;
    glBindFramebuffer(GL_FRAMEBUFFER, 0); // Bind back to default framebuffer

    // Shader setup for the glass
    glassShader.use();
    glassShader.setInt("screenTexture", 0); // Texture unit 0 for screenTexture
    // glassShader.setInt("displacementMap", 1); // If you have a displacement map

    // Main render loop
    while (!glfwWindowShouldClose(window)) {
        float currentFrame = static_cast<float>(glfwGetTime());

        // Input
        processInput(window);

        // --- 1. Render scene into FBO ---
        glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
        glEnable(GL_DEPTH_TEST); // Enable depth test for normal rendering

        glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // A simple background color
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Example: Render some background objects
        // (You'd have other VAOs/VBOs/shaders for these)
        backgroundShader.use();
        backgroundShader.setMat4("projection", glm::value_ptr(glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f)));
        backgroundShader.setMat4("view", glm::value_ptr(glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f))));
        // Render some simple geometry (e.g., a colored cube or sphere)
        // For this minimal example, we'll just have the background color.
        // In a real app, you'd draw your entire UI here.

        // --- 2. Render glass effect to default framebuffer ---
        glBindFramebuffer(GL_FRAMEBUFFER, 0); // Bind back to default framebuffer
        glDisable(GL_DEPTH_TEST); // Disable depth test for screen-space quad rendering
        glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // Clear with white (or original background if needed)
        glClear(GL_COLOR_BUFFER_BIT);

        glassShader.use();
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // Use the captured background
        glassShader.setFloat("time", currentFrame);
        glassShader.setVec2("resolution", (float)SCR_WIDTH, (float)SCR_HEIGHT);
        glassShader.setFloat("blurRadius", 10.0f); // Adjust as needed
        glassShader.setFloat("refractionIndex", 1.05f); // 1.0 for no refraction, higher for more
        glassShader.setFloat("chromaticAberration", 1.5f); // Adjust intensity

        glBindVertexArray(quadVAO);
        glDrawArrays(GL_TRIANGLES, 0, 6);

        // GLFW: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // Optional: de-allocate all resources once they've outlived their purpose
    glDeleteVertexArrays(1, &quadVAO);
    glDeleteBuffers(1, &quadVBO);
    glDeleteFramebuffers(1, &framebuffer);
    glDeleteTextures(1, &textureColorbuffer);
    glDeleteRenderbuffers(1, &rbo);

    glfwTerminate();
    return 0;
}

// Process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
void processInput(GLFWwindow *window) {
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// GLFW: whenever the window size changed (by OS or user resize) this callback function executes
void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    // Make sure the viewport matches the new window dimensions; note that width and
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
    // Also update FBO texture size and RBO size here if you want it to resize dynamically
}




#version 330 core
layout (location = 0) in vec3 aPos;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}



#version 330 core
out vec4 FragColor;
void main()
{
    FragColor = vec4(0.8, 0.4, 0.6, 1.0); // Simple magenta background for cubes
}




g++ main.cpp src/glad.c -o liquid_glass -Iinclude -lglfw -lGL -lX11 -lpthread -lXrandr -lXi -ldl



import SwiftUI

struct ContentView: View {
    // Define some background content to see the glass effect
    @State private var backgroundColor: Color = .blue
    @State private var showGradient: Bool = true

    var body: some View {
        ZStack {
            // Background Layer: Content that the glass will reflect/refract/blur
            if showGradient {
                LinearGradient(
                    gradient: Gradient(colors: [backgroundColor, backgroundColor.opacity(0.6).hueRotation(Angle(degrees: 90))]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: backgroundColor)
                // Add some dynamic shapes to the background
                CirclesBackground()
            } else {
                Image(systemName: "photo.fill")
                    .resizable()
                    .scaledToFill()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.gray)
                    .ignoresSafeArea()
            }


            // The Liquid Glass Panel itself
            VStack(spacing: 20) {
                Text("Liquid Glass Demo")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(.white) // Text color for contrast

                Text("Experience Apple's new Liquid Glass material.")
                    .font(.title2)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                Button("Toggle Background") {
                    showGradient.toggle()
                }
                .buttonStyle(.borderedProminent) // Applies system glass effect automatically if enabled
                .controlSize(.large)
                .tint(.white.opacity(0.5)) // Tint for the button

                Button("Change Color") {
                    backgroundColor = Color(
                        hue: Double.random(in: 0...1),
                        saturation: Double.random(in: 0.5...1),
                        brightness: Double.random(in: 0.5...1)
                    )
                }
                .buttonStyle(.bordered)
                .controlSize(.large)
                .tint(.white.opacity(0.3))
            }
            .padding(40)
            .glassEffect(in: RoundedRectangle(cornerRadius: 30)) // Apply Liquid Glass effect to the VStack
            // You can specify different shapes like Capsule(), Circle(), Rectangle()
            // .glassEffect(in: .capsule)
            // .glassEffect(in: .circle)
            // .glassEffect(in: .rect)
            .frame(width: 350, height: 450) // Fixed size for the glass panel
            .shadow(radius: 20) // Add a subtle shadow to the glass panel
            .interactive() // Make the glass panel react to touch/pointer interactions
            // For custom tinting: .glassEffect(tint: .blue.opacity(0.2), in: ...)

            // For grouping multiple glass effects for performance and morphing:
            // Wrap multiple .glassEffect() views in a GlassEffectContainer
            // GlassEffectContainer {
            //     Text("One").glassEffect()
            //     Text("Two").glassEffect()
            // }

        }
    }
}

// Helper view for dynamic background elements
struct CirclesBackground: View {
    @State private var circleOffsets: [CGSize] = Array(repeating: .zero, count: 5)
    @State private var circleColors: [Color] = Array(repeating: .clear, count: 5)
    @State private var circleScales: [CGFloat] = Array(repeating: 1.0, count: 5)

    var body: some View {
        GeometryReader { geometry in
            ForEach(0..<circleOffsets.count, id: \.self) { index in
                Circle()
                    .fill(circleColors[index].opacity(0.5))
                    .frame(width: 200 * circleScales[index], height: 200 * circleScales[index])
                    .offset(circleOffsets[index])
                    .blur(radius: 50)
                    .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: circleOffsets[index])
                    .animation(.easeInOut(duration: 8).repeatForever(autoreverses: true), value: circleColors[index])
                    .animation(.easeInOut(duration: 7).repeatForever(autoreverses: true), value: circleScales[index])
                    .onAppear {
                        randomizeCircle(index, geometry.size)
                        // Animate colors for a more "liquid" background
                        Timer.scheduledTimer(withTimeInterval: Double.random(in: 3...6), repeats: true) { _ in
                            randomizeCircle(index, geometry.size)
                        }
                    }
            }
        }
        .ignoresSafeArea()
    }

    private func randomizeCircle(_ index: Int, _ size: CGSize) {
        circleOffsets[index] = CGSize(
            width: CGFloat.random(in: -size.width/2...size.width/2),
            height: CGFloat.random(in: -size.height/2...size.height/2)
        )
        circleColors[index] = Color(
            hue: Double.random(in: 0...1),
            saturation: Double.random(in: 0.5...1),
            brightness: Double.random(in: 0.5...1)
        )
        circleScales[index] = CGFloat.random(in: 0.8...1.5)
    }
}

#Preview {
    ContentView()
}



//  LiquidGlassShaders.metal

#include <metal_stdlib>
using namespace metal;

// Our custom vertex structure
struct VertexIn {
    float4 position [[attribute(0)]];
    float2 texCoords [[attribute(1)]];
};

// Our output structure for the fragment function
struct FragmentIn {
    float4 position [[position]];
    float2 texCoords;
};

// Simple vertex shader for a quad (similar to the C++ OpenGL example)
vertex FragmentIn customVertexShader(VertexIn in [[stage_in]]) {
    FragmentIn out;
    out.position = in.position;
    out.texCoords = in.texCoords;
    return out;
}

// --- Liquid Glass Fragment Shader ---
// This shader attempts to simulate a very basic distorted blur and color shift.
// It's not physically accurate refraction but demonstrates the concept.

fragment float4 liquidGlassFragmentShader(
    FragmentIn in [[stage_in]],
    texture2d<float> backgroundTexture [[texture(0)]], // Texture of the content behind
    texture2d<float> displacementTexture [[texture(1)]], // Optional: For liquid distortion
    sampler backgroundSampler [[sampler(0)]],
    sampler displacementSampler [[sampler(1)]],
    float time [[time]],
    float2 resolution [[render_target_size]]
) {
    float2 uv = in.texCoords;
    float2 onePixel = 1.0 / resolution;

    // --- 1. Dynamic Distortion (for the "liquid" feel) ---
    // If you have a displacement map, you'd sample it here.
    // For a simple procedural distortion:
    float distortionStrength = 0.03; // How much to distort
    float waveSpeed = 1.5;
    float waveFrequency = 10.0;

    float2 distortionOffset = float2(
        sin(uv.x * waveFrequency + time * waveSpeed) * cos(uv.y * waveFrequency * 0.5 + time * waveSpeed * 0.7),
        cos(uv.y * waveFrequency + time * waveSpeed * 1.2) * sin(uv.x * waveFrequency * 0.8 + time * waveSpeed * 0.9)
    ) * distortionStrength;

    // Optional: If using a displacement texture (e.g., animated noise map)
    // float4 dispColor = displacementTexture.sample(displacementSampler, uv * 0.5 + time * 0.01);
    // float2 displacementFromMap = (dispColor.rg * 2.0 - 1.0) * distortionStrength;
    // uv += displacementFromMap;

    uv += distortionOffset;

    // Clamp UVs to avoid sampling outside the texture
    uv = clamp(uv, float2(0.0, 0.0), float2(1.0, 1.0));

    // --- 2. Blur and Refraction (Approximation) ---
    // Instead of a simple backdrop-filter, we simulate light passing through
    // by sampling the background texture at slightly offset, distorted positions.
    // For a real Gaussian blur, you'd do multiple passes or a larger sample.

    float blurRadius = 15.0; // Visual radius for the blur/sample
    float chromaticOffset = 2.0; // Pixels for chromatic aberration shift
    float blendFactor = 0.7; // How much refraction vs. blur

    // Sample for red channel (shifted)
    float4 colorR = backgroundTexture.sample(backgroundSampler, uv + float2(chromaticOffset, 0.0) * onePixel * blurRadius);
    // Sample for green channel (center)
    float4 colorG = backgroundTexture.sample(backgroundSampler, uv);
    // Sample for blue channel (shifted)
    float4 colorB = backgroundTexture.sample(backgroundSampler, uv - float2(chromaticOffset, 0.0) * onePixel * blurRadius);

    float3 finalRGB = float3(colorR.r, colorG.g, colorB.b);

    // Also get a slightly blurred version for background "bleed"
    float4 blurredBg = backgroundTexture.sample(backgroundSampler, uv);
    // A real blur would sample multiple points. This is very crude.
    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            blurredBg += backgroundTexture.sample(backgroundSampler, uv + float2(float(i), float(j)) * onePixel * blurRadius * 0.2);
        }
    }
    blurredBg /= 10.0; // Normalize crude blur


    // --- 3. Combine and Apply Transparency/Tint ---
    float4 finalColor = mix(blurredBg, float4(finalRGB, 1.0), blendFactor);
    finalColor.rgb *= 1.05; // Slight brightening
    finalColor.a = 0.75; // Overall opacity

    return finalColor;
}



import SwiftUI
import CoreImage // For CIImage based operations if needed

struct ContentView: View {
    @State private var backgroundColor: Color = .blue
    @State private var showGradient: Bool = true
    @State private var time: Double = 0.0

    // Timer to update time for shader animation
    let timer = Timer.publish(every: 0.016, on: .main, in: .common).autoconnect() // ~60 FPS

    var body: some View {
        ZStack {
            // Background Layer (the content the glass will affect)
            if showGradient {
                LinearGradient(
                    gradient: Gradient(colors: [backgroundColor, backgroundColor.opacity(0.6).hueRotation(Angle(degrees: 90))]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: backgroundColor)
                CirclesBackground()
            } else {
                Image(systemName: "photo.fill")
                    .resizable()
                    .scaledToFill()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.gray)
                    .ignoresSafeArea()
            }

            // The View that will have the custom Metal Shader applied
            VStack(spacing: 20) {
                Text("Custom Metal Glass")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(.white)

                Text("This uses a custom Metal shader for advanced effects.")
                    .font(.title2)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                Button("Toggle Background") {
                    showGradient.toggle()
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.white.opacity(0.5))

                Button("Change Color") {
                    backgroundColor = Color(
                        hue: Double.random(in: 0...1),
                        saturation: Double.random(in: 0.5...1),
                        brightness: Double.random(in: 0.5...1)
                    )
                }
                .buttonStyle(.bordered)
                .controlSize(.large)
                .tint(.white.opacity(0.3))
            }
            .padding(40)
            .frame(width: 350, height: 450)
            .shadow(radius: 20)
            .shading(
                ShaderLibrary.liquidGlassFragmentShader(
                    .float(time) // Pass time for animation
                    // If you had a displacement map texture:
                    // .image(Image("displacement_map_image").resizable())
                ),
                // This is crucial: .background gives the shader the rendered content behind the view
                // For a truly flexible "liquid glass" over any background, you'd feed in a dynamic snapshot
                // of the view hierarchy behind it. SwiftUI's `.shading()` with `.image(Image("."))`
                // on a background is the closest built-in approach.
                // For complex scenarios, you might need to render to an offscreen texture or use `RenderView`.
                .background
            )
            .onReceive(timer) { _ in
                time += 0.016 // Increment time for shader animation
            }
            // You might add .drawingGroup() for performance with complex shaders
            // or other gesture recognizers for interactive distortions.

        }
    }
}

// CirclesBackground helper view remains the same as in example 1
struct CirclesBackground: View {
    @State private var circleOffsets: [CGSize] = Array(repeating: .zero, count: 5)
    @State private var circleColors: [Color] = Array(repeating: .clear, count: 5)
    @State private var circleScales: [CGFloat] = Array(repeating: 1.0, count: 5)

    var body: some View {
        GeometryReader { geometry in
            ForEach(0..<circleOffsets.count, id: \.self) { index in
                Circle()
                    .fill(circleColors[index].opacity(0.5))
                    .frame(width: 200 * circleScales[index], height: 200 * circleScales[index])
                    .offset(circleOffsets[index])
                    .blur(radius: 50)
                    .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: circleOffsets[index])
                    .animation(.easeInOut(duration: 8).repeatForever(autoreverses: true), value: circleColors[index])
                    .animation(.easeInOut(duration: 7).repeatForever(autoreverses: true), value: circleScales[index])
                    .onAppear {
                        randomizeCircle(index, geometry.size)
                        Timer.scheduledTimer(withTimeInterval: Double.random(in: 3...6), repeats: true) { _ in
                            randomizeCircle(index, geometry.size)
                        }
                    }
            }
        }
        .ignoresSafeArea()
    }

    private func randomizeCircle(_ index: Int, _ size: CGSize) {
        circleOffsets[index] = CGSize(
            width: CGFloat.random(in: -size.width/2...size.width/2),
            height: CGFloat.random(in: -size.height/2...size.height/2)
        )
        circleColors[index] = Color(
            hue: Double.random(in: 0...1),
            saturation: Double.random(in: 0.5...1),
            brightness: Double.random(in: 0.5...1)
        )
        circleScales[index] = CGFloat.random(in: 0.8...1.5)
    }
}


#Preview {
    ContentView()
}



//  LiquidGlassShaders.metal

#include <metal_stdlib>
using namespace metal;

// Our custom vertex structure
struct VertexIn {
    float4 position [[attribute(0)]];
    float2 texCoords [[attribute(1)]];
};

// Our output structure for the fragment function
struct FragmentIn {
    float4 position [[position]];
    float2 texCoords;
};

// Simple vertex shader for a quad (similar to the C++ OpenGL example)
vertex FragmentIn customVertexShader(VertexIn in [[stage_in]]) {
    FragmentIn out;
    out.position = in.position;
    out.texCoords = in.texCoords;
    return out;
}

// --- Liquid Glass Fragment Shader ---
// This shader attempts to simulate a very basic distorted blur and color shift.
// It's not physically accurate refraction but demonstrates the concept.

fragment float4 liquidGlassFragmentShader(
    FragmentIn in [[stage_in]],
    texture2d<float> backgroundTexture [[texture(0)]], // Texture of the content behind
    texture2d<float> displacementTexture [[texture(1)]], // Optional: For liquid distortion
    sampler backgroundSampler [[sampler(0)]],
    sampler displacementSampler [[sampler(1)]],
    float time [[time]],
    float2 resolution [[render_target_size]]
) {
    float2 uv = in.texCoords;
    float2 onePixel = 1.0 / resolution;

    // --- 1. Dynamic Distortion (for the "liquid" feel) ---
    // If you have a displacement map, you'd sample it here.
    // For a simple procedural distortion:
    float distortionStrength = 0.03; // How much to distort
    float waveSpeed = 1.5;
    float waveFrequency = 10.0;

    float2 distortionOffset = float2(
        sin(uv.x * waveFrequency + time * waveSpeed) * cos(uv.y * waveFrequency * 0.5 + time * waveSpeed * 0.7),
        cos(uv.y * waveFrequency + time * waveSpeed * 1.2) * sin(uv.x * waveFrequency * 0.8 + time * waveSpeed * 0.9)
    ) * distortionStrength;

    // Optional: If using a displacement texture (e.g., animated noise map)
    // float4 dispColor = displacementTexture.sample(displacementSampler, uv * 0.5 + time * 0.01);
    // float2 displacementFromMap = (dispColor.rg * 2.0 - 1.0) * distortionStrength;
    // uv += displacementFromMap;

    uv += distortionOffset;

    // Clamp UVs to avoid sampling outside the texture
    uv = clamp(uv, float2(0.0, 0.0), float2(1.0, 1.0));

    // --- 2. Blur and Refraction (Approximation) ---
    // Instead of a simple backdrop-filter, we simulate light passing through
    // by sampling the background texture at slightly offset, distorted positions.
    // For a real Gaussian blur, you'd do multiple passes or a larger sample.

    float blurRadius = 15.0; // Visual radius for the blur/sample
    float chromaticOffset = 2.0; // Pixels for chromatic aberration shift
    float blendFactor = 0.7; // How much refraction vs. blur

    // Sample for red channel (shifted)
    float4 colorR = backgroundTexture.sample(backgroundSampler, uv + float2(chromaticOffset, 0.0) * onePixel * blurRadius);
    // Sample for green channel (center)
    float4 colorG = backgroundTexture.sample(backgroundSampler, uv);
    // Sample for blue channel (shifted)
    float4 colorB = backgroundTexture.sample(backgroundSampler, uv - float2(chromaticOffset, 0.0) * onePixel * blurRadius);

    float3 finalRGB = float3(colorR.r, colorG.g, colorB.b);

    // Also get a slightly blurred version for background "bleed"
    float4 blurredBg = backgroundTexture.sample(backgroundSampler, uv);
    // A real blur would sample multiple points. This is very crude.
    for (int i = -1; i <= 1; ++i) {
        for (int j = -1; j <= 1; ++j) {
            blurredBg += backgroundTexture.sample(backgroundSampler, uv + float2(float(i), float(j)) * onePixel * blurRadius * 0.2);
        }
    }
    blurredBg /= 10.0; // Normalize crude blur


    // --- 3. Combine and Apply Transparency/Tint ---
    float4 finalColor = mix(blurredBg, float4(finalRGB, 1.0), blendFactor);
    finalColor.rgb *= 1.05; // Slight brightening
    finalColor.a = 0.75; // Overall opacity

    return finalColor;
}



import SwiftUI
import CoreImage // For CIImage based operations if needed

struct ContentView: View {
    @State private var backgroundColor: Color = .blue
    @State private var showGradient: Bool = true
    @State private var time: Double = 0.0

    // Timer to update time for shader animation
    let timer = Timer.publish(every: 0.016, on: .main, in: .common).autoconnect() // ~60 FPS

    var body: some View {
        ZStack {
            // Background Layer (the content the glass will affect)
            if showGradient {
                LinearGradient(
                    gradient: Gradient(colors: [backgroundColor, backgroundColor.opacity(0.6).hueRotation(Angle(degrees: 90))]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: backgroundColor)
                CirclesBackground()
            } else {
                Image(systemName: "photo.fill")
                    .resizable()
                    .scaledToFill()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.gray)
                    .ignoresSafeArea()
            }

            // The View that will have the custom Metal Shader applied
            VStack(spacing: 20) {
                Text("Custom Metal Glass")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(.white)

                Text("This uses a custom Metal shader for advanced effects.")
                    .font(.title2)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                Button("Toggle Background") {
                    showGradient.toggle()
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.white.opacity(0.5))

                Button("Change Color") {
                    backgroundColor = Color(
                        hue: Double.random(in: 0...1),
                        saturation: Double.random(in: 0.5...1),
                        brightness: Double.random(in: 0.5...1)
                    )
                }
                .buttonStyle(.bordered)
                .controlSize(.large)
                .tint(.white.opacity(0.3))
            }
            .padding(40)
            .frame(width: 350, height: 450)
            .shadow(radius: 20)
            .shading(
                ShaderLibrary.liquidGlassFragmentShader(
                    .float(time) // Pass time for animation
                    // If you had a displacement map texture:
                    // .image(Image("displacement_map_image").resizable())
                ),
                // This is crucial: .background gives the shader the rendered content behind the view
                // For a truly flexible "liquid glass" over any background, you'd feed in a dynamic snapshot
                // of the view hierarchy behind it. SwiftUI's `.shading()` with `.image(Image("."))`
                // on a background is the closest built-in approach.
                // For complex scenarios, you might need to render to an offscreen texture or use `RenderView`.
                .background
            )
            .onReceive(timer) { _ in
                time += 0.016 // Increment time for shader animation
            }
            // You might add .drawingGroup() for performance with complex shaders
            // or other gesture recognizers for interactive distortions.

        }
    }
}

// CirclesBackground helper view remains the same as in example 1
struct CirclesBackground: View {
    @State private var circleOffsets: [CGSize] = Array(repeating: .zero, count: 5)
    @State private var circleColors: [Color] = Array(repeating: .clear, count: 5)
    @State private var circleScales: [CGFloat] = Array(repeating: 1.0, count: 5)

    var body: some View {
        GeometryReader { geometry in
            ForEach(0..<circleOffsets.count, id: \.self) { index in
                Circle()
                    .fill(circleColors[index].opacity(0.5))
                    .frame(width: 200 * circleScales[index], height: 200 * circleScales[index])
                    .offset(circleOffsets[index])
                    .blur(radius: 50)
                    .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: circleOffsets[index])
                    .animation(.easeInOut(duration: 8).repeatForever(autoreverses: true), value: circleColors[index])
                    .animation(.easeInOut(duration: 7).repeatForever(autoreverses: true), value: circleScales[index])
                    .onAppear {
                        randomizeCircle(index, geometry.size)
                        Timer.scheduledTimer(withTimeInterval: Double.random(in: 3...6), repeats: true) { _ in
                            randomizeCircle(index, geometry.size)
                        }
                    }
            }
        }
        .ignoresSafeArea()
    }

    private func randomizeCircle(_ index: Int, _ size: CGSize) {
        circleOffsets[index] = CGSize(
            width: CGFloat.random(in: -size.width/2...size.width/2),
            height: CGFloat.random(in: -size.height/2...size.height/2)
        )
        circleColors[index] = Color(
            hue: Double.random(in: 0...1),
            saturation: Double.random(in: 0.5...1),
            brightness: Double.random(in: 0.5...1)
        )
        circleScales[index] = CGFloat.random(in: 0.8...1.5)
    }
}


#Preview {
    ContentView()
}



import SwiftUI

struct ContentView: View {
    // Define some background content to see the glass effect
    @State private var backgroundColor: Color = Color(red: 0.2, green: 0.4, blue: 0.8) // A nice blue
    @State private var showGradient: Bool = true

    var body: some View {
        ZStack {
            // Background Layer: Content that the glass will reflect/refract/blur
            if showGradient {
                LinearGradient(
                    gradient: Gradient(colors: [backgroundColor, backgroundColor.opacity(0.6).hueRotation(Angle(degrees: 90))]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: backgroundColor)

                // Add some dynamic shapes to the background for visual interest
                CirclesBackground()
            } else {
                // Alternative background: an image
                Image(systemName: "mountain.2.fill")
                    .resizable()
                    .scaledToFill()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.gray)
                    .ignoresSafeArea()
            }

            // The Liquid Glass Panel itself
            VStack(spacing: 20) {
                Text("Liquid Glass Demo")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(.white) // Text color for contrast

                Text("Experience Apple's new Liquid Glass material, reacting to background content and interactions.")
                    .font(.title2)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                Button("Toggle Background") {
                    showGradient.toggle()
                }
                .buttonStyle(.borderedProminent) // Applies system glass effect automatically if enabled
                .controlSize(.large)
                .tint(.white.opacity(0.5)) // Tint for the button

                Button("Change Color") {
                    backgroundColor = Color(
                        hue: Double.random(in: 0...1),
                        saturation: Double.random(in: 0.5...1),
                        brightness: Double.random(in: 0.5...1)
                    )
                }
                .buttonStyle(.bordered)
                .controlSize(.large)
                .tint(.white.opacity(0.3)) // Tint for the button
            }
            .padding(40)
            // Apply the Liquid Glass effect to the VStack
            // You can specify different shapes like Capsule(), Circle(), Rectangle()
            .glassEffect(in: RoundedRectangle(cornerRadius: 30))
            // .glassEffect(in: .capsule)
            // .glassEffect(in: .circle)
            // .glassEffect(in: .rect)
            .frame(width: 350, height: 450) // Fixed size for the glass panel
            .shadow(radius: 20) // Add a subtle shadow to the glass panel
            .interactive() // Make the glass panel react to touch/pointer interactions
            // For custom tinting: .glassEffect(tint: .blue.opacity(0.2), in: ...)

            // For grouping multiple glass effects for performance and morphing:
            // GlassEffectContainer {
            //     Text("Item 1").glassEffect()
            //     Text("Item 2").glassEffect()
            // }
            // This is useful for things like a row of buttons that should merge their glass effect.
        }
    }
}

// Helper view for dynamic background elements to demonstrate the blur
struct CirclesBackground: View {
    @State private var circleOffsets: [CGSize] = Array(repeating: .zero, count: 5)
    @State private var circleColors: [Color] = Array(repeating: .clear, count: 5)
    @State private var circleScales: [CGFloat] = Array(repeating: 1.0, count: 5)

    var body: some View {
        GeometryReader { geometry in
            ForEach(0..<circleOffsets.count, id: \.self) { index in
                Circle()
                    .fill(circleColors[index].opacity(0.5))
                    .frame(width: 200 * circleScales[index], height: 200 * circleScales[index])
                    .offset(circleOffsets[index])
                    .blur(radius: 50) // Blur the background circles slightly
                    .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: circleOffsets[index])
                    .animation(.easeInOut(duration: 8).repeatForever(autoreverses: true), value: circleColors[index])
                    .animation(.easeInOut(duration: 7).repeatForever(autoreverses: true), value: circleScales[index])
                    .onAppear {
                        randomizeCircle(index, geometry.size)
                        // Animate colors for a more "liquid" background
                        Timer.scheduledTimer(withTimeInterval: Double.random(in: 3...6), repeats: true) { _ in
                            randomizeCircle(index, geometry.size)
                        }
                    }
            }
        }
        .ignoresSafeArea()
    }

    private func randomizeCircle(_ index: Int, _ size: CGSize) {
        circleOffsets[index] = CGSize(
            width: CGFloat.random(in: -size.width/2...size.width/2),
            height: CGFloat.random(in: -size.height/2...size.height/2)
        )
        circleColors[index] = Color(
            hue: Double.random(in: 0...1),
            saturation: Double.random(in: 0.5...1),
            brightness: Double.random(in: 0.5...1)
        )
        circleScales[index] = CGFloat.random(in: 0.8...1.5)
    }
}

#Preview {
    ContentView()
}



//  LiquidGlassShaders.metal
//  This file contains custom Metal shaders for a liquid glass effect.

#include <metal_stdlib>
using namespace metal;

// Our custom vertex structure (default for SwiftUI shaders)
struct VertexIn {
    float4 position [[attribute(0)]];
    float2 texCoords [[attribute(1)]];
};

// Our output structure for the fragment function
struct FragmentIn {
    float4 position [[position]];
    float2 texCoords; // UV coordinates
};

// Default vertex shader (often provided by SwiftUI or very simple for screen-space effects)
vertex FragmentIn customVertexShader(VertexIn in [[stage_in]]) {
    FragmentIn out;
    out.position = in.position;
    out.texCoords = in.texCoords;
    return out;
}

// --- Liquid Glass Fragment Shader ---
// This shader attempts to simulate a very basic distorted blur and color shift.
// It's not physically accurate refraction but demonstrates the concept.

fragment float4 liquidGlassFragmentShader(
    FragmentIn in [[stage_in]],
    texture2d<float> backgroundTexture [[texture(0)]], // The rendered content behind the view
    sampler backgroundSampler [[sampler(0)]],
    float time [[time]],                               // Current time for animation
    float2 resolution [[render_target_size]]           // Resolution of the render target
) {
    float2 uv = in.texCoords;
    float2 onePixel = 1.0 / resolution; // Size of one pixel in UV space

    // --- 1. Dynamic Distortion (for the "liquid" feel) ---
    // A simple procedural noise to simulate liquid-like surface movement.
    // For a more realistic effect, you'd use animated noise textures (displacement maps)
    // or even a fluid simulation.
    float distortionStrength = 0.04; // How much to distort (adjust this value)
    float waveSpeed = 1.8;           // Speed of the liquid waves
    float waveFrequency = 15.0;      // Frequency/density of the waves

    float2 distortionOffset = float2(
        sin(uv.x * waveFrequency + time * waveSpeed) * cos(uv.y * waveFrequency * 0.5 + time * waveSpeed * 0.7),
        cos(uv.y * waveFrequency + time * waveSpeed * 1.2) * sin(uv.x * waveFrequency * 0.8 + time * waveSpeed * 0.9)
    ) * distortionStrength;

    // Apply the distortion to the UV coordinates
    uv += distortionOffset;

    // Clamp UVs to avoid sampling outside the texture boundaries, which can cause artifacts
    uv = clamp(uv, float2(0.0, 0.0), float2(1.0, 1.0));

    // --- 2. Blur and Refraction (Approximation) ---
    // Instead of a true backdrop-filter, we simulate light passing through
    // by sampling the background texture at slightly offset, distorted positions.
    // This is a basic "box blur" by averaging a few samples.
    // For a real Gaussian blur, you'd do multiple passes or a larger, weighted sample.

    float blurRadiusPixels = 20.0; // Visual radius for the blur/sample in pixels
    float chromaticAberrationAmount = 2.0; // Pixel shift for color fringing (adjust)
    float blendRefractionVsBlur = 0.8; // How much refraction effect vs. blur (0.0=more blur, 1.0=more refraction)

    // Collect multiple samples for a crude blur/refraction effect
    float4 sumColor = float4(0.0);
    int sampleCount = 0;
    float sampleOffsetStep = 0.5; // Controls density of samples within the radius

    for (float x = -blurRadiusPixels; x <= blurRadiusPixels; x += blurRadiusPixels / 2.0) { // Larger step for performance
        for (float y = -blurRadiusPixels; y <= blurRadiusPixels; y += blurRadiusPixels / 2.0) {
            float2 offset = float2(x, y) * onePixel; // Convert pixel offset to UV space
            sumColor += backgroundTexture.sample(backgroundSampler, uv + offset);
            sampleCount++;
        }
    }
    float4 blurredBaseColor = sumColor / float(sampleCount);

    // --- Chromatic Aberration (Simplified) ---
    // Sample the background texture with slight color-specific offsets
    float3 finalRGB;
    float4 colorR = backgroundTexture.sample(backgroundSampler, uv + float2(chromaticAberrationAmount, 0.0) * onePixel);
    float4 colorG = backgroundTexture.sample(backgroundSampler, uv);
    float4 colorB = backgroundTexture.sample(backgroundSampler, uv - float2(chromaticAberrationAmount, 0.0) * onePixel);
    finalRGB = float3(colorR.r, colorG.g, colorB.b);


    // --- 3. Combine and Apply Translucency / Tint ---
    // Blend the blurred background with the chromatic-aberrated, refracted look.
    float4 finalColor = mix(blurredBaseColor, float4(finalRGB, 1.0), blendRefractionVsBlur);

    // Apply a slight brightening/tint and overall transparency
    finalColor.rgb *= 1.05; // Slightly brighten to simulate light passing through
    finalColor.a = 0.75;    // Overall transparency (adjust as needed)

    // Optional: Add subtle highlights or reflections
    // For a dynamic highlight, you'd typically need to calculate surface normals and light direction.
    // float specularity = pow(max(dot(normalize(float3(0.1, 0.1, 1.0)), normalize(float3(0.0, 0.0, 1.0))), 0.0), 64.0);
    // finalColor.rgb += float3(specularity * 0.2);

    return finalColor;
}



import SwiftUI
import CoreImage // Used for potential image processing, not strictly needed for basic shader

struct ContentView: View {
    @State private var backgroundColor: Color = Color(red: 0.2, green: 0.4, blue: 0.8)
    @State private var showGradient: Bool = true
    @State private var time: Double = 0.0 // Uniform for shader animation

    // Timer to update time for shader animation
    let timer = Timer.publish(every: 1.0 / 60.0, on: .main, in: .common).autoconnect() // ~60 FPS

    var body: some View {
        ZStack {
            // Background Layer (the content the glass will affect)
            if showGradient {
                LinearGradient(
                    gradient: Gradient(colors: [backgroundColor, backgroundColor.opacity(0.6).hueRotation(Angle(degrees: 90))]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: backgroundColor)
                CirclesBackground() // Dynamic background elements
            } else {
                Image(systemName: "mountain.2.fill")
                    .resizable()
                    .scaledToFill()
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.gray)
                    .ignoresSafeArea()
            }

            // The View that will have the custom Metal Shader applied
            VStack(spacing: 20) {
                Text("Custom Metal Glass")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(.white)

                Text("This panel uses a custom Metal shader for advanced liquid effects beyond system defaults.")
                    .font(.title2)
                    .foregroundStyle(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                Button("Toggle Background") {
                    showGradient.toggle()
                }
                .buttonStyle(.borderedProminent)
                .controlSize(.large)
                .tint(.white.opacity(0.5))

                Button("Change Color") {
                    backgroundColor = Color(
                        hue: Double.random(in: 0...1),
                        saturation: Double.random(in: 0.5...1),
                        brightness: Double.random(in: 0.5...1)
                    )
                }
                .buttonStyle(.bordered)
                .controlSize(.large)
                .tint(.white.opacity(0.3))
            }
            .padding(40)
            .frame(width: 350, height: 450)
            .shadow(radius: 20)
            .shading(
                // Reference your Metal shader function and pass uniforms
                // The ShaderLibrary is automatically generated by Xcode for your .metal file.
                ShaderLibrary.liquidGlassFragmentShader(
                    .float(time) // Pass current time for animation
                    // If you had other uniforms (e.g., blur_radius, distortion_strength), pass them here:
                    // .float(someBlurRadiusVariable)
                ),
                // This is crucial: .background gives the shader the rendered content behind the view.
                // For a truly flexible "liquid glass" over any background, you'd feed in a dynamic snapshot
                // of the view hierarchy behind it. SwiftUI's `.shading()` with `.image(Image("."))`
                // on a background is the closest built-in approach.
                // For complex scenarios (e.g., blurring arbitrary content not directly behind this view),
                // you might need to use `TimelineView` with `ImageRenderer` to capture a `UIImage`
                // of your background and then convert it to a `Shader.Image`.
                .background
            )
            .onReceive(timer) { _ in
                time += 0.016 // Increment time for shader animation
            }
            // Add .drawingGroup() for performance with complex shaders, as it renders the view to an offscreen image.
            .drawingGroup()

            // Optional: Add interactive gestures to modify shader uniforms for touch-based liquid effects
            // .gesture(DragGesture().onChanged { value in
            //     // Example: adjust a distortion strength based on drag amount
            //     // You'd need to bind a @State variable for distortion strength and pass it to the shader.
            // })
        }
    }
}

// CirclesBackground helper view remains the same as in example 1
struct CirclesBackground: View {
    @State private var circleOffsets: [CGSize] = Array(repeating: .zero, count: 5)
    @State private var circleColors: [Color] = Array(repeating: .clear, count: 5)
    @State private var circleScales: [CGFloat] = Array(repeating: 1.0, count: 5)

    var body: some View {
        GeometryReader { geometry in
            ForEach(0..<circleOffsets.count, id: \.self) { index in
                Circle()
                    .fill(circleColors[index].opacity(0.5))
                    .frame(width: 200 * circleScales[index], height: 200 * circleScales[index])
                    .offset(circleOffsets[index])
                    .blur(radius: 50)
                    .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: circleOffsets[index])
                    .animation(.easeInOut(duration: 8).repeatForever(autoreverses: true), value: circleColors[index])
                    .animation(.easeInOut(duration: 7).repeatForever(autoreverses: true), value: circleScales[index])
                    .onAppear {
                        randomizeCircle(index, geometry.size)
                        Timer.scheduledTimer(withTimeInterval: Double.random(in: 3...6), repeats: true) { _ in
                            randomizeCircle(index, geometry.size)
                        }
                    }
            }
        }
        .ignoresSafeArea()
    }

    private func randomizeCircle(_ index: Int, _ size: CGSize) {
        circleOffsets[index] = CGSize(
            width: CGFloat.random(in: -size.width/2...size.width/2),
            height: CGFloat.random(in: -size.height/2...size.height/2)
        )
        circleColors[index] = Color(
            hue: Double.random(in: 0...1),
            saturation: Double.random(in: 0.5...1),
            brightness: Double.random(in: 0.5...1)
        )
        circleScales[index] = CGFloat.random(in: 0.8...1.5)
    }
}


#Preview {
    ContentView()
}




