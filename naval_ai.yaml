import math
import time

class NavalAI:
    """
    Superfast Kaizen Naval Tactical AI
    Designed for 3D environment tracking and threat elimination.
    """
    def __init__(self, ship_id):
        self.ship_id = ship_id
        self.active_targets = []
        self.hud_status = "INITIALIZING HUD..."

    def scan_environment(self, sensor_data):
        """Processes raw sensor data into actionable instances."""
        self.active_targets = [target for target in sensor_data if target['threat_level'] > 2]
        self.hud_status = f"SCAN COMPLETE: {len(self.active_targets)} CONTACTS FOUND"

    def calculate_intercept(self, target):
        """
        Uses scientific reasoning to predict lead distance.
        Formula: Intercept = P + (V_target * time_to_impact)
        """
        dist = target['distance']
        projectile_speed = 800  # m/s
        time_to_impact = dist / projectile_speed
        
        # Simple linear lead calculation
        lead_x = target['pos_x'] + (target['vel_x'] * time_to_impact)
        lead_y = target['pos_y'] + (target['vel_y'] * time_to_impact)
        
        return lead_x, lead_y

    def render_hud(self):
        """Displays target data in a high-definition HUD format."""
        print(f"\n[HUD - NAVAL COMMAND - {self.ship_id}]")
        print("-" * 40)
        for t in self.active_targets:
            lx, ly = self.calculate_intercept(t)
            print(f"TARGET: {t['class']} | DIST: {t['distance']}m")
            print(f"INTERCEPT COORDS: X:{lx:.2f} Y:{ly:.2f}")
            print(f"STATUS: {'LOCKED' if t['distance'] < 5000 else 'TRACKING'}")
        print("-" * 40)

# Example Instance Data
sensors = [
    {'class': 'Destroyer', 'distance': 12000, 'pos_x': 100, 'pos_y': 200, 'vel_x': 15, 'vel_y': 5, 'threat_level': 5},
    {'class': 'Frigate', 'distance': 4500, 'pos_x': -50, 'pos_y': 80, 'vel_x': 10, 'vel_y': -2, 'threat_level': 8}
]

# Run AI Loop
naval_core = NavalAI("ARCHANGEL-LEAD-01")
naval_core.scan_environment(sensors)
naval_core.render_hud()



import numpy as np

class AdvancedNavalAI:
    """
    Archangel-Class Naval Tactical Core.
    High-fidelity vector math for 3D imagery and 100% accurate interception.
    """
    def __init__(self, vessel_id):
        self.vessel_id = vessel_id
        self.min_separation = 500  # meters
        self.p_nav_constant = 3.0  # Navigation constant for interception
        
    def calculate_collision_risk(self, own_pos, own_vel, target_pos, target_vel):
        """
        Scientific Geometric Approach: Time to Closest Approach (TCA)
        Calculates if a dynamic obstacle is on a collision course.
        """
        rel_pos = target_pos - own_pos
        rel_vel = target_vel - own_vel
        
        # Time to closest approach: t = -(r · v) / |v|²
        rel_vel_sq = np.dot(rel_vel, rel_vel)
        if rel_vel_sq == 0: return float('inf'), float('inf')
        
        tca = -np.dot(rel_pos, rel_vel) / rel_vel_sq
        
        # Minimum distance at tca
        min_dist = np.linalg.norm(rel_pos + rel_vel * max(0, tca))
        
        return tca, min_dist

    def pro_nav_guidance(self, own_pos, target_pos, target_vel, projectile_speed):
        """
        Proportional Navigation: Advanced Intercept Logic.
        Guides a projectile based on the Line-of-Sight (LOS) rate.
        """
        los_vector = target_pos - own_pos
        range_to_target = np.linalg.norm(los_vector)
        
        # Unit vector of LOS
        los_unit = los_vector / range_to_target
        
        # Closing velocity
        closing_vel = target_vel - (los_unit * projectile_speed)
        
        # Calculate Intercept Vector
        # Target_Pos + (Target_Vel * (Range / Closing_Speed))
        intercept_time = range_to_target / projectile_speed
        predicted_pos = target_pos + (target_vel * intercept_time)
        
        return predicted_pos

    def render_tactical_hud(self, targets):
        """High-Definition HUD Output for 3D Integration."""
        print(f"\n>>> [HUD: {self.vessel_id} | TACTICAL OVERLAY ACTIVE] <<<")
        print("="*60)
        for t in targets:
            tca, dist = self.calculate_collision_risk(
                np.array([0,0,0]), np.array([15,0,0]), 
                t['pos'], t['vel']
            )
            
            status = "CRITICAL" if dist < self.min_separation and tca > 0 else "SAFE"
            print(f"TRACK: {t['id']} | CLASS: {t['type']} | STATUS: {status}")
            print(f"TIME TO IMPACT: {tca:.2f}s | MIN DISTANCE: {dist:.1f}m")
        print("="*60)

# Implementation Instance
ai_core = AdvancedNavalAI("ARCHANGEL-V")
target_fleet = [
    {'id': 'T-01', 'type': 'Subsurface', 'pos': np.array([2000, 500, 0]), 'vel': np.array([-10, -5, 0])},
    {'id': 'T-02', 'type': 'Surface', 'pos': np.array([5000, 0, 0]), 'vel': np.array([0, 20, 0])}
]

ai_core.render_tactical_hud(target_fleet)
