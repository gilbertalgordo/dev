<!DOCTYPE html>
<html>
<head>
    <title>TensorFlow.js Linear Regression</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
</head>
<body>
    <h1>TensorFlow.js Linear Regression Example</h1>
    <p>Check the browser console (F12) for the training process and prediction result.</p>
    <script src="index.js"></script>
</body>
</html>



// Function to create and compile the simple linear model
function createModel() {
    // A sequential model is a linear stack of layers. 
    const model = tf.sequential();

    // Add a single dense layer (the core of a linear regression model)
    // units: 1 (The output is a single number, y)
    // inputShape: [1] (The input is a single number, x)
    model.add(tf.layers.dense({ units: 1, inputShape: [1] }));

    // Compile the model: define the loss function and optimizer
    // loss: 'meanSquaredError' (Standard for regression problems)
    // optimizer: 'sgd' (Stochastic Gradient Descent, a simple optimizer)
    model.compile({
        loss: 'meanSquaredError',
        optimizer: 'sgd'
    });

    return model;
}

// Function to train the model
async function trainModel(model, xs, ys) {
    console.log("Starting model training...");
    
    // Train the model
    const history = await model.fit(xs, ys, {
        epochs: 500, // Number of times to iterate over the data
        callbacks: {
            onEpochEnd: (epoch, logs) => {
                // Log the loss every 50 epochs to track learning progress
                if (epoch % 50 === 0) {
                    console.log(`Epoch ${epoch}: Loss = ${logs.loss.toFixed(4)}`);
                }
            }
        }
    });
    
    console.log("Training complete!");
    // Optional: Log the final loss
    console.log(`Final Loss: ${history.history.loss[history.history.loss.length - 1].toFixed(4)}`);
}

// Function to make a prediction
function predict(model, inputValue) {
    // Convert the input value to a tensor
    const inputTensor = tf.tensor2d([inputValue], [1, 1]);

    // Make the prediction
    const predictionTensor = model.predict(inputTensor);

    // Get the actual number from the tensor
    const predictionValue = predictionTensor.dataSync()[0];

    return predictionValue;
}

// --- Main execution block ---
async function run() {
    // 1. Define Training Data (The model will learn the relationship y = 2x - 1)
    const xs = tf.tensor2d([1, 2, 3, 4, 5], [5, 1]); // Input features (x values)
    const ys = tf.tensor2d([1, 3, 5, 7, 9], [5, 1]); // Labels (y values)
    
    // 2. Create the model
    const model = createModel();

    // 3. Train the model
    await trainModel(model, xs, ys);

    // 4. Make a prediction (Expected output for x=10 should be close to 2*10 - 1 = 19)
    const inputValue = 10;
    const outputValue = predict(model, inputValue);

    // 5. Display the result
    console.log(`\n--- Prediction Result ---`);
    console.log(`Input (x): ${inputValue}`);
    console.log(`Predicted Output (y): ${outputValue.toFixed(4)}`);
    console.log(`-------------------------`);
}

// Start the AI process
run();



<!DOCTYPE html>
<html>
<head>
    <title>Advanced TensorFlow.js CNN</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
</head>
<body>
    <h1>Advanced AI: Convolutional Neural Network (CNN)</h1>
    <p>This example trains a CNN model. Please open the browser console (F12) to monitor the progress and results.</p>
    <script src="index.js"></script>
</body>
</html>



/**
 * Creates and compiles a Convolutional Neural Network (CNN) model.
 * A CNN is typically used for image processing tasks.
 * 
 */
function createCnnModel(imageShape, numClasses) {
    // 1. Define the Sequential model structure
    const model = tf.sequential();

    // 2. Convolutional Layer 1
    // This layer learns feature maps (like edges, textures) from the image.
    model.add(tf.layers.conv2d({
        inputShape: imageShape, // e.g., [28, 28, 1] for 28x28 grayscale image
        kernelSize: 5,         // The size of the sliding window
        filters: 8,            // Number of feature maps (outputs)
        activation: 'relu',    // The Rectified Linear Unit activation function
    }));

    // 3. Max Pooling Layer 1
    // This layer downsamples the feature maps, reducing the computational load.
    model.add(tf.layers.maxPooling2d({ poolSize: [2, 2], strides: [2, 2] }));

    // 4. Convolutional Layer 2
    model.add(tf.layers.conv2d({
        kernelSize: 5,
        filters: 16,
        activation: 'relu',
    }));

    // 5. Max Pooling Layer 2
    model.add(tf.layers.maxPooling2d({ poolSize: [2, 2], strides: [2, 2] }));

    // 6. Flatten Layer
    // Flattens the 3D output of the convolutional layers into a 1D vector
    // to feed into the final dense layer.
    model.add(tf.layers.flatten());

    // 7. Dense (Output) Layer
    // This is the final layer for classification.
    // 'softmax' activation ensures the output is a probability distribution (summing to 1).
    model.add(tf.layers.dense({ units: numClasses, activation: 'softmax' }));

    // 8. Compile the model
    model.compile({
        optimizer: tf.train.adam(), // A more advanced and fast optimizer than 'sgd'
        loss: 'categoricalCrossentropy', // Standard loss for multi-class classification
        metrics: ['accuracy']
    });

    console.log('CNN Model Summary:');
    model.summary();
    return model;
}

/**
 * Generates synthetic (dummy) image data for demonstration purposes.
 * In a real application, you would load a dataset like MNIST.
 */
function generateData(imageShape, numClasses, numSamples) {
    const totalPixels = imageShape[0] * imageShape[1] * imageShape[2];
    
    // Create random input data (X)
    const xs = tf.randomUniform([numSamples, ...imageShape]);
    
    // Create one-hot encoded random labels (Y)
    // One-hot encoding means a class of 3 would be [0, 0, 1]
    const labels = tf.randomUniform([numSamples, numClasses], 0, numClasses, 'int32');
    const ys = tf.oneHot(labels.squeeze(), numClasses);
    
    return { xs, ys };
}


// --- Main execution block ---
async function run() {
    // Configuration for a simulated 28x28 grayscale image dataset with 10 classes (like MNIST)
    const IMAGE_SHAPE = [28, 28, 1]; 
    const NUM_CLASSES = 10;
    const NUM_SAMPLES = 50; // Use a small number of samples for fast demo

    // 1. Create the CNN Model
    const model = createCnnModel(IMAGE_SHAPE, NUM_CLASSES);

    // 2. Generate Data (Simulated loading/preprocessing)
    console.log('\nGenerating synthetic data...');
    const { xs, ys } = generateData(IMAGE_SHAPE, NUM_CLASSES, NUM_SAMPLES);
    console.log(`Input data shape: ${xs.shape}`);
    console.log(`Label data shape: ${ys.shape}`);

    // 3. Train the Model
    console.log('\nStarting advanced training process...');
    await model.fit(xs, ys, {
        batchSize: 10,
        epochs: 10, // Fewer epochs for a quick example
        shuffle: true,
        callbacks: {
            onEpochEnd: (epoch, logs) => {
                console.log(`Epoch ${epoch + 1}: Loss = ${logs.loss.toFixed(4)}, Accuracy = ${logs.acc.toFixed(4)}`);
            }
        }
    });
    console.log('Training complete!');

    // 4. Make a Prediction (Inference)
    // Create a single random input tensor to classify
    const testImage = tf.randomUniform([1, ...IMAGE_SHAPE]);
    const prediction = model.predict(testImage);
    
    // Get the index of the highest probability (the predicted class)
    const predictedClass = prediction.argMax(-1).dataSync()[0]; 
    
    console.log(`\n--- Advanced Prediction Result ---`);
    console.log(`Model classified the test image into class: ${predictedClass}`);
    
    // Dispose of the tensors to free up GPU/CPU memory
    xs.dispose();
    ys.dispose();
    testImage.dispose();
    prediction.dispose();
    tf.dispose(model);
}

// Execute the advanced AI code
run();
