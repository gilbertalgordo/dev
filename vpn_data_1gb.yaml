<manifest ...>
  <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
  <application ...>
    <service
        android:name=".DayCapVpnService"
        android:permission="android.permission.BIND_VPN_SERVICE"
        android:exported="true">
      <intent-filter>
        <action android:name="android.net.VpnService" />
      </intent-filter>
    </service>
  </application>
</manifest>


package com.example.daycapvpn

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Intent
import android.net.VpnService
import android.os.Build
import android.os.ParcelFileDescriptor
import android.util.Log
import kotlinx.coroutines.*
import java.io.FileInputStream
import java.io.FileOutputStream
import java.nio.ByteBuffer
import java.util.concurrent.atomic.AtomicLong

class DayCapVpnService : VpnService() {
    private val TAG = "DayCapVpn"
    private var vpnInterface: ParcelFileDescriptor? = null
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private val dailyLimitBytes = 1L * 1024 * 1024 * 1024 // 1 GiB
    private val usedBytes = AtomicLong(0L)
    private var monitorJob: Job? = null

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
        startForeground(NOTIF_ID, buildNotification("Starting DayCap VPN"))
        loadUsageFromPrefs()
        scheduleMidnightReset()
    }

    override fun onDestroy() {
        scope.cancel()
        vpnInterface?.close()
        super.onDestroy()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        scope.launch {
            startVpn()
        }
        return START_STICKY
    }

    private suspend fun startVpn() {
        // If already established, ignore
        if (vpnInterface != null) return

        val builder = Builder()
        // Configure a simple local VPN: no DNS or routes to the world, just intercept device traffic
        builder.setSession("DayCapVPN")
        // Intercept all traffic (0.0.0.0/0) — this requires a real implementation to forward packets;
        // for counting-only we can still capture bytes read from the tun file descriptor.
        builder.addAddress("10.0.0.2", 32) // local address for VPN interface
        builder.addRoute("0.0.0.0", 0)

        val mtu = 1500
        builder.setMtu(mtu)

        // Establish the interface (this prompts the user the first time)
        vpnInterface = builder.establish()
        if (vpnInterface == null) {
            Log.e(TAG, "Failed to establish VPN (user denied?)")
            stopSelf()
            return
        }

        // Start monitoring traffic
        monitorJob = scope.launch {
            monitorVpnTraffic(vpnInterface!!)
        }
        updateNotification("DayCap VPN active — used ${humanReadable(usedBytes.get())} / 1 GB")
    }

    private suspend fun monitorVpnTraffic(pfd: ParcelFileDescriptor) {
        val input = FileInputStream(pfd.fileDescriptor)
        val output = FileOutputStream(pfd.fileDescriptor)
        val buffer = ByteArray(32768)
        while (isActive) {
            // Read any inbound packets (device -> network)
            val read = try {
                input.read(buffer)
            } catch (e: Exception) {
                Log.e(TAG, "Read error: ${e.message}")
                -1
            }
            if (read > 0) {
                usedBytes.addAndGet(read.toLong())
                saveUsageToPrefs()
            }

            // Check threshold
            if (usedBytes.get() >= dailyLimitBytes) {
                // We have reached or exceeded daily cap — block further traffic.
                // Simplest approach: sleep loop and update notification until midnight reset.
                updateNotification("Daily cap reached. Blocking data until reset.")
                // Optionally drop packets by not writing them back out.
                delay(10_000)
                continue
            }

            // In a real VPN you'd forward packets to the remote and back.
            // In this skeleton we simply discard or echo back minimally.
            // To keep things simple and safe, we won't forward traffic; this effectively blocks network
            // unless you implement full user-space forwarding or proxying.
            // Sleep a short while to avoid busy loop
            delay(50)
        }
    }

    // ----- persistence -----
    private fun saveUsageToPrefs() {
        val prefs = getSharedPreferences("daycap", MODE_PRIVATE)
        prefs.edit().putLong("usedBytes", usedBytes.get()).apply()
    }

    private fun loadUsageFromPrefs() {
        val prefs = getSharedPreferences("daycap", MODE_PRIVATE)
        usedBytes.set(prefs.getLong("usedBytes", 0L))
    }

    private fun scheduleMidnightReset() {
        // Simple coroutine that wakes every minute, checks date rollover and resets if needed.
        scope.launch {
            var lastDay = currentDayOfYear()
            while (isActive) {
                delay(60_000)
                val nowDay = currentDayOfYear()
                if (nowDay != lastDay) {
                    usedBytes.set(0L)
                    saveUsageToPrefs()
                    lastDay = nowDay
                    updateNotification("Daily usage reset. 0 / 1 GB used.")
                }
            }
        }
    }

    // ----- notifications -----
    private val NOTIF_ID = 1
    private val CHANNEL_ID = "daycap_vpn"

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val nm = getSystemService(NotificationManager::class.java)
            val chan = NotificationChannel(CHANNEL_ID, "DayCap VPN", NotificationManager.IMPORTANCE_LOW)
            nm.createNotificationChannel(chan)
        }
    }

    private fun buildNotification(content: String): Notification {
        val intent = Intent(this, MainActivity::class.java)
        val pi = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE)
        return Notification.Builder(this, CHANNEL_ID)
            .setContentTitle("DayCap VPN")
            .setContentText(content)
            .setSmallIcon(android.R.drawable.stat_sys_upload)
            .setContentIntent(pi)
            .build()
    }

    private fun updateNotification(content: String) {
        val nm = getSystemService(NotificationManager::class.java)
        nm.notify(NOTIF_ID, buildNotification(content))
    }

    private fun humanReadable(bytes: Long): String {
        val kb = 1024.0
        val mb = kb * 1024.0
        val gb = mb * 1024.0
        val d = bytes.toDouble()
        return when {
            d >= gb -> String.format("%.2f GB", d / gb)
            d >= mb -> String.format("%.2f MB", d / mb)
            d >= kb -> String.format("%.2f KB", d / kb)
            else -> "$bytes B"
        }
    }

    private fun currentDayOfYear(): Int {
        val cal = java.util.Calendar.getInstance()
        return cal.get(java.util.Calendar.DAY_OF_YEAR)
    }
}
