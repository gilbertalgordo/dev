# finance_ai_assistant.py

import json
import hashlib
from datetime import datetime
from collections import defaultdict
import random # For simulating anti-spy detection

# --- Security & Anti-Spy Module (Highly Simplified) ---
class AntiSpy:
    def __init__(self, user_id):
        self.user_id = user_id
        self.access_logs = []
        self.data_hashes = {} # Store hashes of sensitive data for integrity checks
        self.suspicious_patterns = [
            "unusual data export",
            "multiple failed login attempts",
            "access from unknown IP",
            "sudden large transfer"
        ]

    def _hash_data(self, data):
        """Generates a SHA256 hash of the data for integrity checking."""
        return hashlib.sha256(json.dumps(data, sort_keys=True).encode('utf-8')).hexdigest()

    def log_access(self, action, data_accessed=None, ip_address="UNKNOWN"):
        """Logs user and system access."""
        timestamp = datetime.now().isoformat()
        log_entry = {
            "timestamp": timestamp,
            "user_id": self.user_id,
            "action": action,
            "data_accessed": data_accessed,
            "ip_address": ip_address
        }
        self.access_logs.append(log_entry)
        # In a real system, these logs would be securely stored and monitored

    def monitor_data_integrity(self, data_category, current_data):
        """Monitors integrity of specific data categories."""
        current_hash = self._hash_data(current_data)
        if data_category not in self.data_hashes:
            self.data_hashes[data_category] = current_hash
            print(f"[{datetime.now().isoformat()}] AntiSpy: Initial hash set for {data_category}.")
            return True
        elif self.data_hashes[data_category] != current_hash:
            print(f"[{datetime.now().isoformat()}] AntiSpy ALERT: Data integrity breach detected in {data_category}!")
            return False
        return True

    def detect_suspicious_activity(self):
        """Simulates detection of suspicious activity."""
        # This is extremely rudimentary. Real detection would use ML on logs, network traffic, etc.
        if random.random() < 0.05:  # 5% chance of a "suspicious" event
            suspicion = random.choice(self.suspicious_patterns)
            print(f"[{datetime.now().isoformat()}] AntiSpy ALERT: Potential suspicious activity detected - {suspicion} for user {self.user_id}!")
            return True
        return False

    def encrypt_data(self, data):
        """Placeholder for data encryption. In reality, use a robust library like PyCryptodome."""
        # This is NOT real encryption.
        encrypted_data = "".join(chr(ord(c) + 1) for c in json.dumps(data))
        print(f"[{datetime.now().isoformat()}] Data encrypted (placeholder).")
        return encrypted_data

    def decrypt_data(self, encrypted_data):
        """Placeholder for data decryption."""
        # This is NOT real decryption.
        decrypted_data = "".join(chr(ord(c) - 1) for c in encrypted_data)
        print(f"[{datetime.now().isoformat()}] Data decrypted (placeholder).")
        return json.loads(decrypted_data)


# --- Financial Data Model ---
class Transaction:
    def __init__(self, date, description, amount, type, category="Uncategorized"):
        self.date = date
        self.description = description
        self.amount = float(amount)
        self.type = type # "income" or "expense"
        self.category = category

    def to_dict(self):
        return self.__dict__

class Account:
    def __init__(self, name, type, balance=0.0):
        self.name = name
        self.type = type
        self.balance = balance
        self.transactions = []

    def add_transaction(self, transaction):
        self.transactions.append(transaction)
        if transaction.type == "expense":
            self.balance -= transaction.amount
        else:
            self.balance += transaction.amount

    def get_transactions_by_category(self):
        categorized_transactions = defaultdict(list)
        for t in self.transactions:
            categorized_transactions[t.category].append(t.to_dict())
        return dict(categorized_transactions)

    def to_dict(self):
        return {
            "name": self.name,
            "type": self.type,
            "balance": self.balance,
            "transactions": [t.to_dict() for t in self.transactions]
        }

# --- AI Finance Assistant Core (Simplified) ---
class FinanceAI:
    def __init__(self, user_name, anti_spy_agent):
        self.user_name = user_name
        self.accounts = {}
        self.anti_spy = anti_spy_agent
        print(f"Finance AI for {user_name} initialized.")

    def add_account(self, account_name, account_type, initial_balance=0.0):
        if account_name not in self.accounts:
            account = Account(account_name, account_type, initial_balance)
            self.accounts[account_name] = account
            self.anti_spy.log_access(f"Added account: {account_name}")
            self.anti_spy.monitor_data_integrity("accounts", self.get_all_account_data())
            print(f"Account '{account_name}' added.")
        else:
            print(f"Account '{account_name}' already exists.")

    def record_transaction(self, account_name, date, description, amount, type, category="Uncategorized"):
        if account_name in self.accounts:
            transaction = Transaction(date, description, amount, type, category)
            self.accounts[account_name].add_transaction(transaction)
            self.anti_spy.log_access(f"Recorded transaction in {account_name}")
            self.anti_spy.monitor_data_integrity("transactions", self.get_all_account_data())
            print(f"Transaction recorded for '{account_name}': {description} ({amount})")
        else:
            print(f"Account '{account_name}' not found.")

    def get_net_worth(self):
        total_balance = sum(account.balance for account in self.accounts.values())
        self.anti_spy.log_access("Checked net worth")
        return total_balance

    def get_spending_by_category(self):
        spending_by_cat = defaultdict(float)
        for account in self.accounts.values():
            for transaction in account.transactions:
                if transaction.type == "expense":
                    spending_by_cat[transaction.category] += transaction.amount
        self.anti_spy.log_access("Generated spending report by category")
        return dict(spending_by_cat)

    def provide_financial_advice(self):
        # This would be a sophisticated ML model in a real AI.
        net_worth = self.get_net_worth()
        spending = self.get_spending_by_category()
        advice = []

        if net_worth < 0:
            advice.append("Your net worth is negative. Focus on reducing debt and increasing income.")
        else:
            advice.append(f"Your current net worth is ${net_worth:,.2f}.")

        # Simple advice based on spending
        if "Food" in spending and spending["Food"] > 500: # Arbitrary threshold
            advice.append("Consider reviewing your 'Food' expenses; they seem a bit high.")
        if "Entertainment" in spending and spending["Entertainment"] > 300: # Arbitrary threshold
            advice.append("You might save more by cutting back on 'Entertainment'.")

        self.anti_spy.log_access("Provided financial advice")
        return "\n".join(advice)

    def get_all_account_data(self):
        """Returns all account data as a dictionary for hashing/encryption."""
        return {name: account.to_dict() for name, account in self.accounts.items()}

# --- Earnings Collector (Simplified) ---
class EarningsCollector:
    def __init__(self, user_name, anti_spy_agent):
        self.user_name = user_name
        self.expected_earnings = [] # For tracking invoices/expected payments
        self.collected_earnings = []
        self.anti_spy = anti_spy_agent

    def add_expected_earning(self, source, amount, due_date):
        earning = {"source": source, "amount": amount, "due_date": due_date, "status": "expected"}
        self.expected_earnings.append(earning)
        self.anti_spy.log_access(f"Added expected earning: {source} - {amount}")
        print(f"Expected earning added: {source} - ${amount} by {due_date}")

    def record_collected_earning(self, source, amount):
        collected_date = datetime.now().isoformat()
        earning = {"source": source, "amount": amount, "collected_date": collected_date}
        self.collected_earnings.append(earning)
        # Update expected earnings status if applicable (more complex in real app)
        self.anti_spy.log_access(f"Recorded collected earning: {source} - {amount}")
        print(f"Collected earning recorded: {source} - ${amount}")

    def get_uncollected_earnings(self):
        uncollected = [e for e in self.expected_earnings if e["status"] == "expected"]
        self.anti_spy.log_access("Checked uncollected earnings")
        return uncollected

    def generate_earnings_report(self):
        total_collected = sum(e["amount"] for e in self.collected_earnings)
        report = f"--- Earnings Report for {self.user_name} ---\n"
        report += f"Total Collected Earnings: ${total_collected:,.2f}\n"
        if self.expected_earnings:
            report += "\nExpected Earnings:\n"
            for e in self.expected_earnings:
                report += f"- {e['source']}: ${e['amount']} (Due: {e['due_date']}, Status: {e['status']})\n"
        self.anti_spy.log_access("Generated earnings report")
        return report

# --- Main Application Logic ---
if __name__ == "__main__":
    gilbert_id = "gilbert_algordo_123"

    # Initialize Anti-Spy Module
    anti_spy = AntiSpy(gilbert_id)

    # Initialize Finance AI and Earnings Collector
    finance_ai = FinanceAI(gilbert_id, anti_spy)
    earnings_collector = EarningsCollector(gilbert_id, anti_spy)

    print("\n--- Setting up Gilbert's accounts ---")
    finance_ai.add_account("Checking", "bank", 1500.00)
    finance_ai.add_account("Savings", "bank", 5000.00)
    finance_ai.add_account("Investments", "brokerage", 10000.00)

    print("\n--- Recording transactions ---")
    finance_ai.record_transaction("Checking", "2025-07-20", "Groceries", 75.50, "expense", "Food")
    finance_ai.record_transaction("Checking", "2025-07-21", "Electricity Bill", 120.00, "expense", "Utilities")
    finance_ai.record_transaction("Savings", "2025-07-22", "Transfer from Checking", 200.00, "income", "Transfer")
    finance_ai.record_transaction("Checking", "2025-07-23", "Freelance Payment", 800.00, "income", "Freelance")
    finance_ai.record_transaction("Checking", "2025-07-23", "Dinner with friends", 90.00, "expense", "Food")

    print("\n--- Checking financial status ---")
    print(f"Gilbert's Net Worth: ${finance_ai.get_net_worth():,.2f}")
    print("\nSpending by Category:")
    for category, amount in finance_ai.get_spending_by_category().items():
        print(f"- {category}: ${amount:,.2f}")

    print("\n--- Getting financial advice ---")
    print(finance_ai.provide_financial_advice())

    print("\n--- Managing Earnings ---")
    earnings_collector.add_expected_earning("Consulting Project A", 1500.00, "2025-08-01")
    earnings_collector.add_expected_earning("Blog Ad Revenue", 250.00, "2025-07-30")
    earnings_collector.record_collected_earning("Consulting Project A", 1500.00) # Simulate collection

    print("\n--- Earnings Report ---")
    print(earnings_collector.generate_earnings_report())

    print("\n--- Anti-Spy Detections & Logging ---")
    # Simulate some activity for anti-spy to log/detect
    _ = finance_ai.get_net_worth()
    _ = earnings_collector.get_uncollected_earnings()

    # Demonstrate data integrity check
    # Let's simulate a data change (e.g., external modification)
    original_data_hash = anti_spy.data_hashes.get("transactions")
    # This directly modifies the internal state for demonstration.
    # In a real scenario, this would be an unauthorized external change.
    finance_ai.accounts["Checking"].transactions[0].amount = 1000000.00 # A suspicious change!
    anti_spy.monitor_data_integrity("transactions", finance_ai.get_all_account_data())
    finance_ai.accounts["Checking"].transactions[0].amount = 75.50 # Revert for further operations

    anti_spy.detect_suspicious_activity()
    anti_spy.detect_suspicious_activity() # Try again for more chances

    # Show access logs (in a real system, these would be in a secure, immutable log)
    print("\n--- Anti-Spy Access Logs (Sample) ---")
    for log in anti_spy.access_logs[-5:]: # Show last 5 logs
        print(f"  {log['timestamp']} | User: {log['user_id']} | Action: {log['action']} | Data: {log.get('data_accessed', 'N/A')}")

    # Demonstrate encryption/decryption (placeholder)
    print("\n--- Data Encryption/Decryption Demonstration ---")
    gilbert_sensitive_info = {"password_hint": "MyFavoriteColorIsBlue", "secret_Youtube": "Dog'sName"}
    encrypted_info = anti_spy.encrypt_data(gilbert_sensitive_info)
    print(f"Encrypted placeholder: {encrypted_info[:20]}...")
    decrypted_info = anti_spy.decrypt_data(encrypted_info)
    print(f"Decrypted placeholder: {decrypted_info}")



mkdir finance-ai-assistant
cd finance-ai-assistant
npm init -y
npm install express mongoose bcryptjs jsonwebtoken crypto dotenv winston natural @tensorflow/tfjs-node # Add more as needed



// config/default.js (example for non-sensitive configs)
// For sensitive data, use environment variables (.env file and dotenv package)
module.exports = {
  port: process.env.PORT || 3000,
  mongoURI: process.env.MONGO_URI || 'mongodb://localhost:27017/gilbert_finance_ai',
  jwtSecret: process.env.JWT_SECRET || 'aVeryStrongAndSecretKeyForJWTs', // **CHANGE THIS IN PRODUCTION**
  encryptionKey: process.env.ENCRYPTION_KEY || 'aSuperSecret32ByteKeyForAES256Encryption', // **CHANGE THIS IN PRODUCTION**
  // A 32-byte key (256 bits) is required for AES-256
  // Generate a secure random key: crypto.randomBytes(32).toString('hex')
};



// utils/security.js
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const config = require('../config/default'); // Or directly use process.env

const ALGORITHM = 'aes-256-cbc'; // AES 256-bit in CBC mode
const IV_LENGTH = 16; // 16 bytes for AES

class AntiSpy {
  constructor(userId) {
    this.userId = userId;
    this.accessLogs = [];
    this.dataHashes = {}; // To store hashes of sensitive data for integrity checks
    // In a real system, these would be persisted securely
  }

  // --- Encryption/Decryption ---
  encrypt(text) {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(config.encryptionKey, 'hex'), iv);
      let encrypted = cipher.update(JSON.stringify(text), 'utf8', 'hex');
      encrypted += cipher.final('hex');
      return iv.toString('hex') + ':' + encrypted;
    } catch (error) {
      console.error("Encryption error:", error);
      throw new Error("Failed to encrypt data.");
    }
  }

  decrypt(text) {
    try {
      const textParts = text.split(':');
      const iv = Buffer.from(textParts.shift(), 'hex');
      const encryptedText = Buffer.from(textParts.join(':'), 'hex');
      const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(config.encryptionKey, 'hex'), iv);
      let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      return JSON.parse(decrypted);
    } catch (error) {
      console.error("Decryption error:", error);
      throw new Error("Failed to decrypt data.");
    }
  }

  // --- Data Integrity ---
  hashData(data) {
    return crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');
  }

  monitorDataIntegrity(dataCategory, currentData) {
    const currentHash = this.hashData(currentData);
    if (!this.dataHashes[dataCategory]) {
      this.dataHashes[dataCategory] = currentHash;
      console.log(`[AntiSpy] Initial hash set for ${dataCategory}.`);
      return true;
    } else if (this.dataHashes[dataCategory] !== currentHash) {
      console.warn(`[AntiSpy ALERT] Data integrity breach detected in ${dataCategory} for user ${this.userId}!`);
      // In a real system: trigger alerts, invalidate sessions, quarantine data
      return false;
    }
    return true;
  }

  // --- Logging & Anomaly Detection (Simplified) ---
  async logAccess(action, dataIdentifier = null, ipAddress = "UNKNOWN") {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      userId: this.userId,
      action,
      dataIdentifier,
      ipAddress
    };
    this.accessLogs.push(logEntry); // In memory for demo; persist securely in production
    // console.log(`[AntiSpy Log] ${action} by ${this.userId} at ${timestamp}`);
    // A real system would save this to a secure, immutable log database.
    // Trigger basic anomaly detection immediately
    await this.detectSuspiciousActivity(logEntry);
  }

  async detectSuspiciousActivity(latestLogEntry) {
    // This is a very basic placeholder.
    // Real anomaly detection uses ML models on aggregated logs and behavioral data.
    const suspiciousPatterns = [
      "multiple failed login attempts",
      "unusual data export volume",
      "access from new geographic location"
    ];

    if (Math.random() < 0.05) { // Simulate a 5% chance of detecting something
      const suspicion = suspiciousPatterns[Math.floor(Math.random() * suspiciousPatterns.length)];
      console.warn(`[AntiSpy ALERT] Potential suspicious activity detected: ${suspicion} for user ${this.userId}! Log:`, latestLogEntry);
      // In a real system: send email/SMS alerts, block user, trigger manual review
      return true;
    }
    return false;
  }

  // --- Password Hashing (for user authentication) ---
  static async hashPassword(password) {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
  }

  static async comparePassword(password, hashedPassword) {
    return bcrypt.compare(password, hashedPassword);
  }
}

module.exports = AntiSpy;



// models/user.js
const mongoose = require('mongoose');
const AntiSpy = require('../utils/security');

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // Hashed password
  createdAt: { type: Date, default: Date.now }
});

// Pre-save hook to hash password before saving
UserSchema.pre('save', async function (next) {
  if (this.isModified('password')) {
    this.password = await AntiSpy.hashPassword(this.password);
  }
  next();
});

module.exports = mongoose.model('User', UserSchema);

// models/account.js
const mongoose = require('mongoose');

const AccountSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  name: { type: String, required: true },
  type: { type: String, enum: ['bank', 'credit_card', 'investment', 'cash'], required: true },
  balance: { type: Number, default: 0 },
  encryptedData: { type: String }, // Store encrypted balance/other sensitive account info
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Account', AccountSchema);


// models/transaction.js
const mongoose = require('mongoose');

const TransactionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  accountId: { type: mongoose.Schema.Types.ObjectId, ref: 'Account', required: true },
  date: { type: Date, required: true },
  description: { type: String, required: true },
  amount: { type: Number, required: true }, // Store in smallest currency unit (e.g., cents) as integer to avoid float issues
  type: { type: String, enum: ['income', 'expense'], required: true },
  category: { type: String, default: 'Uncategorized' },
  encryptedDescription: { type: String }, // Optional: Encrypt sensitive parts of description
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Transaction', TransactionSchema);

// models/earning.js
const mongoose = require('mongoose');

const EarningSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  source: { type: String, required: true },
  amount: { type: Number, required: true }, // Smallest currency unit
  type: { type: String, enum: ['expected', 'collected'], required: true },
  dueDate: { type: Date }, // For expected earnings
  collectedDate: { type: Date }, // For collected earnings
  status: { type: String, enum: ['pending', 'collected', 'overdue'], default: 'pending' },
  encryptedDetails: { type: String }, // Encrypt any other sensitive earning details
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Earning', EarningSchema);



// routes/auth.js
const express = require('express');
const jwt = require('jsonwebtoken');
const User = require('../models/user');
const AntiSpy = require('../utils/security');
const config = require('../config/default');

const router = express.Router();

// Register User
router.post('/register', async (req, res) => {
  const { username, email, password } = req.body;
  try {
    let user = await User.findOne({ email });
    if (user) {
      return res.status(400).json({ msg: 'User already exists' });
    }

    user = new User({ username, email, password });
    await user.save(); // Password hashed via pre-save hook

    const antiSpy = new AntiSpy(user._id.toString());
    await antiSpy.logAccess('User Registered');

    res.status(201).json({ msg: 'User registered successfully' });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// Login User
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) {
      const antiSpy = new AntiSpy('UNKNOWN_USER'); // Log failed attempt
      await antiSpy.logAccess('Failed Login Attempt', null, req.ip);
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }

    const isMatch = await AntiSpy.comparePassword(password, user.password);
    if (!isMatch) {
      const antiSpy = new AntiSpy(user._id.toString());
      await antiSpy.logAccess('Failed Login Attempt', null, req.ip);
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }

    const payload = { user: { id: user.id } };
    jwt.sign(payload, config.jwtSecret, { expiresIn: '1h' }, async (err, token) => {
      if (err) throw err;
      const antiSpy = new AntiSpy(user.id);
      await antiSpy.logAccess('User Logged In', null, req.ip);
      res.json({ token });
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;



// middleware/auth.js
const jwt = require('jsonwebtoken');
const config = require('../config/default');
const AntiSpy = require('../utils/security'); // For logging

module.exports = async function (req, res, next) {
  // Get token from header
  const token = req.header('x-auth-token');

  // Check if no token
  if (!token) {
    const antiSpy = new AntiSpy('UNAUTHENTICATED');
    await antiSpy.logAccess('Attempted Unauthorized Access', null, req.ip);
    return res.status(401).json({ msg: 'No token, authorization denied' });
  }

  // Verify token
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded.user;
    next();
  } catch (err) {
    const antiSpy = new AntiSpy('INVALID_TOKEN');
    await antiSpy.logAccess('Invalid Token Access Attempt', null, req.ip);
    res.status(401).json({ msg: 'Token is not valid' });
  }
};



// routes/finance.js
const express = require('express');
const auth = require('../middleware/auth');
const Account = require('../models/account');
const Transaction = require('../models/transaction');
const AntiSpy = require('../utils/security');
const natural = require('natural'); // For NLP/categorization

const router = express.Router();

// Initialize the AntiSpy instance for the current user in a request context
router.use(async (req, res, next) => {
  if (req.user && req.user.id) {
    req.antiSpy = new AntiSpy(req.user.id);
  }
  next();
});

// @route   POST api/finance/account
// @desc    Add a new financial account
// @access  Private
router.post('/account', auth, async (req, res) => {
  const { name, type, initialBalance } = req.body;
  try {
    let account = new Account({
      userId: req.user.id,
      name,
      type,
      balance: initialBalance || 0
    });

    // Encrypt sensitive account data before saving
    account.encryptedData = req.antiSpy.encrypt({
      balance: account.balance // Example: encrypting balance
      // In real scenarios, more sensitive data would be encrypted
    });
    // Set balance to 0 or null after encryption, or rely solely on encryptedData
    account.balance = 0; // Or manage decrypted balance only in memory

    await account.save();
    await req.antiSpy.logAccess(`Added Account: ${name}`, account._id.toString());
    await req.antiSpy.monitorDataIntegrity('accounts', await Account.find({ userId: req.user.id }));

    res.json(account);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   POST api/finance/transaction
// @desc    Record a new transaction
// @access  Private
router.post('/transaction', auth, async (req, res) => {
  const { accountId, date, description, amount, type } = req.body;
  try {
    const account = await Account.findById(accountId);
    if (!account || account.userId.toString() !== req.user.id) {
      return res.status(404).json({ msg: 'Account not found or unauthorized' });
    }

    // Basic NLP for categorization (very simple example)
    let category = 'Uncategorized';
    if (description.toLowerCase().includes('groceries') || description.toLowerCase().includes('supermarket')) {
      category = 'Food';
    } else if (description.toLowerCase().includes('rent') || description.toLowerCase().includes('mortgage')) {
      category = 'Housing';
    } else if (description.toLowerCase().includes('salary') || description.toLowerCase().includes('freelance')) {
      category = 'Income';
    }
    // More advanced NLP would use trained models with natural or TensorFlow.js

    const transaction = new Transaction({
      userId: req.user.id,
      accountId,
      date,
      description,
      amount,
      type,
      category
    });

    // Update account balance (decrypt, update, encrypt)
    const decryptedAccountData = req.antiSpy.decrypt(account.encryptedData);
    if (transaction.type === 'expense') {
      decryptedAccountData.balance -= transaction.amount;
    } else {
      decryptedAccountData.balance += transaction.amount;
    }
    account.encryptedData = req.antiSpy.encrypt(decryptedAccountData);
    await account.save();

    await transaction.save();
    await req.antiSpy.logAccess(`Recorded Transaction: ${description}`, transaction._id.toString());
    await req.antiSpy.monitorDataIntegrity('transactions', await Transaction.find({ userId: req.user.id }));

    res.json(transaction);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/finance/net-worth
// @desc    Get user's net worth
// @access  Private
router.get('/net-worth', auth, async (req, res) => {
  try {
    const accounts = await Account.find({ userId: req.user.id });
    let totalNetWorth = 0;
    for (const account of accounts) {
      const decryptedData = req.antiSpy.decrypt(account.encryptedData);
      totalNetWorth += decryptedData.balance;
    }
    await req.antiSpy.logAccess('Checked Net Worth');
    res.json({ netWorth: totalNetWorth });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/finance/spending-by-category
// @desc    Get spending organized by category
// @access  Private
router.get('/spending-by-category', auth, async (req, res) => {
  try {
    const transactions = await Transaction.find({ userId: req.user.id, type: 'expense' });
    const spendingByCategory = transactions.reduce((acc, t) => {
      acc[t.category] = (acc[t.category] || 0) + t.amount;
      return acc;
    }, {});
    await req.antiSpy.logAccess('Generated Spending by Category Report');
    res.json(spendingByCategory);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/finance/advice
// @desc    Get basic financial advice (placeholder for AI)
// @access  Private
router.get('/advice', auth, async (req, res) => {
  try {
    const netWorthResult = await axios.get(`${req.protocol}://${req.get('host')}/api/finance/net-worth`, {
      headers: { 'x-auth-token': req.header('x-auth-token') }
    });
    const netWorth = netWorthResult.data.netWorth;

    const spendingResult = await axios.get(`${req.protocol}://${req.get('host')}/api/finance/spending-by-category`, {
      headers: { 'x-auth-token': req.header('x-auth-token') }
    });
    const spending = spendingResult.data;

    let advice = [];
    if (netWorth < 0) {
      advice.push("Your net worth is negative. Focus on debt reduction and increasing income.");
    } else if (netWorth < 5000) {
      advice.push("Consider building an emergency fund of 3-6 months of expenses.");
    } else {
      advice.push("Your finances are looking good! Consider exploring investment opportunities.");
    }

    if (spending.Food && spending.Food > 500) {
      advice.push("Your food expenses are quite high. Try meal planning to save money.");
    }
    if (spending.Entertainment && spending.Entertainment > 200) {
      advice.push("Review your entertainment spending. Small cuts can lead to big savings.");
    }

    // In a real AI, this would involve much more complex analysis and potentially
    // real-time market data, risk assessment, etc., using ML models.

    await req.antiSpy.logAccess('Provided Financial Advice');
    res.json({ advice });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;



// routes/earnings.js
const express = require('express');
const auth = require('../middleware/auth');
const Earning = require('../models/earning');
const AntiSpy = require('../utils/security');

const router = express.Router();

router.use(async (req, res, next) => {
  if (req.user && req.user.id) {
    req.antiSpy = new AntiSpy(req.user.id);
  }
  next();
});

// @route   POST api/earnings/expected
// @desc    Add an expected earning
// @access  Private
router.post('/expected', auth, async (req, res) => {
  const { source, amount, dueDate } = req.body;
  try {
    const earning = new Earning({
      userId: req.user.id,
      source,
      amount,
      dueDate,
      type: 'expected',
      status: 'pending'
    });
    earning.encryptedDetails = req.antiSpy.encrypt({
      source: earning.source,
      amount: earning.amount // Example encryption
    });
    await earning.save();
    await req.antiSpy.logAccess(`Added Expected Earning: ${source}`, earning._id.toString());
    res.json(earning);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   POST api/earnings/collected
// @desc    Record a collected earning and update status
// @access  Private
router.post('/collected', auth, async (req, res) => {
  const { earningId } = req.body;
  try {
    const earning = await Earning.findOne({ _id: earningId, userId: req.user.id, type: 'expected' });
    if (!earning) {
      return res.status(404).json({ msg: 'Expected earning not found or unauthorized' });
    }

    earning.status = 'collected';
    earning.collectedDate = new Date();
    earning.type = 'collected'; // Change type to collected for clear distinction

    await earning.save();
    await req.antiSpy.logAccess(`Recorded Collected Earning: ${earning.source}`, earning._id.toString());
    res.json(earning);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/earnings/report
// @desc    Generate an earnings report
// @access  Private
router.get('/report', auth, async (req, res) => {
  try {
    const collectedEarnings = await Earning.find({ userId: req.user.id, type: 'collected' });
    const expectedEarnings = await Earning.find({ userId: req.user.id, type: 'expected', status: 'pending' });

    let totalCollected = 0;
    collectedEarnings.forEach(e => {
      // Decrypt if necessary for display, otherwise keep encrypted for storage
      const decryptedData = req.antiSpy.decrypt(e.encryptedDetails);
      totalCollected += decryptedData.amount;
    });

    await req.antiSpy.logAccess('Generated Earnings Report');
    res.json({
      totalCollected,
      pendingExpected: expectedEarnings.map(e => ({
        id: e._id,
        source: req.antiSpy.decrypt(e.encryptedDetails).source,
        amount: req.antiSpy.decrypt(e.encryptedDetails).amount,
        dueDate: e.dueDate
      }))
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;



// server.js
const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const config = require('./config/default'); // Contains non-sensitive configs and defaults for sensitive ones
const helmet = require('helmet'); // For setting security HTTP headers
const rateLimit = require('express-rate-limit'); // For rate limiting
const cors = require('cors'); // For cross-origin requests (if frontend is separate)

dotenv.config(); // Load environment variables from .env file

const app = express();

// Connect Database
const connectDB = async () => {
  try {
    await mongoose.connect(config.mongoURI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB Connected...');
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
};
connectDB();

// Middleware
app.use(express.json({ extended: false })); // Body parser for JSON
app.use(helmet()); // Set security headers
app.use(cors()); // Enable CORS for all origins (adjust for production)

// Rate limiting to prevent brute-force attacks
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again after 15 minutes',
});
app.use('/api/', apiLimiter); // Apply to all API routes

// Define Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/finance', require('./routes/finance'));
app.use('/api/earnings', require('./routes/earnings'));

// Simple Home Route
app.get('/', (req, res) => res.send('Finance AI Assistant API Running'));

const PORT = config.port;

app.listen(PORT, () => console.log(`Server started on port ${PORT}`));



You're looking to build an "Advanced Finance AI Assistant and Earnings Collector with Anti-Spy" using Node.js for Gilbert Algordo. This is an ambitious project that touches upon highly sensitive domains: financial data, AI, and cybersecurity.
As with the Python example, a complete, production-ready system would require a dedicated team of experts. This Node.js response will provide a high-level conceptual design and illustrative code snippets to demonstrate how you might approach this, emphasizing security and AI aspects within the Node.js ecosystem.
Disclaimer: Financial AI and security are extremely sensitive. The provided code is for illustrative purposes only and should NOT be used in a real-world financial application without rigorous security audits, professional development, and compliance with all relevant financial regulations and data privacy laws. Always prioritize security and data privacy in financial applications.
Conceptual Design: Advanced Finance AI Assistant and Earnings Collector with Anti-Spy (Node.js)
Goal: To create a personalized AI assistant that helps Gilbert Algordo manage finances, optimize earnings, and protect his financial data from unauthorized access, built with Node.js.
Key Components (Node.js Implementation Focus):
 * Backend (Node.js):
   * API Layer: Express.js for building RESTful APIs to handle requests from the frontend.
   * Data Storage: MongoDB (NoSQL, flexible schema for financial data) or PostgreSQL (Relational, strong ACID properties) for storing encrypted financial records.
   * Authentication & Authorization: JWT (JSON Web Tokens) for secure user sessions, bcrypt for password hashing, and role-based access control.
   * Encryption: Node.js's built-in crypto module for AES-256 encryption/decryption of sensitive financial data.
   * Data Aggregation: External APIs (e.g., Plaid, Yodlee - with secure key management and compliance) to connect to bank accounts, or manual data entry.
   * AI/ML Integration:
     * Local Processing: Libraries like TensorFlow.js (for Node.js) for on-server model inference (e.g., transaction categorization, anomaly detection, forecasting).
     * Cloud AI Services: Integration with Google Cloud AI Platform, AWS SageMaker, Azure Machine Learning for more complex models or GPU-accelerated tasks.
   * Earnings Collector Logic: Modules to manage income streams, track invoices, and reconcile payments.
   * Anti-Spy & Security Middleware: Custom middleware to log activities, check data integrity, detect anomalies, and enforce security policies.
   * Logging & Monitoring: Winston or similar for robust logging, integrating with external monitoring tools (e.g., Elastic Stack, Prometheus).
 * AI Financial Core (Node.js/Integrated):
   * Transaction Categorization: NLP (e.g., natural library or custom models with TensorFlow.js) to classify transactions.
   * Budgeting & Forecasting: Time-series analysis (e.g., using danfo.js for data manipulation and then feeding to TensorFlow.js for LSTM or ARIMA models).
   * Investment Insights: Algorithms to analyze portfolio data, potentially integrating with financial data APIs.
   * Personalized Recommendations: Rule-based systems initially, evolving to ML-driven recommendations.
   * Natural Language Processing (NLP): For a conversational interface (if planned), using libraries like natural for text understanding and intent recognition.
 * Earnings Collector (Node.js Logic):
   * Income Stream Management: Database models for ExpectedEarning and CollectedEarning.
   * Payment Tracking: Logic to update statuses and generate reports.
   * Automated Reminders: Using cron jobs or scheduled tasks (e.g., node-cron).
 * Anti-Spy & Security Module (Node.js Logic & Libraries):
   * Data Encryption: Crucial. Use crypto module.
   * Hashing: For password storage (bcrypt) and data integrity checks (SHA256).
   * Access Control: Middleware to enforce permissions.
   * Anomaly Detection: Statistical methods or simple ML models (TensorFlow.js) on user activity logs and financial transaction patterns.
   * Secure Environment: Utilize environment variables for sensitive configurations, avoid hardcoding secrets.
   * HTTPS: Enforce HTTPS for all communication.
   * Input Validation & Sanitization: Prevent injection attacks.
   * Rate Limiting: Protect against brute-force and DoS attacks.
Illustrative Node.js Code Snippets (Highly Simplified)
These snippets illustrate core concepts. A production system would be far more complex, with robust error handling, detailed data models, and a structured project layout (e.g., using MVC or hexagonal architecture).
Project Setup (Conceptual):
mkdir finance-ai-assistant
cd finance-ai-assistant
npm init -y
npm install express mongoose bcryptjs jsonwebtoken crypto dotenv winston natural @tensorflow/tfjs-node # Add more as needed

1. config/default.js (or use .env for secrets)
// config/default.js (example for non-sensitive configs)
// For sensitive data, use environment variables (.env file and dotenv package)
module.exports = {
  port: process.env.PORT || 3000,
  mongoURI: process.env.MONGO_URI || 'mongodb://localhost:27017/gilbert_finance_ai',
  jwtSecret: process.env.JWT_SECRET || 'aVeryStrongAndSecretKeyForJWTs', // **CHANGE THIS IN PRODUCTION**
  encryptionKey: process.env.ENCRYPTION_KEY || 'aSuperSecret32ByteKeyForAES256Encryption', // **CHANGE THIS IN PRODUCTION**
  // A 32-byte key (256 bits) is required for AES-256
  // Generate a secure random key: crypto.randomBytes(32).toString('hex')
};

2. utils/security.js (Anti-Spy & Encryption Core)
// utils/security.js
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const config = require('../config/default'); // Or directly use process.env

const ALGORITHM = 'aes-256-cbc'; // AES 256-bit in CBC mode
const IV_LENGTH = 16; // 16 bytes for AES

class AntiSpy {
  constructor(userId) {
    this.userId = userId;
    this.accessLogs = [];
    this.dataHashes = {}; // To store hashes of sensitive data for integrity checks
    // In a real system, these would be persisted securely
  }

  // --- Encryption/Decryption ---
  encrypt(text) {
    try {
      const iv = crypto.randomBytes(IV_LENGTH);
      const cipher = crypto.createCipheriv(ALGORITHM, Buffer.from(config.encryptionKey, 'hex'), iv);
      let encrypted = cipher.update(JSON.stringify(text), 'utf8', 'hex');
      encrypted += cipher.final('hex');
      return iv.toString('hex') + ':' + encrypted;
    } catch (error) {
      console.error("Encryption error:", error);
      throw new Error("Failed to encrypt data.");
    }
  }

  decrypt(text) {
    try {
      const textParts = text.split(':');
      const iv = Buffer.from(textParts.shift(), 'hex');
      const encryptedText = Buffer.from(textParts.join(':'), 'hex');
      const decipher = crypto.createDecipheriv(ALGORITHM, Buffer.from(config.encryptionKey, 'hex'), iv);
      let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      return JSON.parse(decrypted);
    } catch (error) {
      console.error("Decryption error:", error);
      throw new Error("Failed to decrypt data.");
    }
  }

  // --- Data Integrity ---
  hashData(data) {
    return crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');
  }

  monitorDataIntegrity(dataCategory, currentData) {
    const currentHash = this.hashData(currentData);
    if (!this.dataHashes[dataCategory]) {
      this.dataHashes[dataCategory] = currentHash;
      console.log(`[AntiSpy] Initial hash set for ${dataCategory}.`);
      return true;
    } else if (this.dataHashes[dataCategory] !== currentHash) {
      console.warn(`[AntiSpy ALERT] Data integrity breach detected in ${dataCategory} for user ${this.userId}!`);
      // In a real system: trigger alerts, invalidate sessions, quarantine data
      return false;
    }
    return true;
  }

  // --- Logging & Anomaly Detection (Simplified) ---
  async logAccess(action, dataIdentifier = null, ipAddress = "UNKNOWN") {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      userId: this.userId,
      action,
      dataIdentifier,
      ipAddress
    };
    this.accessLogs.push(logEntry); // In memory for demo; persist securely in production
    // console.log(`[AntiSpy Log] ${action} by ${this.userId} at ${timestamp}`);
    // A real system would save this to a secure, immutable log database.
    // Trigger basic anomaly detection immediately
    await this.detectSuspiciousActivity(logEntry);
  }

  async detectSuspiciousActivity(latestLogEntry) {
    // This is a very basic placeholder.
    // Real anomaly detection uses ML models on aggregated logs and behavioral data.
    const suspiciousPatterns = [
      "multiple failed login attempts",
      "unusual data export volume",
      "access from new geographic location"
    ];

    if (Math.random() < 0.05) { // Simulate a 5% chance of detecting something
      const suspicion = suspiciousPatterns[Math.floor(Math.random() * suspiciousPatterns.length)];
      console.warn(`[AntiSpy ALERT] Potential suspicious activity detected: ${suspicion} for user ${this.userId}! Log:`, latestLogEntry);
      // In a real system: send email/SMS alerts, block user, trigger manual review
      return true;
    }
    return false;
  }

  // --- Password Hashing (for user authentication) ---
  static async hashPassword(password) {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
  }

  static async comparePassword(password, hashedPassword) {
    return bcrypt.compare(password, hashedPassword);
  }
}

module.exports = AntiSpy;

3. models/user.js, models/account.js, models/transaction.js, models/earning.js (Mongoose Models)
// models/user.js
const mongoose = require('mongoose');
const AntiSpy = require('../utils/security');

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // Hashed password
  createdAt: { type: Date, default: Date.now }
});

// Pre-save hook to hash password before saving
UserSchema.pre('save', async function (next) {
  if (this.isModified('password')) {
    this.password = await AntiSpy.hashPassword(this.password);
  }
  next();
});

module.exports = mongoose.model('User', UserSchema);

// models/account.js
const mongoose = require('mongoose');

const AccountSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  name: { type: String, required: true },
  type: { type: String, enum: ['bank', 'credit_card', 'investment', 'cash'], required: true },
  balance: { type: Number, default: 0 },
  encryptedData: { type: String }, // Store encrypted balance/other sensitive account info
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Account', AccountSchema);


// models/transaction.js
const mongoose = require('mongoose');

const TransactionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  accountId: { type: mongoose.Schema.Types.ObjectId, ref: 'Account', required: true },
  date: { type: Date, required: true },
  description: { type: String, required: true },
  amount: { type: Number, required: true }, // Store in smallest currency unit (e.g., cents) as integer to avoid float issues
  type: { type: String, enum: ['income', 'expense'], required: true },
  category: { type: String, default: 'Uncategorized' },
  encryptedDescription: { type: String }, // Optional: Encrypt sensitive parts of description
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Transaction', TransactionSchema);

// models/earning.js
const mongoose = require('mongoose');

const EarningSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  source: { type: String, required: true },
  amount: { type: Number, required: true }, // Smallest currency unit
  type: { type: String, enum: ['expected', 'collected'], required: true },
  dueDate: { type: Date }, // For expected earnings
  collectedDate: { type: Date }, // For collected earnings
  status: { type: String, enum: ['pending', 'collected', 'overdue'], default: 'pending' },
  encryptedDetails: { type: String }, // Encrypt any other sensitive earning details
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Earning', EarningSchema);

4. routes/auth.js (Authentication)
// routes/auth.js
const express = require('express');
const jwt = require('jsonwebtoken');
const User = require('../models/user');
const AntiSpy = require('../utils/security');
const config = require('../config/default');

const router = express.Router();

// Register User
router.post('/register', async (req, res) => {
  const { username, email, password } = req.body;
  try {
    let user = await User.findOne({ email });
    if (user) {
      return res.status(400).json({ msg: 'User already exists' });
    }

    user = new User({ username, email, password });
    await user.save(); // Password hashed via pre-save hook

    const antiSpy = new AntiSpy(user._id.toString());
    await antiSpy.logAccess('User Registered');

    res.status(201).json({ msg: 'User registered successfully' });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// Login User
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) {
      const antiSpy = new AntiSpy('UNKNOWN_USER'); // Log failed attempt
      await antiSpy.logAccess('Failed Login Attempt', null, req.ip);
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }

    const isMatch = await AntiSpy.comparePassword(password, user.password);
    if (!isMatch) {
      const antiSpy = new AntiSpy(user._id.toString());
      await antiSpy.logAccess('Failed Login Attempt', null, req.ip);
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }

    const payload = { user: { id: user.id } };
    jwt.sign(payload, config.jwtSecret, { expiresIn: '1h' }, async (err, token) => {
      if (err) throw err;
      const antiSpy = new AntiSpy(user.id);
      await antiSpy.logAccess('User Logged In', null, req.ip);
      res.json({ token });
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;

5. middleware/auth.js (JWT Middleware)
// middleware/auth.js
const jwt = require('jsonwebtoken');
const config = require('../config/default');
const AntiSpy = require('../utils/security'); // For logging

module.exports = async function (req, res, next) {
  // Get token from header
  const token = req.header('x-auth-token');

  // Check if no token
  if (!token) {
    const antiSpy = new AntiSpy('UNAUTHENTICATED');
    await antiSpy.logAccess('Attempted Unauthorized Access', null, req.ip);
    return res.status(401).json({ msg: 'No token, authorization denied' });
  }

  // Verify token
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded.user;
    next();
  } catch (err) {
    const antiSpy = new AntiSpy('INVALID_TOKEN');
    await antiSpy.logAccess('Invalid Token Access Attempt', null, req.ip);
    res.status(401).json({ msg: 'Token is not valid' });
  }
};

6. routes/finance.js (Finance AI Logic - Simplified)
// routes/finance.js
const express = require('express');
const auth = require('../middleware/auth');
const Account = require('../models/account');
const Transaction = require('../models/transaction');
const AntiSpy = require('../utils/security');
const natural = require('natural'); // For NLP/categorization

const router = express.Router();

// Initialize the AntiSpy instance for the current user in a request context
router.use(async (req, res, next) => {
  if (req.user && req.user.id) {
    req.antiSpy = new AntiSpy(req.user.id);
  }
  next();
});

// @route   POST api/finance/account
// @desc    Add a new financial account
// @access  Private
router.post('/account', auth, async (req, res) => {
  const { name, type, initialBalance } = req.body;
  try {
    let account = new Account({
      userId: req.user.id,
      name,
      type,
      balance: initialBalance || 0
    });

    // Encrypt sensitive account data before saving
    account.encryptedData = req.antiSpy.encrypt({
      balance: account.balance // Example: encrypting balance
      // In real scenarios, more sensitive data would be encrypted
    });
    // Set balance to 0 or null after encryption, or rely solely on encryptedData
    account.balance = 0; // Or manage decrypted balance only in memory

    await account.save();
    await req.antiSpy.logAccess(`Added Account: ${name}`, account._id.toString());
    await req.antiSpy.monitorDataIntegrity('accounts', await Account.find({ userId: req.user.id }));

    res.json(account);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   POST api/finance/transaction
// @desc    Record a new transaction
// @access  Private
router.post('/transaction', auth, async (req, res) => {
  const { accountId, date, description, amount, type } = req.body;
  try {
    const account = await Account.findById(accountId);
    if (!account || account.userId.toString() !== req.user.id) {
      return res.status(404).json({ msg: 'Account not found or unauthorized' });
    }

    // Basic NLP for categorization (very simple example)
    let category = 'Uncategorized';
    if (description.toLowerCase().includes('groceries') || description.toLowerCase().includes('supermarket')) {
      category = 'Food';
    } else if (description.toLowerCase().includes('rent') || description.toLowerCase().includes('mortgage')) {
      category = 'Housing';
    } else if (description.toLowerCase().includes('salary') || description.toLowerCase().includes('freelance')) {
      category = 'Income';
    }
    // More advanced NLP would use trained models with natural or TensorFlow.js

    const transaction = new Transaction({
      userId: req.user.id,
      accountId,
      date,
      description,
      amount,
      type,
      category
    });

    // Update account balance (decrypt, update, encrypt)
    const decryptedAccountData = req.antiSpy.decrypt(account.encryptedData);
    if (transaction.type === 'expense') {
      decryptedAccountData.balance -= transaction.amount;
    } else {
      decryptedAccountData.balance += transaction.amount;
    }
    account.encryptedData = req.antiSpy.encrypt(decryptedAccountData);
    await account.save();

    await transaction.save();
    await req.antiSpy.logAccess(`Recorded Transaction: ${description}`, transaction._id.toString());
    await req.antiSpy.monitorDataIntegrity('transactions', await Transaction.find({ userId: req.user.id }));

    res.json(transaction);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/finance/net-worth
// @desc    Get user's net worth
// @access  Private
router.get('/net-worth', auth, async (req, res) => {
  try {
    const accounts = await Account.find({ userId: req.user.id });
    let totalNetWorth = 0;
    for (const account of accounts) {
      const decryptedData = req.antiSpy.decrypt(account.encryptedData);
      totalNetWorth += decryptedData.balance;
    }
    await req.antiSpy.logAccess('Checked Net Worth');
    res.json({ netWorth: totalNetWorth });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/finance/spending-by-category
// @desc    Get spending organized by category
// @access  Private
router.get('/spending-by-category', auth, async (req, res) => {
  try {
    const transactions = await Transaction.find({ userId: req.user.id, type: 'expense' });
    const spendingByCategory = transactions.reduce((acc, t) => {
      acc[t.category] = (acc[t.category] || 0) + t.amount;
      return acc;
    }, {});
    await req.antiSpy.logAccess('Generated Spending by Category Report');
    res.json(spendingByCategory);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/finance/advice
// @desc    Get basic financial advice (placeholder for AI)
// @access  Private
router.get('/advice', auth, async (req, res) => {
  try {
    const netWorthResult = await axios.get(`${req.protocol}://${req.get('host')}/api/finance/net-worth`, {
      headers: { 'x-auth-token': req.header('x-auth-token') }
    });
    const netWorth = netWorthResult.data.netWorth;

    const spendingResult = await axios.get(`${req.protocol}://${req.get('host')}/api/finance/spending-by-category`, {
      headers: { 'x-auth-token': req.header('x-auth-token') }
    });
    const spending = spendingResult.data;

    let advice = [];
    if (netWorth < 0) {
      advice.push("Your net worth is negative. Focus on debt reduction and increasing income.");
    } else if (netWorth < 5000) {
      advice.push("Consider building an emergency fund of 3-6 months of expenses.");
    } else {
      advice.push("Your finances are looking good! Consider exploring investment opportunities.");
    }

    if (spending.Food && spending.Food > 500) {
      advice.push("Your food expenses are quite high. Try meal planning to save money.");
    }
    if (spending.Entertainment && spending.Entertainment > 200) {
      advice.push("Review your entertainment spending. Small cuts can lead to big savings.");
    }

    // In a real AI, this would involve much more complex analysis and potentially
    // real-time market data, risk assessment, etc., using ML models.

    await req.antiSpy.logAccess('Provided Financial Advice');
    res.json({ advice });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;

7. routes/earnings.js (Earnings Collector Logic)
// routes/earnings.js
const express = require('express');
const auth = require('../middleware/auth');
const Earning = require('../models/earning');
const AntiSpy = require('../utils/security');

const router = express.Router();

router.use(async (req, res, next) => {
  if (req.user && req.user.id) {
    req.antiSpy = new AntiSpy(req.user.id);
  }
  next();
});

// @route   POST api/earnings/expected
// @desc    Add an expected earning
// @access  Private
router.post('/expected', auth, async (req, res) => {
  const { source, amount, dueDate } = req.body;
  try {
    const earning = new Earning({
      userId: req.user.id,
      source,
      amount,
      dueDate,
      type: 'expected',
      status: 'pending'
    });
    earning.encryptedDetails = req.antiSpy.encrypt({
      source: earning.source,
      amount: earning.amount // Example encryption
    });
    await earning.save();
    await req.antiSpy.logAccess(`Added Expected Earning: ${source}`, earning._id.toString());
    res.json(earning);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   POST api/earnings/collected
// @desc    Record a collected earning and update status
// @access  Private
router.post('/collected', auth, async (req, res) => {
  const { earningId } = req.body;
  try {
    const earning = await Earning.findOne({ _id: earningId, userId: req.user.id, type: 'expected' });
    if (!earning) {
      return res.status(404).json({ msg: 'Expected earning not found or unauthorized' });
    }

    earning.status = 'collected';
    earning.collectedDate = new Date();
    earning.type = 'collected'; // Change type to collected for clear distinction

    await earning.save();
    await req.antiSpy.logAccess(`Recorded Collected Earning: ${earning.source}`, earning._id.toString());
    res.json(earning);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

// @route   GET api/earnings/report
// @desc    Generate an earnings report
// @access  Private
router.get('/report', auth, async (req, res) => {
  try {
    const collectedEarnings = await Earning.find({ userId: req.user.id, type: 'collected' });
    const expectedEarnings = await Earning.find({ userId: req.user.id, type: 'expected', status: 'pending' });

    let totalCollected = 0;
    collectedEarnings.forEach(e => {
      // Decrypt if necessary for display, otherwise keep encrypted for storage
      const decryptedData = req.antiSpy.decrypt(e.encryptedDetails);
      totalCollected += decryptedData.amount;
    });

    await req.antiSpy.logAccess('Generated Earnings Report');
    res.json({
      totalCollected,
      pendingExpected: expectedEarnings.map(e => ({
        id: e._id,
        source: req.antiSpy.decrypt(e.encryptedDetails).source,
        amount: req.antiSpy.decrypt(e.encryptedDetails).amount,
        dueDate: e.dueDate
      }))
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;

8. server.js (Main Application File)
// server.js
const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const config = require('./config/default'); // Contains non-sensitive configs and defaults for sensitive ones
const helmet = require('helmet'); // For setting security HTTP headers
const rateLimit = require('express-rate-limit'); // For rate limiting
const cors = require('cors'); // For cross-origin requests (if frontend is separate)

dotenv.config(); // Load environment variables from .env file

const app = express();

// Connect Database
const connectDB = async () => {
  try {
    await mongoose.connect(config.mongoURI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    console.log('MongoDB Connected...');
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
};
connectDB();

// Middleware
app.use(express.json({ extended: false })); // Body parser for JSON
app.use(helmet()); // Set security headers
app.use(cors()); // Enable CORS for all origins (adjust for production)

// Rate limiting to prevent brute-force attacks
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again after 15 minutes',
});
app.use('/api/', apiLimiter); // Apply to all API routes

// Define Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/finance', require('./routes/finance'));
app.use('/api/earnings', require('./routes/earnings'));

// Simple Home Route
app.get('/', (req, res) => res.send('Finance AI Assistant API Running'));

const PORT = config.port;

app.listen(PORT, () => console.log(`Server started on port ${PORT}`));

9. .env file (Important for Sensitive Data)
PORT=3000
MONGO_URI=mongodb://localhost:27017/gilbert_finance_ai
JWT_SECRET=YOUR_SUPER_STRONG_JWT_SECRET_HERE_REALLY_CHANGE_THIS
ENCRYPTION_KEY=YOUR_SUPER_STRONG_32_BYTE_HEX_ENCRYPTION_KEY_HERE_REALLY_CHANGE_THIS
# To generate a strong encryption key in Node.js:
# require('crypto').randomBytes(32).toString('hex')

How to Run:
 * Save the files: Create the folder structure as indicated (e.g., config, models, routes, utils).
 * Install dependencies: npm install
 * Create .env: Add your secret keys as shown above. Never commit .env to version control.
 * Run: node server.js
Key Node.js Specific Considerations and Best Practices:
 * Asynchronous Nature: Node.js thrives on non-blocking I/O. The use of async/await throughout the examples helps manage asynchronous operations cleanly.
 * Security Libraries:
   * bcryptjs: For secure password hashing (CPU-intensive, so it's resistant to brute-force attacks).
   * jsonwebtoken (JWT): For stateless authentication, allowing scalability.
   * crypto: Node.js's built-in module for cryptographic operations (hashing, encryption/decryption). Use it carefully and correctly.
   * helmet: A collection of 14 middleware functions that set various HTTP headers for security.
   * express-rate-limit: Prevents brute-force and denial-of-service attacks by limiting request rates.
 * Data Encryption:
   * Field-Level Encryption: Encrypt specific sensitive fields in your database (e.g., balance, description). Do not store raw sensitive data.
   * Key Management: This is critical. Storing encryption keys directly in .env is a starting point for a demo. In production, use dedicated key management services (KMS) like AWS KMS, Google Cloud KMS, or Azure Key Vault.
   * IV (Initialization Vector): Always use a unique, randomly generated IV for each encryption operation (as shown in the AntiSpy.encrypt method).
 * AI/ML Integration:
   * TensorFlow.js (Node.js backend): Allows running pre-trained ML models or even training simpler models directly in your Node.js application for tasks like classification or forecasting.
   * External AI Services: For more complex financial modeling (e.g., advanced predictive analytics, deep learning), consider integrating with cloud-based ML platforms which offer scalable compute and specialized algorithms.
 * Financial Precision: JavaScript's Number type uses floating-point arithmetic, which can lead to precision issues with currency. For critical financial calculations, it's highly recommended to:
   * Store all monetary amounts as integers representing the smallest currency unit (e.g., cents, pesos).
   * Use a dedicated library for high-precision arithmetic (e.g., decimal.js or big.js) if complex calculations involving decimals are needed before converting back to integers for storage.
 * Logging and Monitoring: Implement comprehensive logging for all financial activities and security events. Use a dedicated logging library like winston and consider integrating with a SIEM (Security Information and Event Management) system.
 * Error Handling: Implement robust error handling and avoid leaking sensitive information in error messages.
 * Input Validation & Sanitization: Crucial for preventing various attacks (e.g., injection attacks). Use libraries like express-validator or Joi.
 * CORS: Properly configure Cross-Origin Resource Sharing if your frontend and backend are on different domains.
 * Docker/Containerization: For deployment, containerizing your Node.js application with Docker provides consistency and isolation.
This Node.js structure provides a foundational understanding. Remember, building a truly "advanced" and "anti-spy" finance AI requires deep expertise across multiple domains and a continuous focus on security, compliance, and ethical AI development.



npm create vite@latest gilbert-finance-fe -- --template react
cd gilbert-finance-fe
npm install
npm install axios # For API calls
npm install @mui/material @emotion/react @emotion/styled @mui/icons-material # Example UI library (MUI)
npm install recharts # For charting



// src/api/api.js
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api'; // From .env.local

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor to attach JWT token to requests
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers['x-auth-token'] = token;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Interceptor to handle expired tokens or unauthorized responses
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Handle unauthorized access or token expiry
      console.error("Unauthorized: Token expired or invalid. Please log in again.");
      localStorage.removeItem('token'); // Clear invalid token
      // Redirect to login page (implement this logic in your AuthContext or router)
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;



// src/context/AuthContext.jsx
import React, { createContext, useState, useEffect, useContext } from 'react';
import api from '../api/api';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Check for token on app load
  useEffect(() => {
    const checkAuth = async () => {
      const token = localStorage.getItem('token');
      if (token) {
        // In a real app, you'd verify the token with your backend (e.g., /api/auth/me)
        // For simplicity, we'll assume a valid token means authenticated.
        // A more robust check would involve a backend call to validate the token.
        try {
          // Example: Fetch user profile to validate token
          // const res = await api.get('/auth/me'); // A protected route to get user info
          // setUser(res.data);
          setUser({ id: 'gilbert_algordo', username: 'Gilbert Algordo' }); // Placeholder user
        } catch (error) {
          console.error("Token validation failed:", error);
          localStorage.removeItem('token');
          setUser(null);
        }
      }
      setLoading(false);
    };
    checkAuth();
  }, []);

  const login = async (email, password) => {
    try {
      setLoading(true);
      const res = await api.post('/auth/login', { email, password });
      localStorage.setItem('token', res.data.token);
      setUser({ id: 'gilbert_algordo', username: 'Gilbert Algordo' }); // Assuming success
      setLoading(false);
      return true;
    } catch (error) {
      console.error("Login failed:", error.response?.data?.msg || error.message);
      setLoading(false);
      return false;
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);



// src/App.jsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider, useAuth } from './context/AuthContext';
import LoginPage from './pages/LoginPage';
import DashboardPage from './pages/DashboardPage';
import AccountsPage from './pages/AccountsPage';
import TransactionsPage from './pages/TransactionsPage';
import EarningsPage from './pages/EarningsPage';
import FinancialAdvicePage from './pages/FinancialAdvicePage';
import Layout from './components/Layout'; // A common layout component

function PrivateRoute({ children }) {
  const { user, loading } = useAuth();

  if (loading) {
    return <div>Loading authentication...</div>; // Or a spinner
  }

  return user ? children : <Navigate to="/login" replace />;
}

function App() {
  return (
    <Router>
      <AuthProvider>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/" element={<Navigate to="/dashboard" replace />} /> {/* Default redirect */}
          <Route
            path="/dashboard"
            element={
              <PrivateRoute>
                <Layout><DashboardPage /></Layout>
              </PrivateRoute>
            }
          />
          <Route
            path="/accounts"
            element={
              <PrivateRoute>
                <Layout><AccountsPage /></Layout>
              </PrivateRoute>
            }
          />
          <Route
            path="/transactions"
            element={
              <PrivateRoute>
                <Layout><TransactionsPage /></Layout></Layout>
              </PrivateRoute>
            }
          />
          <Route
            path="/earnings"
            element={
              <PrivateRoute>
                <Layout><EarningsPage /></Layout>
              </PrivateRoute>
            }
          />
          <Route
            path="/advice"
            element={
              <PrivateRoute>
                <Layout><FinancialAdvicePage /></Layout>
              </PrivateRoute>
            }
          />
          {/* Add more routes as needed */}
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;



// src/components/Layout.jsx
import React from 'react';
import { AppBar, Toolbar, Typography, Button, IconButton, Drawer, List, ListItem, ListItemText } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import AccountCircle from '@mui/icons-material/AccountCircle';
import { Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

function Layout({ children }) {
  const { user, logout } = useAuth();
  const [drawerOpen, setDrawerOpen] = React.useState(false);

  const toggleDrawer = (open) => () => {
    setDrawerOpen(open);
  };

  const navItems = [
    { text: 'Dashboard', path: '/dashboard' },
    { text: 'Accounts', path: '/accounts' },
    { text: 'Transactions', path: '/transactions' },
    { text: 'Earnings', path: '/earnings' },
    { text: 'Financial Advice', path: '/advice' },
  ];

  return (
    <div>
      <AppBar position="static">
        <Toolbar>
          <IconButton
            edge="start"
            color="inherit"
            aria-label="menu"
            onClick={toggleDrawer(true)}
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            Gilbert's Finance AI
          </Typography>
          {user && (
            <>
              <Typography variant="subtitle1" sx={{ mr: 1 }}>
                Welcome, {user.username}!
              </Typography>
              <IconButton color="inherit">
                <AccountCircle />
              </IconButton>
              <Button color="inherit" onClick={logout}>
                Logout
              </Button>
            </>
          )}
        </Toolbar>
      </AppBar>
      <Drawer
        anchor="left"
        open={drawerOpen}
        onClose={toggleDrawer(false)}
      >
        <List>
          {navItems.map((item) => (
            <ListItem button key={item.text} component={RouterLink} to={item.path} onClick={toggleDrawer(false)}>
              <ListItemText primary={item.text} />
            </ListItem>
          ))}
        </List>
      </Drawer>
      <main style={{ padding: '20px' }}>
        {children}
      </main>
    </div>
  );
}

export default Layout;



// src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { TextField, Button, Box, Typography, Card, CardContent } from '@mui/material';
import { useAuth } from '../context/AuthContext';
import { useNavigate } from 'react-router-dom';

function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    const success = await login(email, password);
    if (success) {
      navigate('/dashboard');
    } else {
      setError('Invalid credentials. Please try again.');
    }
  };

  return (
    <Box
      sx={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '100vh',
        backgroundColor: '#f0f2f5',
      }}
    >
      <Card sx={{ minWidth: 300, padding: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" gutterBottom align="center">
            Login to Finance AI
          </Typography>
          <form onSubmit={handleSubmit}>
            <TextField
              label="Email"
              variant="outlined"
              fullWidth
              margin="normal"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
            <TextField
              label="Password"
              type="password"
              variant="outlined"
              fullWidth
              margin="normal"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            {error && <Typography color="error" variant="body2">{error}</Typography>}
            <Button
              type="submit"
              variant="contained"
              color="primary"
              fullWidth
              sx={{ mt: 2 }}
            >
              Login
            </Button>
          </form>
        </CardContent>
      </Card>
    </Box>
  );
}

export default LoginPage;



// src/pages/DashboardPage.jsx
import React, { useState, useEffect } from 'react';
import { Box, Typography, Grid, Paper } from '@mui/material';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import api from '../api/api';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#AF19FF', '#FF0077'];

function DashboardPage() {
  const [netWorth, setNetWorth] = useState(null);
  const [spendingByCategory, setSpendingByCategory] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const [netWorthRes, spendingRes] = await Promise.all([
          api.get('/finance/net-worth'),
          api.get('/finance/spending-by-category'),
        ]);
        setNetWorth(netWorthRes.data.netWorth);
        setSpendingByCategory(spendingRes.data);
      } catch (err) {
        console.error("Failed to fetch dashboard data:", err);
        setError("Failed to load dashboard data.");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const spendingDataForChart = Object.entries(spendingByCategory).map(([category, amount]) => ({
    name: category,
    value: amount,
  }));

  if (loading) return <Typography>Loading dashboard...</Typography>;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Financial Dashboard
      </Typography>

      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Paper elevation={3} sx={{ padding: 2 }}>
            <Typography variant="h6" gutterBottom>
              Current Net Worth
            </Typography>
            <Typography variant="h3" color="primary">
              ${netWorth ? netWorth.toLocaleString() : 'N/A'}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} md={6}>
          <Paper elevation={3} sx={{ padding: 2 }}>
            <Typography variant="h6" gutterBottom>
              Spending by Category
            </Typography>
            {spendingDataForChart.length > 0 ? (
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={spendingDataForChart}
                    cx="50%"
                    cy="50%"
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                    labelLine={false}
                    label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                  >
                    {spendingDataForChart.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip formatter={(value, name) => [`$${value.toLocaleString()}`, name]} />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            ) : (
              <Typography>No spending data available.</Typography>
            )}
          </Paper>
        </Grid>
        {/* Add more charts/widgets like income vs. expenses, savings progress, etc. */}
      </Grid>
    </Box>
  );
}

export default DashboardPage;



// src/pages/EarningsPage.jsx
import React, { useState, useEffect } from 'react';
import { Box, Typography, Button, TextField, List, ListItem, ListItemText, Paper, Grid } from '@mui/material';
import api from '../api/api';

function EarningsPage() {
  const [expectedEarnings, setExpectedEarnings] = useState([]);
  const [collectedEarnings, setCollectedEarnings] = useState([]);
  const [newEarningSource, setNewEarningSource] = useState('');
  const [newEarningAmount, setNewEarningAmount] = useState('');
  const [newEarningDueDate, setNewEarningDueDate] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchEarnings = async () => {
    try {
      setLoading(true);
      const res = await api.get('/earnings/report');
      setCollectedEarnings(res.data.totalCollected);
      setExpectedEarnings(res.data.pendingExpected);
    } catch (err) {
      console.error("Failed to fetch earnings:", err);
      setError("Failed to load earnings data.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEarnings();
  }, []);

  const handleAddExpectedEarning = async () => {
    try {
      await api.post('/earnings/expected', {
        source: newEarningSource,
        amount: parseFloat(newEarningAmount),
        dueDate: newEarningDueDate,
      });
      setNewEarningSource('');
      setNewEarningAmount('');
      setNewEarningDueDate('');
      fetchEarnings(); // Refresh data
    } catch (err) {
      console.error("Failed to add expected earning:", err);
      setError("Failed to add new earning.");
    }
  };

  const handleCollectEarning = async (earningId) => {
    try {
      await api.post('/earnings/collected', { earningId });
      fetchEarnings(); // Refresh data
    } catch (err) {
      console.error("Failed to collect earning:", err);
      setError("Failed to mark earning as collected.");
    }
  };

  if (loading) return <Typography>Loading earnings...</Typography>;
  if (error) return <Typography color="error">{error}</Typography>;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Earnings Collector
      </Typography>

      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Paper elevation={3} sx={{ padding: 2 }}>
            <Typography variant="h6" gutterBottom>
              Add Expected Earning
            </Typography>
            <TextField
              label="Source"
              fullWidth
              margin="normal"
              value={newEarningSource}
              onChange={(e) => setNewEarningSource(e.target.value)}
            />
            <TextField
              label="Amount"
              type="number"
              fullWidth
              margin="normal"
              value={newEarningAmount}
              onChange={(e) => setNewEarningAmount(e.target.value)}
            />
            <TextField
              label="Due Date"
              type="date"
              fullWidth
              margin="normal"
              InputLabelProps={{ shrink: true }}
              value={newEarningDueDate}
              onChange={(e) => setNewEarningDueDate(e.target.value)}
            />
            <Button variant="contained" color="primary" onClick={handleAddExpectedEarning} sx={{ mt: 2 }}>
              Add Expected Earning
            </Button>
          </Paper>
        </Grid>

        <Grid item xs={12} md={6}>
          <Paper elevation={3} sx={{ padding: 2 }}>
            <Typography variant="h6" gutterBottom>
              Pending Expected Earnings
            </Typography>
            <List>
              {expectedEarnings.length === 0 ? (
                <ListItem><ListItemText primary="No pending expected earnings." /></ListItem>
              ) : (
                expectedEarnings.map((earning) => (
                  <ListItem key={earning.id} divider>
                    <ListItemText
                      primary={`${earning.source}: $${earning.amount.toLocaleString()}`}
                      secondary={`Due: ${new Date(earning.dueDate).toLocaleDateString()}`}
                    />
                    <Button
                      variant="outlined"
                      size="small"
                      onClick={() => handleCollectEarning(earning.id)}
                    >
                      Mark Collected
                    </Button>
                  </ListItem>
                ))
              )}
            </List>
          </Paper>
        </Grid>

        <Grid item xs={12}>
          <Paper elevation={3} sx={{ padding: 2 }}>
            <Typography variant="h6" gutterBottom>
              Total Collected Earnings
            </Typography>
            <Typography variant="h5" color="secondary">
              ${collectedEarnings ? collectedEarnings.toLocaleString() : '0.00'}
            </Typography>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
}

export default EarningsPage;



// src/pages/FinancialAdvicePage.jsx
import React, { useState, useEffect } from 'react';
import { Box, Typography, Button, CircularProgress } from '@mui/material';
import api from '../api/api';

function FinancialAdvicePage() {
  const [advice, setAdvice] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchAdvice = async () => {
    try {
      setLoading(true);
      setError(null);
      const res = await api.get('/finance/advice');
      setAdvice(res.data.advice);
    } catch (err) {
      console.error("Failed to fetch financial advice:", err);
      setError("Failed to get financial advice. Please try again later.");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAdvice(); // Fetch advice on component mount
  }, []);

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Financial AI Assistant
      </Typography>
      <Typography variant="h6" gutterBottom>
        Insights for Gilbert Algordo:
      </Typography>

      {loading && (
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
          <CircularProgress />
          <Typography sx={{ ml: 2 }}>Generating advice...</Typography>
        </Box>
      )}

      {error && (
        <Typography color="error" sx={{ mt: 2 }}>
          {error}
        </Typography>
      )}

      {!loading && advice.length > 0 && (
        <Box sx={{ mt: 2, p: 3, border: '1px solid #ddd', borderRadius: '8px', backgroundColor: '#fff' }}>
          {advice.map((item, index) => (
            <Typography key={index} paragraph>
              • {item}
            </Typography>
          ))}
        </Box>
      )}

      {!loading && advice.length === 0 && !error && (
        <Typography sx={{ mt: 2 }}>
          Click "Get New Advice" to receive personalized financial insights.
        </Typography>
      )}

      <Button variant="contained" color="primary" onClick={fetchAdvice} disabled={loading} sx={{ mt: 3 }}>
        {loading ? 'Generating...' : 'Get New Advice'}
      </Button>
    </Box>
  );
}

export default FinancialAdvicePage;



// GilbertFinanceAIApp.swift
import SwiftUI

@main
struct GilbertFinanceAIApp: App {
    @StateObject var authManager = AuthManager() // Global authentication state

    var body: some Scene {
        WindowGroup {
            if authManager.isLoading {
                // Show a splash screen or loading indicator while checking auth status
                ProgressView("Checking authentication...")
            } else if authManager.isAuthenticated {
                MainTabView() // Main app content
                    .environmentObject(authManager) // Pass authManager to environment
            } else {
                LoginView() // Show login if not authenticated
                    .environmentObject(authManager)
            }
        }
    }
}



// Managers/AuthManager.swift
import Foundation
import LocalAuthentication
import Security // For Keychain Services

class AuthManager: ObservableObject {
    @Published var isAuthenticated: Bool = false
    @Published var isLoading: Bool = true
    @Published var userProfile: UserProfile? // Store basic user info (e.g., username)
    @Published var authError: String?

    private let keychainService = "com.gilbert.finance.authToken" // Unique service identifier for Keychain
    private let tokenKey = "jwtToken"

    init() {
        checkAuthStatus()
    }

    // MARK: - Authentication Logic

    func login(email: String, password: String) async -> Bool {
        // In a real app, this would call your Node.js backend
        // For illustration, simulate API call
        self.isLoading = true
        self.authError = nil

        do {
            // Simulate network delay
            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second

            // Assuming successful login for demo
            if email == "gilbert@example.com" && password == "password123" {
                let simulatedToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoiNjU4ODMyYTY5OWYwYjFjYzIwZGEwNjQxIn0sImlhdCI6MTcwMzMyNzA5NiwiZXhwIjoxNzAzMzMwNjk2fQ.someSimulatedJWTToken"
                await storeTokenInKeychain(token: simulatedToken)
                DispatchQueue.main.async {
                    self.isAuthenticated = true
                    self.userProfile = UserProfile(id: "658832a699f0b1cc20da0641", username: "Gilbert Algordo")
                    self.isLoading = false
                    // Log the login attempt with AntiSpy logic (to backend)
                    Task { await AntiSpyService.shared.logAccess(userId: self.userProfile!.id, action: "User Logged In", dataIdentifier: nil) }
                }
                return true
            } else {
                DispatchQueue.main.async {
                    self.authError = "Invalid email or password."
                    self.isAuthenticated = false
                    self.isLoading = false
                    // Log failed login attempt
                    Task { await AntiSpyService.shared.logAccess(userId: "unknown", action: "Failed Login Attempt", dataIdentifier: nil) }
                }
                return false
            }
        } catch {
            DispatchQueue.main.async {
                self.authError = "Login failed: \(error.localizedDescription)"
                self.isAuthenticated = false
                self.isLoading = false
            }
            return false
        }
    }

    func logout() {
        DispatchQueue.main.async {
            self.isAuthenticated = false
            self.userProfile = nil
            self.deleteTokenFromKeychain()
            // Log logout attempt
            Task { await AntiSpyService.shared.logAccess(userId: self.userProfile?.id ?? "unknown", action: "User Logged Out", dataIdentifier: nil) }
        }
    }

    private func checkAuthStatus() {
        Task {
            if let token = await retrieveTokenFromKeychain() {
                // In a real app, you'd send this token to your backend for validation
                // and fetch user profile based on it.
                // If validation succeeds:
                DispatchQueue.main.async {
                    self.isAuthenticated = true
                    // Decode token or fetch user profile to get username
                    self.userProfile = UserProfile(id: "658832a699f0b1cc20da0641", username: "Gilbert Algordo")
                    self.isLoading = false
                }
            } else {
                DispatchQueue.main.async {
                    self.isAuthenticated = false
                    self.isLoading = false
                }
            }
        }
    }

    // MARK: - Keychain Operations

    private func storeTokenInKeychain(token: String) async {
        let data = Data(token.utf8)
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly // Strong protection
        ]

        SecItemDelete(query as CFDictionary) // Delete old token if exists
        let status = SecItemAdd(query as CFDictionary, nil)
        if status == errSecSuccess {
            print("Token stored successfully in Keychain.")
        } else {
            print("Failed to store token in Keychain: \(status)")
        }
    }

    private func retrieveTokenFromKeychain() async -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var item: CFTypeRef?
        let status = SecItemCopyMatching(query as CFDictionary, &item)

        if status == errSecSuccess {
            if let data = item as? Data {
                print("Token retrieved from Keychain.")
                return String(data: data, encoding: .utf8)
            }
        } else if status == errSecItemNotFound {
            print("Token not found in Keychain.")
        } else {
            print("Failed to retrieve token from Keychain: \(status)")
        }
        return nil
    }

    private func deleteTokenFromKeychain() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: keychainService,
            kSecAttrAccount as String: tokenKey
        ]
        let status = SecItemDelete(query as CFDictionary)
        if status == errSecSuccess {
            print("Token deleted from Keychain.")
        } else {
            print("Failed to delete token from Keychain: \(status)")
        }
    }

    // MARK: - Biometric Authentication (Face ID/Touch ID)

    func authenticateWithBiometrics(reason: String, completion: @escaping (Bool, Error?) -> Void) {
        let context = LAContext()
        var error: NSError?

        // Check if biometric authentication is available and configured
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, authenticationError in
                DispatchQueue.main.async {
                    if success {
                        print("Biometric authentication successful.")
                        completion(true, nil)
                    } else {
                        print("Biometric authentication failed: \(authenticationError?.localizedDescription ?? "Unknown error")")
                        completion(false, authenticationError)
                    }
                }
            }
        } else {
            // Biometric authentication not available or not enrolled
            print("Biometric authentication not available: \(error?.localizedDescription ?? "Device not configured for biometrics")")
            DispatchQueue.main.async {
                completion(false, error)
            }
        }
    }
}

// UserProfile struct (for example)
struct UserProfile {
    let id: String
    let username: String
    // Add other relevant user data
}



// Services/AntiSpyService.swift
import Foundation
import CryptoKit // For hashing and encryption
import SystemConfiguration.SCNetworkReachability // For basic network checks
// import CoreML // If doing on-device ML for anomaly detection

class AntiSpyService {
    static let shared = AntiSpyService() // Singleton

    private init() {}

    // MARK: - Local Anti-Spy Checks

    // Basic Jailbreak Detection (very simple, easily bypassed, but a starting point)
    func isDeviceJailbroken() -> Bool {
        #if targetEnvironment(simulator)
        // Simulator cannot be jailbroken, return false for dev
        return false
        #else
        // Check for common jailbreak files/paths
        let fileManager = FileManager.default
        if fileManager.fileExists(atPath: "/Applications/Cydia.app") ||
           fileManager.fileExists(atPath: "/Library/MobileSubstrate/MobileSubstrate.dylib") ||
           fileManager.fileExists(atPath: "/bin/bash") ||
           fileManager.fileExists(atPath: "/usr/sbin/sshd") ||
           fileManager.fileExists(atPath: "/etc/apt") ||
           fileManager.fileExists(atPath: "/private/var/lib/apt/") ||
           fileManager.fileExists(atPath: "/private/var/mobile/Library/Caches/com.apple.mobile.installd.plist") ||
           fileManager.fileExists(atPath: "/var/lib/cydia") {
            return true
        }
        // Check if app can write outside sandbox (usually indicates jailbreak)
        let testPath = "/private/" + UUID().uuidString
        do {
            try "test".write(toFile: testPath, atomically: true, encoding: .utf8)
            try fileManager.removeItem(atPath: testPath)
            return true
        } catch {
            // Cannot write outside sandbox, likely not jailbroken
        }
        // Check for presence of symbolic links commonly created by jailbreaks
        if (try? FileManager.default.destinationOfSymbolicLink(atPath: "/var/lib/apt")) != nil {
            return true
        }
        return false
        #endif
    }

    // MARK: - Backend Interaction for Logging & Anomaly Detection

    func logAccess(userId: String, action: String, dataIdentifier: String? = nil, ipAddress: String? = nil) async {
        // This function sends logs to your Node.js backend's AntiSpy endpoint
        let logData: [String: Any] = [
            "userId": userId,
            "action": action,
            "timestamp": ISO8601DateFormatter().string(from: Date()),
            "dataIdentifier": dataIdentifier ?? NSNull(),
            "ipAddress": ipAddress ?? NSNull() // Backend should ideally get client IP
        ]

        guard let url = URL(string: "http://localhost:3000/api/anti-spy/log") else { // Adjust URL
            print("Invalid AntiSpy log URL.")
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        do {
            request.httpBody = try JSONSerialization.data(withJSONObject: logData, options: [])
            let (data, response) = try await URLSession.shared.data(for: request)

            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                print("AntiSpy log sent successfully.")
            } else if let httpResponse = response as? HTTPURLResponse {
                print("Failed to send AntiSpy log: HTTP Status \(httpResponse.statusCode)")
                if let responseBody = String(data: data, encoding: .utf8) {
                    print("Response body: \(responseBody)")
                }
            }
        } catch {
            print("Error sending AntiSpy log: \(error.localizedDescription)")
        }
    }

    // MARK: - Data Integrity (Hashing)

    func hashData(_ data: Data) -> String {
        let digest = SHA256.hash(data: data)
        return digest.compactMap { String(format: "%02x", $0) }.joined()
    }

    // This would typically be handled on the backend by comparing hashes
    // but a client-side check can add an extra layer
    func checkLocalDataIntegrity<T: Codable>(data: T, expectedHash: String) -> Bool {
        do {
            let encodedData = try JSONEncoder().encode(data)
            let currentHash = hashData(encodedData)
            return currentHash == expectedHash
        } catch {
            print("Error encoding data for hash check: \(error)")
            return false
        }
    }

    // MARK: - On-Device Encryption (for specific highly sensitive local data)
    // For local data that needs to be encrypted before Core Data storage

    func encryptData(data: Data, using key: SymmetricKey) throws -> Data {
        let sealedBox = try AES.GCM.seal(data, using: key)
        guard let combined = sealedBox.combined else {
            throw EncryptionError.combineFailed
        }
        return combined
    }

    func decryptData(combinedData: Data, using key: SymmetricKey) throws -> Data {
        let sealedBox = try AES.GCM.SealedBox(combined: combinedData)
        let decryptedData = try AES.GCM.open(sealedBox, using: key)
        return decryptedData
    }

    enum EncryptionError: Error {
        case combineFailed
        case decryptionFailed
    }
}



// Services/FinancialDataService.swift
import Foundation

enum APIError: Error, LocalizedError {
    case invalidURL
    case requestFailed(Error)
    case invalidResponse
    case decodingFailed(Error)
    case serverError(String)

    var errorDescription: String? {
        switch self {
        case .invalidURL: return "The API URL is invalid."
        case .requestFailed(let error): return "Network request failed: \(error.localizedDescription)"
        case .invalidResponse: return "Received an invalid response from the server."
        case .decodingFailed(let error): return "Failed to decode server response: \(error.localizedDescription)"
        case .serverError(let message): return "Server Error: \(message)"
        }
    }
}

class FinancialDataService {
    static let shared = FinancialDataService() // Singleton
    private let baseURL = "http://localhost:3000/api" // REPLACE with your actual Node.js backend URL

    private init() {}

    private func performRequest<T: Decodable, U: Encodable>(path: String, method: String, body: U? = nil, requiresAuth: Bool = true) async throws -> T {
        guard let url = URL(string: "\(baseURL)\(path)") else {
            throw APIError.invalidURL
        }

        var request = URLRequest(url: url)
        request.httpMethod = method
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        if requiresAuth {
            // Retrieve token from Keychain and add to header
            if let token = await AuthManager().retrieveTokenFromKeychain() {
                request.setValue(token, forHTTPHeaderField: "x-auth-token")
            } else {
                throw APIError.serverError("Authentication token missing.") // Or a specific auth error
            }
        }

        if let body = body {
            request.httpBody = try JSONEncoder().encode(body)
        }

        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.invalidResponse
            }

            if !(200..<300).contains(httpResponse.statusCode) {
                let errorBody = String(data: data, encoding: .utf8) ?? "No error message"
                throw APIError.serverError("HTTP \(httpResponse.statusCode): \(errorBody)")
            }

            let decodedResponse = try JSONDecoder().decode(T.self, from: data)
            return decodedResponse
        } catch let decodingError as DecodingError {
            throw APIError.decodingFailed(decodingError)
        } catch {
            throw APIError.requestFailed(error)
        }
    }

    // MARK: - Financial Data Endpoints

    func getNetWorth() async throws -> NetWorthResponse {
        try await performRequest(path: "/finance/net-worth", method: "GET")
    }

    func getSpendingByCategory() async throws -> [String: Double] {
        try await performRequest(path: "/finance/spending-by-category", method: "GET")
    }

    func getFinancialAdvice() async throws -> FinancialAdviceResponse {
        try await performRequest(path: "/finance/advice", method: "GET")
    }

    func addAccount(account: AccountRequest) async throws -> AccountResponse {
        try await performRequest(path: "/finance/account", method: "POST", body: account)
    }

    func recordTransaction(transaction: TransactionRequest) async throws -> TransactionResponse {
        try await performRequest(path: "/finance/transaction", method: "POST", body: transaction)
    }

    // MARK: - Earnings Collector Endpoints

    func addExpectedEarning(earning: EarningRequest) async throws -> EarningResponse {
        try await performRequest(path: "/earnings/expected", method: "POST", body: earning)
    }

    func recordCollectedEarning(earningId: String) async throws -> EarningResponse {
        struct EarningIdRequest: Encodable { let earningId: String }
        return try await performRequest(path: "/earnings/collected", method: "POST", body: EarningIdRequest(earningId: earningId))
    }

    func getEarningsReport() async throws -> EarningsReportResponse {
        try await performRequest(path: "/earnings/report", method: "GET")
    }
}

// MARK: - Data Models (Codable)

struct NetWorthResponse: Codable {
    let netWorth: Double
}

struct FinancialAdviceResponse: Codable {
    let advice: [String]
}

struct AccountRequest: Codable {
    let name: String
    let type: String
    let initialBalance: Double
}

struct AccountResponse: Codable, Identifiable {
    let id: String // MongoDB _id
    let userId: String
    let name: String
    let type: String
    let balance: Double // Decrypted on backend, or if securely handled
    let createdAt: String
    // No encryptedData field here; handle encryption/decryption on backend
}

struct TransactionRequest: Codable {
    let accountId: String
    let date: String // ISO 8601 string
    let description: String
    let amount: Double
    let type: String
    let category: String?
}

struct TransactionResponse: Codable, Identifiable {
    let id: String
    let userId: String
    let accountId: String
    let date: String
    let description: String
    let amount: Double
    let type: String
    let category: String
    let createdAt: String
}

struct EarningRequest: Codable {
    let source: String
    let amount: Double
    let dueDate: String // ISO 8601 string
}

struct EarningResponse: Codable, Identifiable {
    let id: String
    let userId: String
    let source: String
    let amount: Double
    let type: String
    let dueDate: String?
    let collectedDate: String?
    let status: String
    let createdAt: String
}

struct EarningsReportResponse: Codable {
    let totalCollected: Double
    let pendingExpected: [EarningResponse] // Use EarningResponse for pending expected
}



// Views/LoginView.swift
import SwiftUI

struct LoginView: View {
    @EnvironmentObject var authManager: AuthManager
    @State private var email = "gilbert@example.com"
    @State private var password = "password123"

    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "dollarsign.circle.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 100, height: 100)
                .foregroundColor(.green)
            Text("Gilbert's Finance AI")
                .font(.largeTitle)
                .fontWeight(.bold)

            TextField("Email", text: $email)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .keyboardType(.emailAddress)
                .autocapitalization(.none)
            SecureField("Password", text: $password)
                .textFieldStyle(RoundedBorderTextFieldStyle())

            if authManager.isLoading {
                ProgressView()
            } else {
                Button("Login") {
                    Task {
                        await authManager.login(email: email, password: password)
                    }
                }
                .font(.headline)
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
                .disabled(authManager.isLoading)
            }

            if let error = authManager.authError {
                Text(error)
                    .foregroundColor(.red)
            }

            Spacer()
        }
        .padding()
    }
}



// Views/MainTabView.swift
import SwiftUI

struct MainTabView: View {
    var body: some View {
        TabView {
            DashboardView()
                .tabItem {
                    Label("Dashboard", systemImage: "chart.bar.fill")
                }
            AccountsView()
                .tabItem {
                    Label("Accounts", systemImage: "creditcard.fill")
                }
            TransactionsView()
                .tabItem {
                    Label("Transactions", systemImage: "list.bullet.rectangle.fill")
                }
            EarningsView()
                .tabItem {
                    Label("Earnings", systemImage: "dollarsign.square.fill")
                }
            FinancialAdviceView()
                .tabItem {
                    Label("Advice", systemImage: "lightbulb.fill")
                }
            SettingsView() // Include Anti-Spy info here
                .tabItem {
                    Label("Settings", systemImage: "gearshape.fill")
                }
        }
    }
}



// Views/DashboardView.swift
import SwiftUI
import Charts // Requires iOS 16+

struct DashboardView: View {
    @State private var netWorth: Double?
    @State private var spendingByCategory: [String: Double] = [:]
    @State private var isLoading = false
    @State private var errorMessage: String?

    var spendingChartData: [CategorySpending] {
        spendingByCategory.map { CategorySpending(category: $0.key, amount: $0.value) }
            .sorted { $0.amount > $1.amount } // Sort by amount for better visualization
    }

    struct CategorySpending: Identifiable {
        let id = UUID()
        let category: String
        let amount: Double
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    Text("Financial Dashboard")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .padding(.bottom, 10)

                    if let errorMessage = errorMessage {
                        Text(errorMessage)
                            .foregroundColor(.red)
                            .padding()
                    }

                    if isLoading {
                        ProgressView("Loading financial data...")
                    } else {
                        // Net Worth Card
                        CardView {
                            VStack(alignment: .leading) {
                                Text("Current Net Worth")
                                    .font(.headline)
                                Text(netWorth != nil ? "$\(netWorth!, specifier: "%.2f")" : "N/A")
                                    .font(.largeTitle)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.green)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)
                        }

                        // Spending by Category Chart
                        CardView {
                            VStack(alignment: .leading) {
                                Text("Spending by Category")
                                    .font(.headline)
                                if spendingChartData.isEmpty {
                                    Text("No spending data available.")
                                        .foregroundColor(.secondary)
                                        .padding()
                                } else {
                                    Chart(spendingChartData) { data in
                                        SectorMark(
                                            angle: .value("Amount", data.amount),
                                            innerRadius: 60,
                                            outerRadius: 100,
                                            angularInset: 1.0
                                        )
                                        .cornerRadius(5)
                                        .foregroundStyle(by: .value("Category", data.category))
                                        .annotation(position: .overlay) {
                                            Text(data.amount.formatted(.currency(code: "USD")))
                                                .font(.caption)
                                                .foregroundStyle(.white)
                                        }
                                    }
                                    .frame(height: 250)
                                    .chartBackground { chartProxy in
                                        GeometryReader { geometry in
                                            let frame = geometry[chartProxy.plotFrame!]
                                            VStack {
                                                Text("Total Spending")
                                                    .font(.caption)
                                                    .foregroundStyle(.secondary)
                                                Text(spendingChartData.reduce(0) { $0 + $1.amount }.formatted(.currency(code: "USD")))
                                                    .font(.title2.bold())
                                            }
                                            .position(x: frame.midX, y: frame.midY)
                                        }
                                    }
                                }
                            }
                        }

                        // Add more sections as needed: Recent Transactions, Savings Goals etc.
                    }
                }
                .padding()
            }
            .navigationTitle("Dashboard")
            .navigationBarHidden(true) // Hide default nav bar if using custom layout
        }
        .onAppear(perform: loadDashboardData)
    }

    private func loadDashboardData() {
        Task {
            isLoading = true
            errorMessage = nil
            do {
                let netWorthResponse = try await FinancialDataService.shared.getNetWorth()
                DispatchQueue.main.async {
                    self.netWorth = netWorthResponse.netWorth
                }

                let spendingResponse = try await FinancialDataService.shared.getSpendingByCategory()
                DispatchQueue.main.async {
                    self.spendingByCategory = spendingResponse
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = error.localizedDescription
                }
            }
            isLoading = false
            // Log access
            Task { await AntiSpyService.shared.logAccess(userId: AuthManager().userProfile?.id ?? "unknown", action: "Viewed Dashboard") }
        }
    }
}

// Reusable Card View for better UI consistency
struct CardView<Content: View>: View {
    let content: Content

    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    var body: some View {
        VStack {
            content
        }
        .padding()
        .background(Color.white)
        .cornerRadius(15)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 5)
    }
}



// Views/EarningsView.swift
import SwiftUI

struct EarningsView: View {
    @State private var totalCollected: Double = 0.0
    @State private var pendingExpected: [EarningResponse] = []
    @State private var newEarningSource: String = ""
    @State private var newEarningAmount: String = ""
    @State private var newEarningDueDate: Date = Date()
    @State private var isLoading = false
    @State private var errorMessage: String?

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    Text("Earnings Collector")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .padding(.bottom, 10)

                    if let errorMessage = errorMessage {
                        Text(errorMessage)
                            .foregroundColor(.red)
                            .padding()
                    }

                    if isLoading {
                        ProgressView("Loading earnings...")
                    } else {
                        // Total Collected Earnings Card
                        CardView {
                            VStack(alignment: .leading) {
                                Text("Total Collected Earnings")
                                    .font(.headline)
                                Text("$\(totalCollected, specifier: "%.2f")")
                                    .font(.title2)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.blue)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)
                        }

                        // Add Expected Earning Form
                        CardView {
                            VStack(alignment: .leading, spacing: 10) {
                                Text("Add Expected Earning")
                                    .font(.headline)
                                TextField("Source (e.g., Client Project)", text: $newEarningSource)
                                    .textFieldStyle(RoundedBorderTextFieldStyle())
                                TextField("Amount", text: $newEarningAmount)
                                    .keyboardType(.decimalPad)
                                    .textFieldStyle(RoundedBorderTextFieldStyle())
                                DatePicker("Due Date", selection: $newEarningDueDate, displayedComponents: .date)
                                    .datePickerStyle(.compact)

                                Button("Add Earning") {
                                    addExpectedEarning()
                                }
                                .font(.headline)
                                .padding()
                                .frame(maxWidth: .infinity)
                                .background(Color.green)
                                .foregroundColor(.white)
                                .cornerRadius(10)
                            }
                        }

                        // Pending Expected Earnings List
                        CardView {
                            VStack(alignment: .leading) {
                                Text("Pending Expected Earnings")
                                    .font(.headline)
                                if pendingExpected.isEmpty {
                                    Text("No pending earnings.")
                                        .foregroundColor(.secondary)
                                        .padding()
                                } else {
                                    ForEach(pendingExpected) { earning in
                                        HStack {
                                            VStack(alignment: .leading) {
                                                Text(earning.source)
                                                    .font(.subheadline)
                                                Text("$\(earning.amount, specifier: "%.2f") - Due: \(DateFormatter.shortDate.string(from: ISO8601DateFormatter().date(from: earning.dueDate ?? "") ?? Date()))")
                                                    .font(.caption)
                                                    .foregroundColor(.secondary)
                                            }
                                            Spacer()
                                            Button("Mark Collected") {
                                                markEarningCollected(earningId: earning.id)
                                            }
                                            .buttonStyle(.bordered)
                                        }
                                        .padding(.vertical, 5)
                                        Divider()
                                    }
                                }
                            }
                        }
                    }
                }
                .padding()
            }
            .navigationTitle("Earnings")
            .navigationBarHidden(true)
        }
        .onAppear(perform: loadEarningsData)
    }

    private func loadEarningsData() {
        Task {
            isLoading = true
            errorMessage = nil
            do {
                let report = try await FinancialDataService.shared.getEarningsReport()
                DispatchQueue.main.async {
                    self.totalCollected = report.totalCollected
                    self.pendingExpected = report.pendingExpected
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = error.localizedDescription
                }
            }
            isLoading = false
            Task { await AntiSpyService.shared.logAccess(userId: AuthManager().userProfile?.id ?? "unknown", action: "Viewed Earnings") }
        }
    }

    private func addExpectedEarning() {
        guard let amount = Double(newEarningAmount), !newEarningSource.isEmpty else {
            errorMessage = "Please enter valid source and amount."
            return
        }
        let formattedDate = ISO8601DateFormatter().string(from: newEarningDueDate)
        let request = EarningRequest(source: newEarningSource, amount: amount, dueDate: formattedDate)

        Task {
            isLoading = true
            errorMessage = nil
            do {
                _ = try await FinancialDataService.shared.addExpectedEarning(earning: request)
                DispatchQueue.main.async {
                    self.newEarningSource = ""
                    self.newEarningAmount = ""
                    self.newEarningDueDate = Date()
                }
                await loadEarningsData() // Reload data after adding
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = error.localizedDescription
                }
            }
            isLoading = false
            Task { await AntiSpyService.shared.logAccess(userId: AuthManager().userProfile?.id ?? "unknown", action: "Added Expected Earning", dataIdentifier: request.source) }
        }
    }

    private func markEarningCollected(earningId: String) {
        Task {
            isLoading = true
            errorMessage = nil
            do {
                _ = try await FinancialDataService.shared.recordCollectedEarning(earningId: earningId)
                await loadEarningsData() // Reload data after marking collected
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = error.localizedDescription
                }
            }
            isLoading = false
            Task { await AntiSpyService.shared.logAccess(userId: AuthManager().userProfile?.id ?? "unknown", action: "Marked Earning Collected", dataIdentifier: earningId) }
        }
    }
}

extension DateFormatter {
    static let shortDate: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        return formatter
    }()
}



// Views/FinancialAdviceView.swift
import SwiftUI

struct FinancialAdviceView: View {
    @State private var advice: [String] = []
    @State private var isLoading = false
    @State private var errorMessage: String?

    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 20) {
                Text("Financial AI Assistant")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding(.bottom, 10)

                Text("Insights for Gilbert Algordo:")
                    .font(.title2)
                    .foregroundColor(.secondary)

                if let errorMessage = errorMessage {
                    Text(errorMessage)
                        .foregroundColor(.red)
                        .padding()
                }

                if isLoading {
                    ProgressView("Generating personalized advice...")
                        .padding(.vertical, 50)
                } else if advice.isEmpty && errorMessage == nil {
                    Spacer()
                    Text("Tap 'Get New Advice' to receive personalized financial insights.")
                        .font(.body)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .frame(maxWidth: .infinity)
                    Spacer()
                } else {
                    ScrollView {
                        VStack(alignment: .leading, spacing: 15) {
                            ForEach(advice, id: \.self) { item in
                                CardView {
                                    HStack(alignment: .top) {
                                        Image(systemName: "lightbulb.fill")
                                            .foregroundColor(.yellow)
                                            .font(.title2)
                                        Text(item)
                                            .font(.body)
                                    }
                                    .padding(.vertical, 5)
                                }
                            }
                        }
                    }
                }

                Button("Get New Advice") {
                    fetchAdvice()
                }
                .font(.headline)
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
                .disabled(isLoading)
            }
            .padding()
            .navigationTitle("Advice")
            .navigationBarHidden(true)
        }
        .onAppear {
            if advice.isEmpty && errorMessage == nil {
                fetchAdvice() // Fetch advice on first appearance if not already loaded
            }
        }
    }

    private func fetchAdvice() {
        Task {
            isLoading = true
            errorMessage = nil
            do {
                let response = try await FinancialDataService.shared.getFinancialAdvice()
                DispatchQueue.main.async {
                    self.advice = response.advice
                }
            } catch {
                DispatchQueue.main.async {
                    self.errorMessage = error.localizedDescription
                }
            }
            isLoading = false
            Task { await AntiSpyService.shared.logAccess(userId: AuthManager().userProfile?.id ?? "unknown", action: "Requested Financial Advice") }
        }
    }
}



// Views/SettingsView.swift
import SwiftUI

struct SettingsView: View {
    @State private var isJailbroken: Bool = false

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Account")) {
                    // Placeholder for user profile management etc.
                    Button("Logout") {
                        AuthManager().logout() // Direct call to shared manager
                    }
                    .foregroundColor(.red)
                }

                Section(header: Text("Security & Privacy (Anti-Spy)")) {
                    HStack {
                        Text("Device Jailbroken?")
                        Spacer()
                        if isJailbroken {
                            Text("YES - WARNING!")
                                .foregroundColor(.red)
                                .fontWeight(.bold)
                        } else {
                            Text("No")
                                .foregroundColor(.green)
                        }
                    }
                    Text("This app employs security measures to protect your financial data. Unauthorized modifications to your device (e.g., jailbreaking) can compromise security.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    // Add more security details here:
                    // - SSL Pinning status (if implemented)
                    // - Data encryption status (on-device storage)
                    // - Last security scan result (from backend)
                }
            }
            .navigationTitle("Settings")
            .navigationBarHidden(true)
            .onAppear(perform: checkSecurityStatus)
        }
    }

    private func checkSecurityStatus() {
        isJailbroken = AntiSpyService.shared.isDeviceJailbroken()
        // Here, you could also trigger an API call to your backend
        // to report jailbreak status for enhanced backend-side monitoring.
        Task { await AntiSpyService.shared.logAccess(userId: AuthManager().userProfile?.id ?? "unknown", action: "Viewed Security Settings", dataIdentifier: "Jailbroken: \(isJailbroken)") }
    }
}



cmake_minimum_required(VERSION 3.10)
project(GilbertFinanceAI CXX)

set(CMAKE_CXX_STANDARD 17) # Or 20 for newer features

# Find and link required libraries
# Example for Crypto++ (assuming installed or provided as a submodule)
find_package(CryptoPP CONFIG REQUIRED) # Or adjust find_package for your installation
target_link_libraries(GilbertFinanceAI PRIVATE CryptoPP::cryptopp)

# Example for nlohmann/json (header-only, often just needs include path)
# target_include_directories(GilbertFinanceAI PRIVATE path/to/nlohmann_json)

# Example for curlpp (if installed)
# find_package(CURLPP REQUIRED)
# target_link_libraries(GilbertFinanceAI PRIVATE CURLPP::curlpp)

add_executable(GilbertFinanceAI
    src/main.cpp
    src/FinancialManager.h
    src/FinancialManager.cpp
    src/DataManager.h
    src/DataManager.cpp
    src/NetworkClient.h
    src/NetworkClient.cpp
    src/AntiSpyModule.h
    src/AntiSpyModule.cpp
    src/AIAdvisor.h
    src/AIAdvisor.cpp
    src/Models.h # Data structures
    # Add other source files
)



// src/Models.h
#pragma once

#include <string>
#include <vector>
#include <ctime> // For time_t

// Forward declarations if needed for circular dependencies
// class Account;

namespace Models {

struct FinancialTransaction {
    std::string id;
    std::string account_id;
    time_t date; // Unix timestamp for simplicity
    std::string description;
    double amount;
    std::string type; // e.g., "expense", "income"
    std::string category;
    time_t created_at;
};

struct FinancialAccount {
    std::string id;
    std::string user_id;
    std::string name;
    std::string type; // e.string., "checking", "savings", "credit_card"
    double balance;
    time_t created_at;
};

struct Earning {
    std::string id;
    std::string user_id;
    std::string source;
    double amount;
    time_t due_date;
    time_t collected_date; // 0 if not collected
    std::string status; // "expected", "collected"
    time_t created_at;
};

struct AIAdvice {
    std::string id;
    std::string user_id;
    std::string advice_text;
    time_t generated_at;
};

struct UserSession {
    std::string user_id;
    std::string jwt_token;
    time_t expiry_time;
    // Potentially, an encryption key derived from password
    // (NEVER store raw password)
};

// Error handling types
enum class FinancialErrorType {
    Success,
    AuthenticationFailed,
    NetworkError,
    SerializationError,
    DeserializationError,
    DataNotFound,
    InvalidInput,
    SecurityAlert,
    OtherError
};

struct FinancialError {
    FinancialErrorType type;
    std::string message;
};

} // namespace Models



// src/Utils/SecureConfig.h
#pragma once

#include <string>

namespace SecureConfig {
    // These should ideally be loaded from environment variables or a secure configuration system
    // NOT hardcoded in a real application!
    // Example: const std::string API_BASE_URL = std::getenv("FINANCE_API_URL") ? std::getenv("FINANCE_API_URL") : "http://localhost:3000/api";
    const std::string API_BASE_URL = "http://localhost:3000/api"; // Placeholder for Node.js backend
    const std::string ANTI_SPY_LOG_URL = "http://localhost:3000/api/anti-spy/log"; // Placeholder

    // Dummy secret for encryption for demonstration.
    // In production, this would be derived from a secure user input (password/PIN)
    // using a KDF, or securely stored in hardware-backed storage (TPM/HSM) if available.
    // For *local data encryption*, a key derived from user password is a common robust approach.
    const std::string MASTER_ENCRYPTION_SECRET = "ThisIsAVeryWeakDummySecretForGilbertAlgordoFinanceAI"; // DO NOT USE IN PRODUCTION!
}



// src/Security/CryptoManager.h
#pragma once

#include <string>
#include <vector>
#include <cryptopp/aes.h>
#include <cryptopp/modes.h>
#include <cryptopp/filters.h>
#include <cryptopp/sha.h>
#include <cryptopp/osrng.h> // For AutoSeededRandomPool
#include <cryptopp/hex.h>   // For HexEncoder

namespace Security {

class CryptoManager {
public:
    // Encrypt data using AES-GCM
    // key_hex: Hex-encoded string of the encryption key
    // Returns: Hex-encoded string of the combined ciphertext (ciphertext + IV + tag)
    static std::string encrypt(const std::string& plaintext, const std::string& key_hex);

    // Decrypt data using AES-GCM
    // encrypted_data_hex: Hex-encoded string of the combined ciphertext
    // key_hex: Hex-encoded string of the encryption key
    // Returns: Original plaintext
    static std::string decrypt(const std::string& encrypted_data_hex, const std::string& key_hex);

    // Generate a random AES key (256-bit / 32 bytes)
    // Returns: Hex-encoded string of the key
    static std::string generateAesKey();

    // Generate SHA256 hash of a string
    // Returns: Hex-encoded string of the hash
    static std::string sha256(const std::string& data);

    // Securely wipe memory (prevent sensitive data from lingering)
    static void secure_wipe(void* ptr, size_t size);

private:
    static CryptoPP::SecByteBlock hexDecode(const std::string& hex_string);
    static std::string hexEncode(const CryptoPP::SecByteBlock& bytes);
};

} // namespace Security



// src/Security/CryptoManager.cpp
#include "CryptoManager.h"
#include <iostream>

// Include necessary Crypto++ headers for specific operations
#include <cryptopp/aes.h>
#include <cryptopp/gcm.h>
#include <cryptopp/sha.h>
#include <cryptopp/filters.h>
#include <cryptopp/hex.h>
#include <cryptopp/osrng.h>

namespace Security {

std::string CryptoManager::encrypt(const std::string& plaintext, const std::string& key_hex) {
    try {
        CryptoPP::SecByteBlock key = hexDecode(key_hex);
        if (key.size() != CryptoPP::AES::MAX_KEYLENGTH) {
            throw std::runtime_error("Invalid key size for AES-256.");
        }

        CryptoPP::AutoSeededRandomPool prng;
        CryptoPP::SecByteBlock iv(CryptoPP::AES::BLOCKSIZE); // GCM typically uses 12-byte IV for security, but AES::BLOCKSIZE is common for simplicity. For better security, use 12-byte IV and store it separately or derive.
        prng.GenerateBlock(iv, iv.size());

        CryptoPP::GCM<CryptoPP::AES>::Encryption e;
        e.SetKeyWith-IV(key, key.size(), iv, iv.size());

        std::string ciphertext;
        CryptoPP::AuthenticatedEncryptionFilter ef(e,
            new CryptoPP::StringSink(ciphertext),
            CryptoPP::AuthenticatedEncryptionFilter::DEFAULT_KEYLENGTH_BITS // Tag size in bits
        );

        ef.Put(reinterpret_cast<const CryptoPP::byte*>(plaintext.data()), plaintext.size());
        ef.MessageEnd();

        // Combine IV and ciphertext for storage/transmission
        std::string combined_data;
        CryptoPP::StringSource ss1(iv.data(), iv.size(), true, new CryptoPP::StringSink(combined_data));
        CryptoPP::StringSource ss2(ciphertext, true, new CryptoPP::StringSink(combined_data));

        return hexEncode(CryptoPP::SecByteBlock(reinterpret_cast<const CryptoPP::byte*>(combined_data.data()), combined_data.size()));
    } catch (const CryptoPP::Exception& e) {
        std::cerr << "Encryption Error: " << e.what() << std::endl;
        return "";
    } catch (const std::runtime_error& e) {
        std::cerr << "Encryption Error: " << e.what() << std::endl;
        return "";
    }
}

std::string CryptoManager::decrypt(const std::string& encrypted_data_hex, const std::string& key_hex) {
    try {
        CryptoPP::SecByteBlock key = hexDecode(key_hex);
        if (key.size() != CryptoPP::AES::MAX_KEYLENGTH) {
            throw std::runtime_error("Invalid key size for AES-256.");
        }

        CryptoPP::SecByteBlock combined_bytes = hexDecode(encrypted_data_hex);
        if (combined_bytes.size() < CryptoPP::AES::BLOCKSIZE + 16) { // IV size + tag size
            throw std::runtime_error("Encrypted data too short.");
        }

        CryptoPP::SecByteBlock iv(combined_bytes.data(), CryptoPP::AES::BLOCKSIZE);
        std::string ciphertext_with_tag(reinterpret_cast<const char*>(combined_bytes.data() + CryptoPP::AES::BLOCKSIZE), combined_bytes.size() - CryptoPP::AES::BLOCKSIZE);

        CryptoPP::GCM<CryptoPP::AES>::Decryption d;
        d.SetKeyWith-IV(key, key.size(), iv, iv.size());

        std::string decrypted_text;
        CryptoPP::AuthenticatedDecryptionFilter df(d,
            new CryptoPP::StringSink(decrypted_text),
            CryptoPP::AuthenticatedDecryptionFilter::DEFAULT_KEYLENGTH_BITS // Tag size in bits
        );

        df.Put(reinterpret_cast<const CryptoPP::byte*>(ciphertext_with_tag.data()), ciphertext_with_tag.size());
        df.MessageEnd();

        return decrypted_text;
    } catch (const CryptoPP::Exception& e) {
        std::cerr << "Decryption Error: " << e.what() << std::endl;
        return "";
    } catch (const std::runtime_error& e) {
        std::cerr << "Decryption Error: " << e.what() << std::endl;
        return "";
    }
}

std::string CryptoManager::generateAesKey() {
    CryptoPP::AutoSeededRandomPool prng;
    CryptoPP::SecByteBlock key(CryptoPP::AES::MAX_KEYLENGTH);
    prng.GenerateBlock(key, key.size());
    return hexEncode(key);
}

std::string CryptoManager::sha256(const std::string& data) {
    CryptoPP::SHA256 hash;
    std::string digest;
    CryptoPP::StringSource s(data, true,
        new CryptoPP::HashFilter(hash,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(digest),
                false // lower-case
            )
        )
    );
    return digest;
}

void CryptoManager::secure_wipe(void* ptr, size_t size) {
    // Overwrite memory with zeros and ensure it's not optimized away
    volatile unsigned char* p = reinterpret_cast<volatile unsigned char*>(ptr);
    while (size--) {
        *p++ = 0;
    }
    // For more robust wiping, consider platform-specific APIs if available (e.g., SecureZeroMemory on Windows)
}

CryptoPP::SecByteBlock CryptoManager::hexDecode(const std::string& hex_string) {
    std::string decoded_string;
    CryptoPP::StringSource s(hex_string, true,
        new CryptoPP::HexDecoder(
            new CryptoPP::StringSink(decoded_string)
        )
    );
    return CryptoPP::SecByteBlock(reinterpret_cast<const CryptoPP::byte*>(decoded_string.data()), decoded_string.size());
}

std::string CryptoManager::hexEncode(const CryptoPP::SecByteBlock& bytes) {
    std::string encoded_string;
    CryptoPP::StringSource s(bytes.data(), bytes.size(), true,
        new CryptoPP::HexEncoder(
            new CryptoPP::StringSink(encoded_string),
            false // lower-case
        )
    );
    return encoded_string;
}

} // namespace Security


// src/Security/AntiSpyModule.h
#pragma once

#include <string>
#include <vector>
#include "../Utils/SecureConfig.h" // For API_BASE_URL
#include "../Models.h"

namespace Security {

class AntiSpyModule {
public:
    // Singleton pattern
    static AntiSpyModule& getInstance();

    // Check if the application binary has been tampered with (basic)
    // This would involve hashing sections of the executable and comparing to a stored hash.
    bool checkBinaryIntegrity() const;

    // Check for common debugging tools (platform-specific)
    bool isDebuggerAttached() const;

    // Report security event to backend
    Models::FinancialError logSecurityEvent(const std::string& user_id, const std::string& event_type, const std::string& details);

    // Placeholder for other anti-spy checks
    // bool detectVirtualMachine() const;
    // bool detectHooking() const;

private:
    AntiSpyModule() = default; // Private constructor for singleton
    AntiSpyModule(const AntiSpyModule&) = delete; // Delete copy constructor
    AntiSpyModule& operator=(const AntiSpyModule&) = delete; // Delete assignment operator

    // Helper to get executable path (platform-specific)
    std::string getExecutablePath() const;
};

} // namespace Security



// src/Security/AntiSpyModule.cpp
#include "AntiSpyModule.h"
#include "CryptoManager.h" // For hashing
#include "../Network/NetworkClient.h" // For logging to backend
#include <iostream>
#include <fstream>
#include <sstream>

// Platform-specific headers for anti-tampering (examples for Linux/macOS)
#ifdef _WIN32
#include <Windows.h>
#include <DbgHelp.h> // For IsDebuggerPresent
#elif __APPLE__
#include <sys/sysctl.h> // For sysctl
#include <unistd.h>     // For getpid
#elif __linux__
#include <sys/stat.h> // For stat
#include <fcntl.h>    // For open
#include <unistd.h>   // For readlink, getpid
#endif

namespace Security {

AntiSpyModule& AntiSpyModule::getInstance() {
    static AntiSpyModule instance;
    return instance;
}

// VERY BASIC binary integrity check (needs strong hardening for production)
bool AntiSpyModule::checkBinaryIntegrity() const {
    std::string exec_path = getExecutablePath();
    if (exec_path.empty()) {
        std::cerr << "AntiSpy: Could not get executable path." << std::endl;
        return false;
    }

    // In a real scenario, you'd calculate a hash of critical sections
    // or the entire binary at build time and embed it securely.
    // At runtime, recalculate and compare.
    // This is a *highly simplified* example.
    std::ifstream file(exec_path, std::ios::binary | std::ios::ate);
    if (!file.is_open()) {
        std::cerr << "AntiSpy: Could not open executable for integrity check: " << exec_path << std::endl;
        return false;
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        std::cerr << "AntiSpy: Could not read executable for integrity check." << std::endl;
        return false;
    }

    std::string binary_data(buffer.begin(), buffer.end());
    std::string current_hash = CryptoManager::sha256(binary_data);

    // This "expected_hash" would be calculated at build time and securely embedded
    // or fetched from a secure remote source. Hardcoding is for demo only!
    const std::string EXPECTED_BINARY_HASH = "A_PRECALCULATED_SECURE_HASH_OF_YOUR_BINARY"; // REPLACE ME!
    if (current_hash != EXPECTED_BINARY_HASH) {
        std::cerr << "AntiSpy: Binary integrity check FAILED! Current hash: " << current_hash << std::endl;
        return false;
    }

    std::cout << "AntiSpy: Binary integrity check PASSED." << std::endl;
    return true;
}

// Basic debugger attachment check (platform-specific)
bool AntiSpyModule::isDebuggerAttached() const {
#ifdef _WIN32
    return IsDebuggerPresent();
#elif __APPLE__
    int junk;
    int mib[4];
    struct kinfo_proc info;
    size_t size;

    info.kp_proc.p_flag = 0;
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PID;
    mib[3] = getpid();
    size = sizeof(info);
    junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, NULL, 0);
    if (junk) {
        std::cerr << "AntiSpy: sysctl failed for debugger check." << std::endl;
        return false;
    }
    return ((info.kp_proc.p_flag & P_TRACED) != 0);
#elif __linux__
    // Check /proc/self/status for TracerPid
    std::ifstream status_file("/proc/self/status");
    std::string line;
    while (std::getline(status_file, line)) {
        if (line.rfind("TracerPid:", 0) == 0) { // Starts with "TracerPid:"
            if (line.length() > 10 && std::stoi(line.substr(10)) != 0) {
                return true; // TracerPid is not 0
            }
            break;
        }
    }
    return false;
#else
    // Default for unknown platforms
    std::cerr << "AntiSpy: Debugger check not implemented for this platform." << std::endl;
    return false;
#endif
}

Models::FinancialError AntiSpyModule::logSecurityEvent(const std::string& user_id, const std::string& event_type, const std::string& details) {
    nlohmann::json log_payload = {
        {"userId", user_id},
        {"eventType", event_type},
        {"timestamp", std::time(nullptr)}, // Unix timestamp
        {"details", details}
    };

    NetworkClient& net_client = NetworkClient::getInstance();
    std::string response_str;
    Models::FinancialError err = net_client.post(SecureConfig::ANTI_SPY_LOG_URL, log_payload.dump(), response_str);

    if (err.type == Models::FinancialErrorType::Success) {
        std::cout << "AntiSpy: Security event logged to backend: " << event_type << std::endl;
    } else {
        std::cerr << "AntiSpy: Failed to log security event to backend: " << err.message << std::endl;
    }
    return err;
}

// Platform-specific helper to get executable path
std::string AntiSpyModule::getExecutablePath() const {
#ifdef _WIN32
    char buffer[MAX_PATH];
    GetModuleFileNameA(NULL, buffer, MAX_PATH);
    return std::string(buffer);
#elif __APPLE__
    char path[PATH_MAX];
    uint32_t size = sizeof(path);
    if (_NSGetExecutablePath(path, &size) == 0) {
        return std::string(path);
    }
    return "";
#elif __linux__
    char path[PATH_MAX];
    ssize_t len = readlink("/proc/self/exe", path, sizeof(path) - 1);
    if (len != -1) {
        path[len] = '\0';
        return std::string(path);
    }
    return "";
#else
    return ""; // Not implemented for other platforms
#endif
}

} // namespace Security



// src/Network/NetworkClient.h
#pragma once

#include <string>
#include <curl/curl.h> // Include libcurl header
#include "../Models.h"

namespace Network {

class NetworkClient {
public:
    // Singleton pattern
    static NetworkClient& getInstance();

    // Perform a GET request
    Models::FinancialError get(const std::string& url, std::string& response_body);

    // Perform a POST request
    Models::FinancialError post(const std::string& url, const std::string& request_body, std::string& response_body);

private:
    NetworkClient(); // Private constructor for singleton
    ~NetworkClient(); // Destructor to clean up curl
    NetworkClient(const NetworkClient&) = delete; // Delete copy constructor
    NetworkClient& operator=(const NetworkClient&) = delete; // Delete assignment operator

    CURL* curl_; // libcurl easy handle
};

} // namespace Network



// src/Network/NetworkClient.cpp
#include "NetworkClient.h"
#include <iostream>
#include <nlohmann/json.hpp> // For JSON parsing
#include "../Utils/SecureConfig.h" // For API_BASE_URL

namespace Network {

// Callback function for libcurl to write received data
size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

NetworkClient& NetworkClient::getInstance() {
    static NetworkClient instance;
    return instance;
}

NetworkClient::NetworkClient() : curl_(nullptr) {
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl_ = curl_easy_init();
    if (curl_) {
        curl_easy_setopt(curl_, CURLOPT_WRITEFUNCTION, WriteCallback);
        // Always enforce HTTPS for financial data
        curl_easy_setopt(curl_, CURLOPT_USE_SSL, CURLUSESSL_ALL);
        curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYPEER, 1L); // Verify server's authenticity
        curl_easy_setopt(curl_, CURLOPT_SSL_VERIFYHOST, 2L); // Verify hostname in certificate
        // For production, consider CURLOPT_CAINFO to specify trusted CA bundle
        // or CURLOPT_SSLCERT/CURLOPT_SSLKEY for client-side certificates if needed.
        // For SSL Pinning, you'd use CURLOPT_PINNEDPUBLICKEY.
    } else {
        std::cerr << "NetworkClient: Failed to initialize curl." << std::endl;
    }
}

NetworkClient::~NetworkClient() {
    if (curl_) {
        curl_easy_cleanup(curl_);
    }
    curl_global_cleanup();
}

Models::FinancialError NetworkClient::get(const std::string& url, std::string& response_body) {
    if (!curl_) {
        return {Models::FinancialErrorType::NetworkError, "Curl not initialized."};
    }

    response_body.clear();
    curl_easy_setopt(curl_, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl_, CURLOPT_HTTPGET, 1L);
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response_body);

    // Add JWT token from a secure storage (e.g., in-memory or secure file)
    // For demo, assume token is passed or managed elsewhere
    // struct curl_slist *headers = NULL;
    // headers = curl_slist_append(headers, "x-auth-token: YOUR_JWT_TOKEN_HERE");
    // curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, headers);

    CURLcode res = curl_easy_perform(curl_);
    long http_code = 0;
    curl_easy_getinfo(curl_, CURLINFO_RESPONSE_CODE, &http_code);

    // curl_slist_free_all(headers); // Free header list

    if (res != CURLE_OK) {
        return {Models::FinancialErrorType::NetworkError, "GET request failed: " + std::string(curl_easy_strerror(res))};
    }
    if (http_code < 200 || http_code >= 300) {
        return {Models::FinancialErrorType::NetworkError, "HTTP Error: " + std::to_string(http_code) + " - " + response_body};
    }
    return {Models::FinancialErrorType::Success, ""};
}

Models::FinancialError NetworkClient::post(const std::string& url, const std::string& request_body, std::string& response_body) {
    if (!curl_) {
        return {Models::FinancialErrorType::NetworkError, "Curl not initialized."};
    }

    response_body.clear();
    curl_easy_setopt(curl_, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl_, CURLOPT_POSTFIELDS, request_body.c_str());
    curl_easy_setopt(curl_, CURLOPT_POSTFIELDSIZE, request_body.length());
    curl_easy_setopt(curl_, CURLOPT_WRITEDATA, &response_body);

    struct curl_slist *headers = NULL;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    // Add JWT token if required for this endpoint
    // headers = curl_slist_append(headers, "x-auth-token: YOUR_JWT_TOKEN_HERE");
    curl_easy_setopt(curl_, CURLOPT_HTTPHEADER, headers);

    CURLcode res = curl_easy_perform(curl_);
    long http_code = 0;
    curl_easy_getinfo(curl_, CURLINFO_RESPONSE_CODE, &http_code);

    curl_slist_free_all(headers); // Free header list

    if (res != CURLE_OK) {
        return {Models::FinancialErrorType::NetworkError, "POST request failed: " + std::string(curl_easy_strerror(res))};
    }
    if (http_code < 200 || http_code >= 300) {
        return {Models::FinancialErrorType::NetworkError, "HTTP Error: " + std::to_string(http_code) + " - " + response_body};
    }
    return {Models::FinancialErrorType::Success, ""};
}

} // namespace Network



// src/FinancialManager.h
#pragma once

#include <string>
#include <vector>
#include <memory>
#include "../Models.h"
#include "../Security/CryptoManager.h" // For local encryption
#include "../Network/NetworkClient.h"   // For API calls

namespace Core {

class FinancialManager {
public:
    FinancialManager();

    // Authentication
    Models::FinancialError authenticate(const std::string& username, const std::string& password);
    void logout();
    bool isAuthenticated() const { return current_session_.user_id != ""; }
    const Models::UserSession& getCurrentSession() const { return current_session_; }

    // Accounts
    Models::FinancialError addAccount(const std::string& name, const std::string& type, double initial_balance);
    std::vector<Models::FinancialAccount> getAccounts() const;
    Models::FinancialError updateAccountBalance(const std::string& account_id, double amount);

    // Transactions
    Models::FinancialError recordTransaction(const std::string& account_id, time_t date, const std::string& description, double amount, const std::string& type, const std::string& category);
    std::vector<Models::FinancialTransaction> getTransactions() const;

    // Earnings Collector
    Models::FinancialError addExpectedEarning(const std::string& source, double amount, time_t due_date);
    Models::FinancialError markEarningCollected(const std::string& earning_id);
    std::vector<Models::Earning> getExpectedEarnings() const;
    double getTotalCollectedEarnings() const;

    // AI Assistant (calls to backend AI)
    Models::FinancialError getFinancialAdvice(std::vector<std::string>& advice_list);
    // Models::FinancialError analyzeSpendingPatterns(std::map<std::string, double>& categories); // Could return more complex structure

private:
    Models::UserSession current_session_;
    std::string master_encryption_key_hex_; // Derived from password/PIN and used for local data encryption

    // In-memory data storage (for simplicity, a real app would use a DB)
    std::vector<Models::FinancialAccount> accounts_;
    std::vector<Models::FinancialTransaction> transactions_;
    std::vector<Models::Earning> earnings_;

    // Helper to load/save session (e.g., JWT) securely (e.g., to encrypted file/keychain)
    Models::FinancialError loadSession();
    Models::FinancialError saveSession();
    void clearSession();

    // Helper for data serialization/deserialization to/from JSON
    template<typename T>
    Models::FinancialError deserializeJson(const std::string& json_str, T& obj);
    template<typename T>
    std::string serializeJson(const T& obj);

    // Data persistence methods (will eventually interact with a DB)
    Models::FinancialError loadAllData();
    Models::FinancialError saveAllData();
};

} // namespace Core


// src/FinancialManager.cpp
#include "FinancialManager.h"
#include "../Security/AntiSpyModule.h" // For security logging
#include "../Utils/SecureConfig.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <nlohmann/json.hpp> // For JSON parsing
#include <algorithm>

namespace Core {

FinancialManager::FinancialManager() {
    // Attempt to load previous session (e.g., JWT token from a secure location)
    // This is crucial for "remember me" functionality.
    loadSession();

    // Perform initial security checks
    Security::AntiSpyModule& antiSpy = Security::AntiSpyModule::getInstance();
    if (antiSpy.isDebuggerAttached()) {
        std::cerr << "WARNING: Debugger detected!" << std::endl;
        antiSpy.logSecurityEvent(current_session_.user_id, "DebuggerDetected", "Application launched with debugger attached.");
        // Potentially terminate application or disable sensitive features
    }
    if (!antiSpy.checkBinaryIntegrity()) {
        std::cerr << "WARNING: Application binary integrity compromised!" << std::endl;
        antiSpy.logSecurityEvent(current_session_.user_id, "BinaryTampered", "Application binary hash mismatch.");
        // Potentially terminate application
    }

    // Load local financial data (if not using backend for all data)
    loadAllData();
}

// Authentication
Models::FinancialError FinancialManager::authenticate(const std::string& username, const std::string& password) {
    // In a real application, this would involve:
    // 1. Hashing the password securely (e.g., PBKDF2) locally (or on backend).
    // 2. Sending credentials over HTTPS to your Node.js backend.
    // 3. Backend verifies credentials and returns a JWT token.
    // 4. Store the JWT token securely (e.g., in `current_session_` and persistently in an encrypted file/keychain).
    // 5. Derive a *master encryption key* from the user's password using a KDF. This key is used
    //    to encrypt sensitive local financial data and is *never stored directly*.

    // *** SIMPLIFIED DEMO AUTHENTICATION ***
    if (username == "gilbert.algordo@example.com" && password == "SecurePa$$w0rd") {
        current_session_.user_id = "gilbert_algordo_user_id"; // Replace with actual user ID from backend
        current_session_.jwt_token = "dummy_jwt_token_for_gilbert"; // Replace with actual JWT
        current_session_.expiry_time = std::time(nullptr) + 3600; // 1 hour expiry

        // Derive master encryption key from password (DUMMY DERIVATION for demo)
        // In real app, use PBKDF2/HKDF with salt
        master_encryption_key_hex_ = Security::CryptoManager::sha256(password + "some_salt_for_key_derivation").substr(0, 64); // Ensure 256-bit key

        saveSession(); // Persist the token
        loadAllData(); // Load encrypted local data using the derived key
        Security::AntiSpyModule::getInstance().logSecurityEvent(current_session_.user_id, "LoginSuccess", "User successfully logged in.");
        return {Models::FinancialErrorType::Success, ""};
    } else {
        Security::AntiSpyModule::getInstance().logSecurityEvent("unknown", "LoginFailure", "Invalid credentials attempted.");
        return {Models::FinancialErrorType::AuthenticationFailed, "Invalid username or password."};
    }
}

void FinancialManager::logout() {
    clearSession();
    accounts_.clear();
    transactions_.clear();
    earnings_.clear();
    Security::AntiSpyModule::getInstance().logSecurityEvent(current_session_.user_id, "Logout", "User logged out.");
}

// Accounts
Models::FinancialError FinancialManager::addAccount(const std::string& name, const std::string& type, double initial_balance) {
    if (!isAuthenticated()) {
        return {Models::FinancialErrorType::AuthenticationFailed, "Not authenticated."};
    }
    Models::FinancialAccount new_account;
    new_account.id = "acc_" + std::to_string(std::time(nullptr)) + std::to_string(accounts_.size()); // Simple ID generation
    new_account.user_id = current_session_.user_id;
    new_account.name = name;
    new_account.type = type;
    new_account.balance = initial_balance;
    new_account.created_at = std::time(nullptr);
    accounts_.push_back(new_account);
    saveAllData(); // Save local changes
    return {Models::FinancialErrorType::Success, ""};
}

std::vector<Models::FinancialAccount> FinancialManager::getAccounts() const {
    return accounts_;
}

Models::FinancialError FinancialManager::updateAccountBalance(const std::string& account_id, double amount) {
    if (!isAuthenticated()) {
        return {Models::FinancialErrorType::AuthenticationFailed, "Not authenticated."};
    }
    auto it = std::find_if(accounts_.begin(), accounts_.end(), [&](const Models::FinancialAccount& acc){
        return acc.id == account_id;
    });

    if (it != accounts_.end()) {
        it->balance += amount;
        saveAllData();
        return {Models::FinancialErrorType::Success, ""};
    }
    return {Models::FinancialErrorType::DataNotFound, "Account not found."};
}

// Transactions
Models::FinancialError FinancialManager::recordTransaction(const std::string& account_id, time_t date, const std::string& description, double amount, const std::string& type, const std::string& category) {
    if (!isAuthenticated()) {
        return {Models::FinancialErrorType::AuthenticationFailed, "Not authenticated."};
    }
    Models::FinancialTransaction new_transaction;
    new_transaction.id = "txn_" + std::to_string(std::time(nullptr)) + std::to_string(transactions_.size());
    new_transaction.account_id = account_id;
    new_transaction.date = date;
    new_transaction.description = description;
    new_transaction.amount = amount;
    new_transaction.type = type;
    new_transaction.category = category;
    new_transaction.created_at = std::time(nullptr);
    transactions_.push_back(new_transaction);
    updateAccountBalance(account_id, (type == "expense" ? -amount : amount)); // Update balance
    saveAllData();
    return {Models::FinancialErrorType::Success, ""};
}

std::vector<Models::FinancialTransaction> FinancialManager::getTransactions() const {
    return transactions_;
}

// Earnings Collector
Models::FinancialError FinancialManager::addExpectedEarning(const std::string& source, double amount, time_t due_date) {
    if (!isAuthenticated()) {
        return {Models::FinancialErrorType::AuthenticationFailed, "Not authenticated."};
    }
    Models::Earning new_earning;
    new_earning.id = "earning_" + std::to_string(std::time(nullptr)) + std::to_string(earnings_.size());
    new_earning.user_id = current_session_.user_id;
    new_earning.source = source;
    new_earning.amount = amount;
    new_earning.due_date = due_date;
    new_earning.collected_date = 0; // Not collected yet
    new_earning.status = "expected";
    new_earning.created_at = std::time(nullptr);
    earnings_.push_back(new_earning);
    saveAllData();
    return {Models::FinancialErrorType::Success, ""};
}

Models::FinancialError FinancialManager::markEarningCollected(const std::string& earning_id) {
    if (!isAuthenticated()) {
        return {Models::FinancialErrorType::AuthenticationFailed, "Not authenticated."};
    }
    auto it = std::find_if(earnings_.begin(), earnings_.end(), [&](const Models::Earning& e){
        return e.id == earning_id && e.status == "expected";
    });

    if (it != earnings_.end()) {
        it->collected_date = std::time(nullptr);
        it->status = "collected";
        // Potentially add to an "income" account
        // updateAccountBalance("income_account_id", it->amount);
        saveAllData();
        return {Models::FinancialErrorType::Success, ""};
    }
    return {Models::FinancialErrorType::DataNotFound, "Expected earning not found or already collected."};
}

std::vector<Models::Earning> FinancialManager::getExpectedEarnings() const {
    std::vector<Models::Earning> filtered_earnings;
    for (const auto& earning : earnings_) {
        if (earning.status == "expected") {
            filtered_earnings.push_back(earning);
        }
    }
    return filtered_earnings;
}

double FinancialManager::getTotalCollectedEarnings() const {
    double total = 0.0;
    for (const auto& earning : earnings_) {
        if (earning.status == "collected") {
            total += earning.amount;
        }
    }
    return total;
}

// AI Assistant
Models::FinancialError FinancialManager::getFinancialAdvice(std::vector<std::string>& advice_list) {
    if (!isAuthenticated()) {
        return {Models::FinancialErrorType::AuthenticationFailed, "Not authenticated."};
    }
    // This would call your Node.js backend AI endpoint
    Network::NetworkClient& net_client = Network::NetworkClient::getInstance();
    std::string response_body;
    Models::FinancialError err = net_client.get(SecureConfig::API_BASE_URL + "/finance/advice", response_body);

    if (err.type == Models::FinancialErrorType::Success) {
        try {
            nlohmann::json json_response = nlohmann::json::parse(response_body);
            if (json_response.contains("advice") && json_response["advice"].is_array()) {
                advice_list = json_response["advice"].get<std::vector<std::string>>();
                return {Models::FinancialErrorType::Success, ""};
            } else {
                return {Models::FinancialErrorType::DeserializationError, "Invalid advice format from AI."};
            }
        } catch (const nlohmann::json::exception& e) {
            return {Models::FinancialErrorType::DeserializationError, "JSON parsing error: " + std::string(e.what())};
        }
    }
    return err; // Return network error
}

// Private helper methods for session/data persistence

// DUMMY FILE PATH FOR DEMO - A real app would use platform-specific secure storage
// (e.g., Apple Keychain, Windows Credential Manager, or encrypted config files in user data directory)
const std::string SESSION_FILE = "session.bin.enc";
const std::string DATA_FILE = "data.bin.enc";

Models::FinancialError FinancialManager::loadSession() {
    std::ifstream file(SESSION_FILE, std::ios::binary);
    if (!file.is_open()) {
        return {Models::FinancialErrorType::DataNotFound, "Session file not found."};
    }

    std::stringstream ss;
    ss << file.rdbuf();
    std::string encrypted_session_data = ss.str();

    // The encryption key for session itself should not depend on password directly,
    // but rather derived from a system-level secure mechanism or
    // from a hardware-backed root key (if available).
    // For this example, we'll use the dummy master key as a placeholder, which is INSECURE.
    // In a real app, JWT token should be handled carefully, often directly from Keychain/Credential Manager.
    if (SecureConfig::MASTER_ENCRYPTION_SECRET.empty()) {
        std::cerr << "WARNING: Master encryption secret is empty. Cannot decrypt session." << std::endl;
        return {Models::FinancialErrorType::SecurityAlert, "Encryption key missing for session."};
    }
    std::string decrypted_session_json = Security::CryptoManager::decrypt(encrypted_session_data, Security::CryptoManager::sha256(SecureConfig::MASTER_ENCRYPTION_SECRET).substr(0, 64)); // DUMMY KEY

    if (decrypted_session_json.empty()) {
        return {Models::FinancialErrorType::SecurityAlert, "Failed to decrypt session."};
    }

    try {
        nlohmann::json j = nlohmann::json::parse(decrypted_session_json);
        current_session_.user_id = j.value("userId", "");
        current_session_.jwt_token = j.value("jwtToken", "");
        current_session_.expiry_time = j.value("expiryTime", 0);
        master_encryption_key_hex_ = j.value("masterKeyHex", ""); // Store the key used for data encryption here (if different)

        if (std::time(nullptr) >= current_session_.expiry_time) {
            clearSession(); // Token expired
            return {Models::FinancialErrorType::AuthenticationFailed, "Session expired."};
        }
        return {Models::FinancialErrorType::Success, ""};
    } catch (const nlohmann::json::exception& e) {
        return {Models::FinancialErrorType::DeserializationError, "Failed to parse session JSON: " + std::string(e.what())};
    }
}

Models::FinancialError FinancialManager::saveSession() {
    nlohmann::json j;
    j["userId"] = current_session_.user_id;
    j["jwtToken"] = current_session_.jwt_token;
    j["expiryTime"] = current_session_.expiry_time;
    j["masterKeyHex"] = master_encryption_key_hex_; // Store the key used for data encryption
    std::string session_json = j.dump();

    std::string encrypted_session_data = Security::CryptoManager::encrypt(session_json, Security::CryptoManager::sha256(SecureConfig::MASTER_ENCRYPTION_SECRET).substr(0, 64)); // DUMMY KEY
    if (encrypted_session_data.empty()) {
        return {Models::FinancialErrorType::SecurityAlert, "Failed to encrypt session data."};
    }

    std::ofstream file(SESSION_FILE, std::ios::binary);
    if (!file.is_open()) {
        return {Models::FinancialErrorType::OtherError, "Failed to open session file for writing."};
    }
    file << encrypted_session_data;
    file.close();
    return {Models::FinancialErrorType::Success, ""};
}

void FinancialManager::clearSession() {
    Security::CryptoManager::secure_wipe(&current_session_, sizeof(current_session_)); // Wipe sensitive session data
    current_session_ = {}; // Reset struct
    master_encryption_key_hex_.clear();
    std::remove(SESSION_FILE.c_str()); // Delete session file
}

// Data persistence methods for accounts, transactions, earnings
// In a real application, these would interact with a secure database (e.g., SQLite with SQLCipher)
// For this example, we'll serialize to JSON and encrypt the whole file.
// This is *highly simplified* and meant for demonstration of encryption concept.
// PER-FIELD ENCRYPTION within a database is typically preferred for fine-grained control.

Models::FinancialError FinancialManager::loadAllData() {
    if (master_encryption_key_hex_.empty()) {
        // Cannot load data without an encryption key
        return {Models::FinancialErrorType::SecurityAlert, "Encryption key not available to load data."};
    }

    std::ifstream file(DATA_FILE, std::ios::binary);
    if (!file.is_open()) {
        std::cout << "Data file not found, starting with empty data." << std::endl;
        return {Models::FinancialErrorType::DataNotFound, "Data file not found."};
    }

    std::stringstream ss;
    ss << file.rdbuf();
    std::string encrypted_data = ss.str();
    file.close();

    std::string decrypted_json_data = Security::CryptoManager::decrypt(encrypted_data, master_encryption_key_hex_);
    if (decrypted_json_data.empty()) {
        return {Models::FinancialErrorType::SecurityAlert, "Failed to decrypt financial data. Key mismatch or corruption."};
    }

    try {
        nlohmann::json j = nlohmann::json::parse(decrypted_json_data);
        if (j.contains("accounts")) {
            accounts_ = j["accounts"].get<std::vector<Models::FinancialAccount>>();
        }
        if (j.contains("transactions")) {
            transactions_ = j["transactions"].get<std::vector<Models::FinancialTransaction>>();
        }
        if (j.contains("earnings")) {
            earnings_ = j["earnings"].get<std::vector<Models::Earning>>();
        }
        std::cout << "Financial data loaded and decrypted successfully." << std::endl;
        return {Models::FinancialErrorType::Success, ""};
    } catch (const nlohmann::json::exception& e) {
        return {Models::FinancialErrorType::DeserializationError, "Failed to parse data JSON after decryption: " + std::string(e.what())};
    }
}

Models::FinancialError FinancialManager::saveAllData() {
    if (master_encryption_key_hex_.empty()) {
        return {Models::FinancialErrorType::SecurityAlert, "Encryption key not available to save data."};
    }

    nlohmann::json j;
    j["accounts"] = accounts_;
    j["transactions"] = transactions_;
    j["earnings"] = earnings_;

    std::string json_data = j.dump();
    std::string encrypted_data = Security::CryptoManager::encrypt(json_data, master_encryption_key_hex_);

    if (encrypted_data.empty()) {
        return {Models::FinancialErrorType::SecurityAlert, "Failed to encrypt financial data for saving."};
    }

    std::ofstream file(DATA_FILE, std::ios::binary);
    if (!file.is_open()) {
        return {Models::FinancialErrorType::OtherError, "Failed to open data file for writing."};
    }
    file << encrypted_data;
    file.close();
    std::cout << "Financial data saved and encrypted successfully." << std::endl;
    return {Models::FinancialErrorType::Success, ""};
}

// JSON Serialization/Deserialization for Models (using nlohmann/json)
// Implement these specializations in .cpp or as free functions in a utils file

void to_json(nlohmann::json& j, const Models::FinancialTransaction& t) {
    j = nlohmann::json{
        {"id", t.id},
        {"account_id", t.account_id},
        {"date", t.date},
        {"description", t.description},
        {"amount", t.amount},
        {"type", t.type},
        {"category", t.category},
        {"created_at", t.created_at}
    };
}

void from_json(const nlohmann::json& j, Models::FinancialTransaction& t) {
    j.at("id").get_to(t.id);
    j.at("account_id").get_to(t.account_id);
    j.at("date").get_to(t.date);
    j.at("description").get_to(t.description);
    j.at("amount").get_to(t.amount);
    j.at("type").get_to(t.type);
    j.at("category").get_to(t.category);
    j.at("created_at").get_to(t.created_at);
}

void to_json(nlohmann::json& j, const Models::FinancialAccount& a) {
    j = nlohmann::json{
        {"id", a.id},
        {"user_id", a.user_id},
        {"name", a.name},
        {"type", a.type},
        {"balance", a.balance},
        {"created_at", a.created_at}
    };
}

void from_json(const nlohmann::json& j, Models::FinancialAccount& a) {
    j.at("id").get_to(a.id);
    j.at("user_id").get_to(a.user_id);
    j.at("name").get_to(a.name);
    j.at("type").get_to(a.type);
    j.at("balance").get_to(a.balance);
    j.at("created_at").get_to(a.created_at);
}

void to_json(nlohmann::json& j, const Models::Earning& e) {
    j = nlohmann::json{
        {"id", e.id},
        {"user_id", e.user_id},
        {"source", e.source},
        {"amount", e.amount},
        {"due_date", e.due_date},
        {"collected_date", e.collected_date},
        {"status", e.status},
        {"created_at", e.created_at}
    };
}

void from_json(const nlohmann::json& j, Models::Earning& e) {
    j.at("id").get_to(e.id);
    j.at("user_id").get_to(e.user_id);
    j.at("source").get_to(e.source);
    j.at("amount").get_to(e.amount);
    j.at("due_date").get_to(e.due_date);
    j.at("collected_date").get_to(e.collected_date);
    j.at("status").get_to(e.status);
    j.at("created_at").get_to(e.created_at);
}

} // namespace Core



// src/AI/AIAdvisor.h
#pragma once

#include <string>
#include <vector>
#include <memory>
#include "../Models.h"
#include "../Network/NetworkClient.h"

namespace AI {

class AIAdvisor {
public:
    AIAdvisor();

    // Get financial advice from the AI backend
    Models::FinancialError getFinancialAdvice(const std::string& user_id, const std::string& jwt_token, std::vector<std::string>& advice_list);

    // Placeholder for other AI-driven analysis functions
    // Models::FinancialError predictMarketTrends(const std::string& user_id, std::vector<double>& predictions);
    // Models::FinancialError categorizeTransaction(const std::string& description, std::string& category);

private:
    Network::NetworkClient& network_client_;
};

} // namespace AI




// src/AI/AIAdvisor.cpp
#include "AIAdvisor.h"
#include <iostream>
#include <nlohmann/json.hpp>
#include "../Utils/SecureConfig.h"

namespace AI {

AIAdvisor::AIAdvisor() : network_client_(Network::NetworkClient::getInstance()) {
    // Constructor
}

Models::FinancialError AIAdvisor::getFinancialAdvice(const std::string& user_id, const std::string& jwt_token, std::vector<std::string>& advice_list) {
    // The actual implementation should send relevant user financial data to the backend AI
    // For this example, it's just a generic request.
    // In a real scenario, you'd send anonymized or encrypted financial data (e.g., spending patterns, income, goals)
    // for the AI to analyze.

    // Construct the URL to your AI advice endpoint
    std::string url = SecureConfig::API_BASE_URL + "/finance/advice";

    // You might want to include the user_id in the request body for the AI,
    // or the backend derives it from the JWT.
    // For simplicity, this example assumes the backend uses the JWT for context.
    // nlohmann::json request_payload = {{"userId", user_id}};

    std::string response_body;
    // For GET request, no body usually, rely on JWT in header (handled by NetworkClient)
    Models::FinancialError error = network_client_.get(url, response_body); // Pass JWT to NetworkClient if not done globally

    if (error.type == Models::FinancialErrorType::Success) {
        try {
            nlohmann::json json_response = nlohmann::json::parse(response_body);
            if (json_response.contains("advice") && json_response["advice"].is_array()) {
                advice_list = json_response["advice"].get<std::vector<std::string>>();
                return {Models::FinancialErrorType::Success, ""};
            } else {
                return {Models::FinancialErrorType::DeserializationError, "Invalid advice format received from AI backend."};
            }
        } catch (const nlohmann::json::exception& e) {
            return {Models::FinancialErrorType::DeserializationError, "Failed to parse AI advice JSON: " + std::string(e.what())};
        }
    }
    return error; // Return the error from the network client
}

} // namespace AI



// src/main.cpp
#include <iostream>
#include <limits> // For numeric_limits
#include "FinancialManager.h"
#include "Security/AntiSpyModule.h" // For initial security checks
#include "AI/AIAdvisor.h" // For AI integration

// Helper function to get clean line input
std::string getLineInput(const std::string& prompt) {
    std::cout << prompt;
    std::string input;
    std::getline(std::cin >> std::ws, input); // std::ws consumes leading whitespace
    return input;
}

// Helper function to get double input
double getDoubleInput(const std::string& prompt) {
    double value;
    while (true) {
        std::cout << prompt;
        std::cin >> value;
        if (std::cin.fail()) {
            std::cout << "Invalid input. Please enter a number." << std::endl;
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        } else {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return value;
        }
    }
}

// Function to print error
void printError(const Models::FinancialError& err) {
    if (err.type != Models::FinancialErrorType::Success) {
        std::cerr << "Error: [" << static_cast<int>(err.type) << "] " << err.message << std::endl;
    }
}

void displayMainMenu() {
    std::cout << "\n--- Main Menu ---" << std::endl;
    std::cout << "1. Manage Accounts" << std::endl;
    std::cout << "2. Record Transaction" << std::endl;
    std::cout << "3. Earnings Collector" << std::endl;
    std::cout << "4. Get Financial Advice (AI)" << std::endl;
    std::cout << "5. View Transactions" << std::endl;
    std::cout << "6. Logout" << std::endl;
    std::cout << "7. Exit" << std::endl;
    std::cout << "Enter your choice: ";
}

void displayAccountMenu() {
    std::cout << "\n--- Account Management ---" << std::endl;
    std::cout << "1. List Accounts" << std::endl;
    std::cout << "2. Add New Account" << std::endl;
    std::cout << "3. Back to Main Menu" << std::endl;
    std::cout << "Enter your choice: ";
}

void displayEarningsMenu() {
    std::cout << "\n--- Earnings Collector ---" << std::endl;
    std::cout << "1. List Expected Earnings" << std::endl;
    std::cout << "2. Add Expected Earning" << std::endl;
    std::cout << "3. Mark Earning Collected" << std::endl;
    std::cout << "4. View Total Collected" << std::endl;
    std::cout << "5. Back to Main Menu" << std::endl;
    std::cout << "Enter your choice: ";
}

int main() {
    Core::FinancialManager finance_manager;
    // Initial security checks on startup
    Security::AntiSpyModule& antiSpy = Security::AntiSpyModule::getInstance();

    if (antiSpy.isDebuggerAttached()) {
        std::cerr << "CRITICAL SECURITY ALERT: DEBUGGER DETECTED! Terminating application." << std::endl;
        antiSpy.logSecurityEvent("system", "DebuggerDetectedCritical", "Application terminated due to debugger detection at launch.");
        return 1; // Exit immediately
    }
    if (!antiSpy.checkBinaryIntegrity()) {
        std::cerr << "CRITICAL SECURITY ALERT: BINARY TAMPERING DETECTED! Terminating application." << std::endl;
        antiSpy.logSecurityEvent("system", "BinaryTamperedCritical", "Application terminated due to binary integrity check failure at launch.");
        return 1; // Exit immediately
    }
    std::cout << "Initial security checks passed." << std::endl;

    if (!finance_manager.isAuthenticated()) {
        std::cout << "Please log in." << std::endl;
        std::string username = getLineInput("Enter username (email): ");
        std::string password = getLineInput("Enter password: ");
        Models::FinancialError auth_err = finance_manager.authenticate(username, password);
        if (auth_err.type != Models::FinancialErrorType::Success) {
            printError(auth_err);
            std::cerr << "Authentication failed. Exiting." << std::endl;
            return 1;
        }
        std::cout << "Login successful! Welcome, Gilbert Algordo." << std::endl;
    } else {
        std::cout << "Already logged in. Welcome back, Gilbert Algordo." << std::endl;
    }


    int choice;
    do {
        displayMainMenu();
        std::cin >> choice;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear buffer

        switch (choice) {
            case 1: { // Manage Accounts
                int acc_choice;
                do {
                    displayAccountMenu();
                    std::cin >> acc_choice;
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

                    switch (acc_choice) {
                        case 1: { // List Accounts
                            std::cout << "\n--- Your Accounts ---" << std::endl;
                            const auto& accounts = finance_manager.getAccounts();
                            if (accounts.empty()) {
                                std::cout << "No accounts found." << std::endl;
                            } else {
                                for (const auto& acc : accounts) {
                                    std::cout << "ID: " << acc.id
                                              << ", Name: " << acc.name
                                              << ", Type: " << acc.type
                                              << ", Balance: $" << acc.balance << std::endl;
                                }
                            }
                            break;
                        }
                        case 2: { // Add New Account
                            std::string name = getLineInput("Enter account name: ");
                            std::string type = getLineInput("Enter account type (e.g., checking, savings, credit_card): ");
                            double initial_balance = getDoubleInput("Enter initial balance: $");
                            printError(finance_manager.addAccount(name, type, initial_balance));
                            std::cout << "Account added." << std::endl;
                            break;
                        }
                        case 3: // Back
                            break;
                        default:
                            std::cout << "Invalid choice. Please try again." << std::endl;
                    }
                } while (acc_choice != 3);
                break;
            }
            case 2: { // Record Transaction
                std::string account_id = getLineInput("Enter account ID for transaction: ");
                std::string description = getLineInput("Enter transaction description: ");
                double amount = getDoubleInput("Enter amount: $");
                std::string type = getLineInput("Enter transaction type (income/expense): ");
                std::string category = getLineInput("Enter category (e.g., Food, Salary, Rent): ");
                time_t now = std::time(nullptr);
                printError(finance_manager.recordTransaction(account_id, now, description, amount, type, category));
                std::cout << "Transaction recorded." << std::endl;
                break;
            }
            case 3: { // Earnings Collector
                int earn_choice;
                do {
                    displayEarningsMenu();
                    std::cin >> earn_choice;
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

                    switch (earn_choice) {
                        case 1: { // List Expected Earnings
                            std::cout << "\n--- Pending Expected Earnings ---" << std::endl;
                            const auto& expected = finance_manager.getExpectedEarnings();
                            if (expected.empty()) {
                                std::cout << "No pending expected earnings." << std::endl;
                            } else {
                                for (const auto& ear : expected) {
                                    char buf[26];
                                    ctime_s(buf, sizeof(buf), &ear.due_date); // Use ctime_s for secure ctime
                                    std::cout << "ID: " << ear.id
                                              << ", Source: " << ear.source
                                              << ", Amount: $" << ear.amount
                                              << ", Due: " << buf; // buf already has newline
                                }
                            }
                            break;
                        }
                        case 2: { // Add Expected Earning
                            std::string source = getLineInput("Enter earning source: ");
                            double amount = getDoubleInput("Enter expected amount: $");
                            // Simple date input: assume current date for simplicity in CLI
                            time_t due_date = std::time(nullptr); // For demo, due now
                            printError(finance_manager.addExpectedEarning(source, amount, due_date));
                            std::cout << "Expected earning added." << std::endl;
                            break;
                        }
                        case 3: { // Mark Earning Collected
                            std::string earning_id = getLineInput("Enter ID of earning to mark as collected: ");
                            printError(finance_manager.markEarningCollected(earning_id));
                            std::cout << "Earning marked as collected." << std::endl;
                            break;
                        }
                        case 4: { // View Total Collected
                            double total_collected = finance_manager.getTotalCollectedEarnings();
                            std::cout << "\nTotal Collected Earnings: $" << total_collected << std::endl;
                            break;
                        }
                        case 5: // Back
                            break;
                        default:
                            std::cout << "Invalid choice. Please try again." << std::endl;
                    }
                } while (earn_choice != 5);
                break;
            }
            case 4: { // Get Financial Advice (AI)
                std::cout << "\n--- Financial AI Assistant ---" << std::endl;
                std::vector<std::string> advice_list;
                Models::FinancialError ai_err = finance_manager.getFinancialAdvice(advice_list);
                if (ai_err.type == Models::FinancialErrorType::Success) {
                    if (advice_list.empty()) {
                        std::cout << "No specific advice available at this time." << std::endl;
                    } else {
                        for (const auto& advice : advice_list) {
                            std::cout << "- " << advice << std::endl;
                        }
                    }
                } else {
                    printError(ai_err);
                }
                break;
            }
            case 5: { // View Transactions
                std::cout << "\n--- Your Transactions ---" << std::endl;
                const auto& transactions = finance_manager.getTransactions();
                if (transactions.empty()) {
                    std::cout << "No transactions found." << std::endl;
                } else {
                    for (const auto& txn : transactions) {
                        char buf[26];
                        ctime_s(buf, sizeof(buf), &txn.date);
                        std::cout << "ID: " << txn.id
                                  << ", Account: " << txn.account_id
                                  << ", Date: " << buf
                                  << " Desc: " << txn.description
                                  << ", Amount: $" << txn.amount
                                  << ", Type: " << txn.type
                                  << ", Category: " << txn.category << std::endl;
                    }
                }
                break;
            }
            case 6: // Logout
                finance_manager.logout();
                std::cout << "Logged out. Please restart the application to log in again." << std::endl;
                choice = 7; // Exit after logout
                break;
            case 7: // Exit
                std::cout << "Exiting application. Goodbye, Gilbert Algordo!" << std::endl;
                break;
            default:
                std::cout << "Invalid choice. Please try again." << std::endl;
        }
    } while (choice != 7);

    return 0;
}


mkdir build
cd build
cmake ..
make


./GilbertFinanceAI



Building an "Advanced Finance AI Assistant and Earnings Collector with Anti-Spy" in Go for Gilbert Algordo is an excellent choice. Go's strengths, such as strong concurrency with goroutines, robust standard library, excellent performance, and built-in security features, make it highly suitable for high-performance financial applications.
Similar to the C++ version, this is a very complex project, and a full production-ready system would involve extensive development, security auditing, and infrastructure. I will provide a conceptual design and illustrative Go code for key components, focusing on Go-specific advantages and security best practices.
Go's Advantages for Financial Applications:
 * Concurrency (Goroutines & Channels): Easily handle multiple concurrent operations like API calls, data processing, and user requests without complex threading models.
 * Performance: Compiled to native machine code, Go offers performance comparable to C++ for many tasks, crucial for low-latency operations.
 * Strong Standard Library: Go's crypto, net/http, encoding/json, database/sql, and os packages provide robust and secure primitives.
 * Security Focus: Go's design encourages secure coding practices (e.g., explicit error handling, memory safety).
 * Readability & Maintainability: Go's syntax is concise and easy to read, leading to more maintainable code.
 * Cross-Platform Compilation: Easily compile for various operating systems (Windows, macOS, Linux), which is beneficial for desktop applications.
Conceptual Design: Go Financial AI Assistant
Components:
 * Core Financial Logic (financomanager package): Manages accounts, transactions, and earnings.
 * Data Persistence Layer (dataproviders package): Handles secure storage (encrypted local files or encrypted database interaction).
 * Networking Module (networkclient package): Secure communication with external APIs (your AI backend, market data APIs). Includes TLS pinning for enhanced security.
 * Cryptography Module (security/cryptoutil package): Provides encryption, decryption, and hashing functionalities.
 * Anti-Spy / Security Module (security/antispy package): Implements checks for debugging, binary integrity, and reports suspicious activities.
 * AI Integration Module (aiadvisor package): Interfaces with AI models (likely via gRPC or REST calls to your backend).
 * User Interface (CLI or separate frontend): For this example, a simple CLI. For a desktop app, you might use frameworks like fyne.io, walk, or serve a web UI locally.
Key Go Packages to Consider:
 * Cryptography:
   * crypto/aes: AES encryption.
   * crypto/cipher: Block cipher modes (e.g., GCM for authenticated encryption).
   * golang.org/x/crypto/bcrypt or argon2: For secure password hashing (NOT for encryption keys).
   * golang.org/x/crypto/scrypt: Another KDF for key derivation.
 * Networking:
   * net/http: For HTTP/HTTPS client requests.
   * crypto/tls: For configuring TLS, including certificate pinning.
   * google.golang.org/grpc: For high-performance inter-service communication with your AI backend (if using gRPC).
 * JSON Handling:
   * encoding/json: Built-in for JSON serialization/deserialization.
 * Data Persistence:
   * database/sql: Interface for SQL databases.
   * github.com/mattn/go-sqlite3: SQLite driver.
   * github.com/adrg/go-humanize: For human-readable time/size (optional).
 * UUID Generation:
   * github.com/google/uuid: For generating unique IDs.
Illustrative Go Code Structure and Snippets
Project Structure:
gilbert-finance-ai/
├── cmd/
│   └── main.go         // Main application entry point (CLI)
├── internal/
│   ├── models/           // Data structures
│   │   └── models.go
│   ├── security/
│   │   ├── cryptoutil/   // Cryptography utilities
│   │   │   └── cryptoutil.go
│   │   └── antispy/      // Anti-spy features
│   │       └── antispy.go
│   ├── network/
│   │   └── networkclient.go // HTTP/S client with TLS pinning
│   ├── financomanager/ // Core financial logic
│   │   └── financomanager.go
│   ├── aiadvisor/      // AI integration logic
│   │   └── aiadvisor.go
│   └── config/         // Secure configuration loading
│       └── config.go
└── go.mod
└── go.sum

1. go.mod (Initialize with go mod init gilbert-finance-ai)
module gilbert-finance-ai

go 1.22

require (
	github.com/google/uuid v1.6.0
	golang.org/x/crypto v0.24.0 // For bcrypt, scrypt etc.
	// github.com/mattn/go-sqlite3 v1.14.22 // If using SQLite for local storage
)

2. internal/models/models.go (Data Structures)
package models

import (
	"fmt"
	"time"
)

// FinancialErrorType defines types of errors in the application.
type FinancialErrorType int

const (
	Success FinancialErrorType = iota
	AuthenticationFailed
	NetworkError
	SerializationError
	DeserializationError
	DataNotFound
	InvalidInput
	SecurityAlert
	OtherError
)

// FinancialError holds error details.
type FinancialError struct {
	Type    FinancialErrorType
	Message string
}

func (e FinancialError) Error() string {
	return fmt.Sprintf("[%d] %s", e.Type, e.Message)
}

// FinancialTransaction represents a single financial transaction.
type FinancialTransaction struct {
	ID          string    `json:"id"`
	AccountID   string    `json:"account_id"`
	Date        time.Time `json:"date"`
	Description string    `json:"description"`
	Amount      float64   `json:"amount"`
	Type        string    `json:"type"`     // e.g., "expense", "income"
	Category    string    `json:"category"` // e.g., "Food", "Salary", "Rent"
	CreatedAt   time.Time `json:"created_at"`
}

// FinancialAccount represents a user's financial account.
type FinancialAccount struct {
	ID        string    `json:"id"`
	UserID    string    `json:"user_id"`
	Name      string    `json:"name"`
	Type      string    `json:"type"` // e.g., "checking", "savings", "credit_card"
	Balance   float64   `json:"balance"`
	CreatedAt time.Time `json:"created_at"`
}

// Earning represents an expected or collected earning.
type Earning struct {
	ID           string    `json:"id"`
	UserID       string    `json:"user_id"`
	Source       string    `json:"source"`
	Amount       float64   `json:"amount"`
	DueDate      time.Time `json:"due_date"`
	CollectedDate *time.Time `json:"collected_date,omitempty"` // Pointer to allow nil for not collected
	Status       string    `json:"status"`       // "expected", "collected"
	CreatedAt    time.Time `json:"created_at"`
}

// UserSession holds current user session data.
type UserSession struct {
	UserID     string    `json:"user_id"`
	JWTToken   string    `json:"jwt_token"`
	ExpiryTime time.Time `json:"expiry_time"`
	// MasterEncryptionKeyHex is the hex-encoded key derived from user password
	// used to encrypt local financial data. NEVER store raw password.
	MasterEncryptionKeyHex string `json:"master_encryption_key_hex"`
}

// AIAdvice represents a piece of advice from the AI.
type AIAdvice struct {
	ID          string    `json:"id"`
	UserID      string    `json:"user_id"`
	AdviceText  string    `json:"advice_text"`
	GeneratedAt time.Time `json:"generated_at"`
}

// AppData combines all local data for storage.
type AppData struct {
	Accounts    []FinancialAccount    `json:"accounts"`
	Transactions []FinancialTransaction `json:"transactions"`
	Earnings    []Earning             `json:"earnings"`
}

3. internal/config/config.go (Secure Configuration)
CRUCIAL: NEVER hardcode sensitive information. Use environment variables, secure configuration files (encrypted and outside source control), or dedicated secrets management.
package config

import (
	"log"
	"os"
)

// Config holds application configuration.
type Config struct {
	APIBaseURL             string
	AntiSpyLogURL          string
	MasterEncryptionSecret string // ONLY FOR DEMO. In production, derive from user input or secure hardware.
}

// LoadConfig loads configuration from environment variables or defaults.
func LoadConfig() *Config {
	apiBaseURL := os.Getenv("FINANCE_API_URL")
	if apiBaseURL == "" {
		apiBaseURL = "http://localhost:3000/api" // Default for local Node.js backend
	}

	antiSpyLogURL := os.Getenv("ANTI_SPY_LOG_URL")
	if antiSpyLogURL == "" {
		antiSpyLogURL = "http://localhost:3000/api/anti-spy/log" // Default
	}

	// This is highly insecure for a real application.
	// The master encryption secret should be derived from the user's password
	// using a strong KDF (like Argon2 or scrypt) *at login time* and never stored.
	// For persistent data at rest, you'd use OS-level keystores (e.g., macOS Keychain, Windows Credential Manager)
	// or a hardware security module (HSM) for storing the root key that encrypts other keys.
	masterEncryptionSecret := os.Getenv("MASTER_ENCRYPTION_SECRET")
	if masterEncryptionSecret == "" {
		masterEncryptionSecret = "ThisIsAVeryWeakDummySecretForGilbertAlgordoFinanceAI" // DO NOT USE IN PRODUCTION!
		log.Println("WARNING: Using a weak, hardcoded MASTER_ENCRYPTION_SECRET. DO NOT USE IN PRODUCTION!")
	}

	return &Config{
		APIBaseURL:             apiBaseURL,
		AntiSpyLogURL:          antiSpyLogURL,
		MasterEncryptionSecret: masterEncryptionSecret,
	}
}

4. internal/security/cryptoutil/cryptoutil.go (Cryptography)
Go's standard crypto package is excellent. AES-GCM for authenticated encryption.
package cryptoutil

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"log"

	"golang.org/x/crypto/bcrypt"
	"golang.org/x/crypto/scrypt"
)

// GenerateRandomBytes generates a cryptographically secure random byte slice of specified size.
func GenerateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return nil, fmt.Errorf("failed to read random bytes: %w", err)
	}
	return b, nil
}

// Encrypt encrypts plaintext using AES-256 GCM.
// keyHex is the hex-encoded AES key.
// Returns hex-encoded ciphertext, which includes nonce (IV) and GCM tag.
func Encrypt(plaintext []byte, keyHex string) (string, error) {
	key, err := hex.DecodeString(keyHex)
	if err != nil {
		return "", fmt.Errorf("invalid key hex string: %w", err)
	}
	if len(key) != 32 { // AES-256 requires a 32-byte key
		return "", fmt.Errorf("invalid key size: expected 32 bytes for AES-256, got %d", len(key))
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("failed to create AES cipher: %w", err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("failed to create GCM cipher: %w", err)
	}

	nonce, err := GenerateRandomBytes(aesGCM.NonceSize()) // GCM nonce size typically 12 bytes
	if err != nil {
		return "", fmt.Errorf("failed to generate nonce: %w", err)
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil) // nonce is prepended to ciphertext
	return hex.EncodeToString(ciphertext), nil
}

// Decrypt decrypts hex-encoded ciphertext using AES-256 GCM.
// keyHex is the hex-encoded AES key.
func Decrypt(encryptedHex string, keyHex string) ([]byte, error) {
	key, err := hex.DecodeString(keyHex)
	if err != nil {
		return nil, fmt.Errorf("invalid key hex string: %w", err)
	}
	if len(key) != 32 {
		return nil, fmt.Errorf("invalid key size: expected 32 bytes for AES-256, got %d", len(key))
	}

	ciphertext, err := hex.DecodeString(encryptedHex)
	if err != nil {
		return nil, fmt.Errorf("invalid encrypted hex string: %w", err)
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("failed to create AES cipher: %w", err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCM cipher: %w", err)
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, fmt.Errorf("ciphertext too short")
	}

	nonce, encryptedMessage := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, encryptedMessage, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt: %w", err)
	}
	return plaintext, nil
}

// HashPassword hashes a password using bcrypt.
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}
	return string(bytes), nil
}

// CheckPasswordHash compares a plaintext password with a bcrypt hash.
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// DeriveKeyFromPassword uses scrypt to derive a strong key from a password and salt.
// Returns hex-encoded key.
func DeriveKeyFromPassword(password, saltHex string) (string, error) {
	salt, err := hex.DecodeString(saltHex)
	if err != nil {
		return "", fmt.Errorf("invalid salt hex string: %w", err)
	}
	// N, R, P are scrypt parameters. Adjust for desired security and performance.
	// N = 2^14 (16384), R = 8, P = 1 is a common balance. Higher values are more secure but slower.
	key, err := scrypt.Key([]byte(password), salt, 16384, 8, 1, 32) // 32-byte key for AES-256
	if err != nil {
		return "", fmt.Errorf("failed to derive key from password: %w", err)
	}
	return hex.EncodeToString(key), nil
}

// GenerateSalt generates a random salt (e.g., 16 bytes for scrypt).
func GenerateSalt(size int) (string, error) {
	salt, err := GenerateRandomBytes(size)
	if err != nil {
		return "", fmt.Errorf("failed to generate salt: %w", err)
	}
	return hex.EncodeToString(salt), nil
}

// SecureWipe attempts to zero out a byte slice to prevent sensitive data from lingering in memory.
// Note: Go's garbage collector and memory management make true secure wiping difficult
// and not guaranteed. This is a best-effort approach.
func SecureWipe(b []byte) {
	for i := range b {
		b[i] = 0
	}
	// For critical secrets, consider using memory regions that are explicitly locked
	// or handled outside of Go's GC, e.g., using CGo with mlock.
}

5. internal/security/antispy/antispy.go (Anti-Spy/Security)
Anti-tampering in Go is similar to C++ regarding the challenges. Go compiles to a single static binary, which simplifies distribution but makes runtime integrity checks harder.
package antispy

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"runtime"
	"time"

	"gilbert-finance-ai/internal/config"
	"gilbert-finance-ai/internal/models"
)

// AntiSpyModule provides functions for security checks.
type AntiSpyModule struct {
	cfg *config.Config
}

// NewAntiSpyModule creates a new AntiSpyModule instance.
func NewAntiSpyModule(cfg *config.Config) *AntiSpyModule {
	return &AntiSpyModule{cfg: cfg}
}

// GetExecutablePath returns the path to the currently running executable.
func (a *AntiSpyModule) GetExecutablePath() (string, error) {
	execPath, err := os.Executable()
	if err != nil {
		return "", fmt.Errorf("could not get executable path: %w", err)
	}
	return execPath, nil
}

// CheckBinaryIntegrity calculates the SHA256 hash of the current executable
// and compares it to a pre-calculated, securely embedded hash.
// For demonstration, `expectedHash` is hardcoded. In a real app, it would be
// securely embedded at build time (e.g., as a build flag) or fetched from a trusted source.
func (a *AntiSpyModule) CheckBinaryIntegrity(expectedHash string) bool {
	execPath, err := a.GetExecutablePath()
	if err != nil {
		log.Printf("AntiSpy: Failed to get executable path for integrity check: %v", err)
		return false
	}

	file, err := os.Open(execPath)
	if err != nil {
		log.Printf("AntiSpy: Failed to open executable for integrity check: %v", err)
		return false
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		log.Printf("AntiSpy: Failed to hash executable: %v", err)
		return false
	}
	currentHash := hex.EncodeToString(hasher.Sum(nil))

	if currentHash != expectedHash {
		log.Printf("AntiSpy: Binary integrity check FAILED! Expected: %s, Current: %s", expectedHash, currentHash)
		return false
	}

	log.Println("AntiSpy: Binary integrity check PASSED.")
	return true
}

// IsDebuggerAttached attempts to detect if a debugger is attached.
// This is highly platform-specific and easily bypassed by sophisticated attackers.
func (a *AntiSpyModule) IsDebuggerAttached() bool {
	// Dummy implementation for demonstration.
	// Real detection involves checking process flags, parent process, timing attacks, etc.
	// For Linux, check /proc/self/status for TracerPid.
	// For Windows, use IsDebuggerPresent() via syscalls or CGo.
	// For macOS, similar sysctl checks.
	switch runtime.GOOS {
	case "windows":
		// Placeholder: Use syscalls for IsDebuggerPresent
		// E.g., via "golang.org/x/sys/windows"
		// var isDebuggerPresent bool
		// r, _, _ := syscall.Syscall(windows.NewLazyDLL("kernel32.dll").NewProc("IsDebuggerPresent").Addr(), 0, 0, 0, 0)
		// isDebuggerPresent = r != 0
		// return isDebuggerPresent
		log.Println("AntiSpy: Debugger detection not implemented for Windows in this demo.")
		return false // Assume false for demo
	case "linux":
		// Check /proc/self/status for TracerPid
		// Simplified for brevity. A real implementation would read the file.
		// E.g., content, _ := os.ReadFile("/proc/self/status")
		// if strings.Contains(string(content), "TracerPid:\t0") { ... }
		log.Println("AntiSpy: Debugger detection not implemented for Linux in this demo.")
		return false // Assume false for demo
	case "darwin":
		// Check sysctl kern.proc.acflag
		log.Println("AntiSpy: Debugger detection not implemented for macOS in this demo.")
		return false // Assume false for demo
	default:
		log.Println("AntiSpy: Debugger detection not supported on this OS.")
		return false
	}
}

// LogSecurityEvent sends a security event to a backend API.
func (a *AntiSpyModule) LogSecurityEvent(userID, eventType, details string) models.FinancialError {
	payload := map[string]interface{}{
		"userId":    userID,
		"eventType": eventType,
		"timestamp": time.Now().Unix(),
		"details":   details,
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return models.FinancialError{Type: models.SerializationError, Message: fmt.Sprintf("Failed to marshal security event payload: %v", err)}
	}

	req, err := http.NewRequest("POST", a.cfg.AntiSpyLogURL, nil) // No body for demo, would attach jsonPayload
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to create security log request: %v", err)}
	}
	req.Header.Set("Content-Type", "application/json")
	// For production, you'd add authentication headers (e.g., API key or JWT)

	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Do(req) // Use client.Do with actual body
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to send security log: %v", err)}
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to log security event. Status: %d, Response: %s", resp.StatusCode, string(bodyBytes))}
	}

	log.Printf("AntiSpy: Security event logged to backend: %s - %s", eventType, details)
	return models.FinancialError{Type: models.Success}
}

// CheckEnvironment performs various environment checks (e.g., VM detection - highly complex).
func (a *AntiSpyModule) CheckEnvironment() bool {
	// This would involve looking for VM-specific files, registry keys (Windows),
	// or specific hardware characteristics. Very complex and often prone to false positives.
	// For a desktop app, this is typically less critical than for mobile.
	return true // Placeholder
}

6. internal/network/networkclient.go (Networking with TLS Pinning)
Go's net/http and crypto/tls are powerful for secure networking.
package network

import (
	"bytes"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"gilbert-finance-ai/internal/models"
)

// NetworkClient handles HTTP/HTTPS requests with TLS pinning.
type NetworkClient struct {
	httpClient *http.Client
}

// NewNetworkClient creates a new NetworkClient with TLS pinning configured.
// trustedCertsPEM is a string containing PEM-encoded certificates of trusted servers.
// For production, these should be carefully managed (e.g., embedded at build time,
// or fetched from a secure out-of-band source).
func NewNetworkClient(trustedCertsPEM string) (*NetworkClient, error) {
	rootCAs := x509.NewCertPool()
	if !rootCAs.AppendCertsFromPEM([]byte(trustedCertsPEM)) {
		// If trustedCertsPEM is empty or invalid, this will still work but without pinning.
		// For strict pinning, return an error here if trustedCertsPEM is expected.
		log.Println("WARNING: Could not append trusted certs for TLS pinning. Proceeding without strict pinning.")
	}

	tlsConfig := &tls.Config{
		RootCAs: rootCAs,
		// InsecureSkipVerify: false, // Always verify for financial apps
		// Optionally, specify exact server name for hostname verification
		// ServerName: "your.backend.domain.com",
		// For client-side certificates if needed:
		// Certificates: []tls.Certificate{clientCert},
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
		Proxy:           http.ProxyFromEnvironment,
		IdleConnTimeout: 30 * time.Second, // Adjust as needed
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second, // Overall request timeout
	}

	return &NetworkClient{httpClient: client}, nil
}

// Get performs an authenticated GET request.
func (nc *NetworkClient) Get(url, jwtToken string, response interface{}) models.FinancialError {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to create GET request: %v", err)}
	}
	if jwtToken != "" {
		req.Header.Set("Authorization", "Bearer "+jwtToken)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := nc.httpClient.Do(req)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("GET request failed: %v", err)}
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("HTTP GET Error: %d - %s", resp.StatusCode, string(bodyBytes))}
	}

	if response != nil {
		if err := json.NewDecoder(resp.Body).Decode(response); err != nil {
			return models.FinancialError{Type: models.DeserializationError, Message: fmt.Sprintf("Failed to decode GET response: %v", err)}
		}
	}
	return models.FinancialError{Type: models.Success}
}

// Post performs an authenticated POST request with a JSON payload.
func (nc *NetworkClient) Post(url, jwtToken string, requestPayload, response interface{}) models.FinancialError {
	var reqBody io.Reader
	if requestPayload != nil {
		jsonPayload, err := json.Marshal(requestPayload)
		if err != nil {
			return models.FinancialError{Type: models.SerializationError, Message: fmt.Sprintf("Failed to marshal request payload: %v", err)}
		}
		reqBody = bytes.NewBuffer(jsonPayload)
	}

	req, err := http.NewRequest("POST", url, reqBody)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to create POST request: %v", err)}
	}
	if jwtToken != "" {
		req.Header.Set("Authorization", "Bearer "+jwtToken)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := nc.httpClient.Do(req)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("POST request failed: %v", err)}
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("HTTP POST Error: %d - %s", resp.StatusCode, string(bodyBytes))}
	}

	if response != nil {
		if err := json.NewDecoder(resp.Body).Decode(response); err != nil {
			return models.FinancialError{Type: models.DeserializationError, Message: fmt.Sprintf("Failed to decode POST response: %v", err)}
		}
	}
	return models.FinancialError{Type: models.Success}
}

// TrustedCertificatesPEM should contain the PEM-encoded public keys of your backend server's
// certificates (or the CA that signs them).
// For strict TLS pinning, this would be the actual server certificate's public key hash.
// Example (replace with your actual backend's certificate):
const TrustedCertificatesPEM = `
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIQAfPqJ5m8jGkXQ74Q0/J4YzANBgkqhkiG9w0BAQsFADBL
... (Your actual PEM encoded certificate from your backend) ...
-----END CERTIFICATE-----
`
// You would obtain this from your Node.js backend server's certificate.
// For robust pinning, consider pinning the *Subject Public Key Info* (SPKI) hash.

7. internal/financomanager/financomanager.go (Core Financial Logic)
package financomanager

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"sync"
	"time"

	"gilbert-finance-ai/internal/config"
	"gilbert-finance-ai/internal/models"
	"gilbert-finance-ai/internal/network"
	"gilbert-finance-ai/internal/security/antispy"
	"gilbert-finance-ai/internal/security/cryptoutil"

	"github.com/google/uuid"
)

// financomanager manages financial data and operations.
type FinancoManager struct {
	cfg                    *config.Config
	networkClient          *network.NetworkClient
	antiSpyModule          *antispy.AntiSpyModule
	currentSession         models.UserSession
	masterEncryptionKeyHex string // Derived from password at login, used for local data encryption
	mu                     sync.Mutex // Mutex for protecting in-memory data
	appData                models.AppData // In-memory representation of all local data
}

// NewFinancoManager creates and initializes a new FinancoManager.
func NewFinancoManager(cfg *config.Config, netClient *network.NetworkClient, aspy *antispy.AntiSpyModule) *FinancoManager {
	fm := &FinancoManager{
		cfg:           cfg,
		networkClient: netClient,
		antiSpyModule: aspy,
		appData: models.AppData{
			Accounts:     []models.FinancialAccount{},
			Transactions: []models.FinancialTransaction{},
			Earnings:     []models.Earning{},
		},
	}
	fm.loadSession() // Attempt to load previous session
	fm.loadAllData() // Attempt to load local data (will fail if no key)
	return fm
}

// IsAuthenticated checks if a user is currently authenticated.
func (fm *FinancoManager) IsAuthenticated() bool {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.currentSession.UserID != "" && time.Now().Before(fm.currentSession.ExpiryTime)
}

// GetCurrentSession returns the current user session (copy).
func (fm *FinancoManager) GetCurrentSession() models.UserSession {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.currentSession
}

// Authenticate handles user login.
func (fm *FinancoManager) Authenticate(username, password string) models.FinancialError {
	// In a real application, this would involve:
	// 1. Sending credentials (over HTTPS) to your Node.js backend.
	// 2. Backend verifies and returns a JWT token and possibly a user-specific encryption salt.
	// 3. Derive masterEncryptionKeyHex using `scrypt.Key` with the user's password and the unique salt
	//    from the backend or a securely generated local salt.
	// 4. Store the JWT token and masterEncryptionKeyHex in `currentSession` and persist it securely.

	// --- SIMPLIFIED DEMO AUTHENTICATION ---
	if username == "gilbert.algordo@example.com" && password == "SecurePa$$w0rd" {
		fm.mu.Lock()
		defer fm.mu.Unlock()

		fm.currentSession.UserID = "gilbert_algordo_user_id"
		fm.currentSession.JWTToken = "dummy_jwt_token_for_gilbert"
		fm.currentSession.ExpiryTime = time.Now().Add(time.Hour) // 1 hour expiry

		// For demo, derive key from password directly with a fixed salt. HIGHLY INSECURE FOR PROD.
		// In production, the salt would be unique per user and stored/retrieved securely.
		dummySalt := "deadbeef0123456789abcdef" // DO NOT USE FIXED SALT IN PROD
		derivedKey, err := cryptoutil.DeriveKeyFromPassword(password, dummySalt)
		if err != nil {
			log.Printf("Error deriving key: %v", err)
			return models.FinancialError{Type: models.SecurityAlert, Message: "Failed to derive encryption key."}
		}
		fm.masterEncryptionKeyHex = derivedKey
		fm.currentSession.MasterEncryptionKeyHex = derivedKey // Store this for persistence

		fm.saveSession()
		fm.loadAllData() // Load data with the newly derived key
		fm.antiSpyModule.LogSecurityEvent(fm.currentSession.UserID, "LoginSuccess", "User successfully logged in.")
		return models.FinancialError{Type: models.Success}
	} else {
		fm.antiSpyModule.LogSecurityEvent("unknown", "LoginFailure", "Invalid credentials attempted.")
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Invalid username or password."}
	}
}

// Logout clears the current session.
func (fm *FinancoManager) Logout() {
	fm.mu.Lock()
	defer fm.mu.Unlock()

	fm.antiSpyModule.LogSecurityEvent(fm.currentSession.UserID, "Logout", "User logged out.")

	// Securely wipe sensitive data from memory (best effort)
	cryptoutil.SecureWipe([]byte(fm.currentSession.JWTToken))
	cryptoutil.SecureWipe([]byte(fm.masterEncryptionKeyHex))

	fm.currentSession = models.UserSession{} // Reset session
	fm.masterEncryptionKeyHex = ""
	fm.appData = models.AppData{} // Clear in-memory data

	// Remove persistent session and data files
	os.Remove("session.bin.enc")
	os.Remove("data.bin.enc")

	log.Println("User logged out and session data cleared.")
}

// AddAccount adds a new financial account.
func (fm *FinancoManager) AddAccount(name, accountType string, initialBalance float64) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	newAccount := models.FinancialAccount{
		ID:        uuid.New().String(),
		UserID:    fm.currentSession.UserID,
		Name:      name,
		Type:      accountType,
		Balance:   initialBalance,
		CreatedAt: time.Now(),
	}
	fm.appData.Accounts = append(fm.appData.Accounts, newAccount)
	fm.saveAllData()
	return models.FinancialError{Type: models.Success}
}

// GetAccounts returns all financial accounts for the current user.
func (fm *FinancoManager) GetAccounts() []models.FinancialAccount {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.appData.Accounts // Return a copy for safety
}

// UpdateAccountBalance updates an account's balance by adding/subtracting amount.
func (fm *FinancoManager) UpdateAccountBalance(accountID string, amount float64) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	for i := range fm.appData.Accounts {
		if fm.appData.Accounts[i].ID == accountID {
			fm.appData.Accounts[i].Balance += amount
			fm.saveAllData()
			return models.FinancialError{Type: models.Success}
		}
	}
	return models.FinancialError{Type: models.DataNotFound, Message: "Account not found."}
}

// RecordTransaction records a new financial transaction.
func (fm *FinancoManager) RecordTransaction(accountID string, date time.Time, description string, amount float64, txnType, category string) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	newTxn := models.FinancialTransaction{
		ID:          uuid.New().String(),
		AccountID:   accountID,
		Date:        date,
		Description: description,
		Amount:      amount,
		Type:        txnType,
		Category:    category,
		CreatedAt:   time.Now(),
	}
	fm.appData.Transactions = append(fm.appData.Transactions, newTxn)

	// Update account balance
	balanceChange := amount
	if txnType == "expense" {
		balanceChange = -amount
	}
	// Temporarily release mutex for UpdateAccountBalance to avoid deadlock if it locks internally
	// In a real system, you'd carefully design your locking strategy (e.g., using a single global lock or more granular locks).
	fm.mu.Unlock()
	err := fm.UpdateAccountBalance(accountID, balanceChange)
	fm.mu.Lock() // Re-acquire mutex
	if err.Type != models.Success {
		log.Printf("Warning: Failed to update account balance for transaction %s: %v", newTxn.ID, err.Message)
		// Decide if transaction should still be recorded if balance update fails
	}
	fm.saveAllData()
	return models.FinancialError{Type: models.Success}
}

// GetTransactions returns all financial transactions for the current user.
func (fm *FinancoManager) GetTransactions() []models.FinancialTransaction {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.appData.Transactions // Return a copy for safety
}

// AddExpectedEarning adds a new expected earning.
func (fm *FinancoManager) AddExpectedEarning(source string, amount float64, dueDate time.Time) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	newEarning := models.Earning{
		ID:        uuid.New().String(),
		UserID:    fm.currentSession.UserID,
		Source:    source,
		Amount:    amount,
		DueDate:   dueDate,
		Status:    "expected",
		CreatedAt: time.Now(),
	}
	fm.appData.Earnings = append(fm.appData.Earnings, newEarning)
	fm.saveAllData()
	return models.FinancialError{Type: models.Success}
}

// MarkEarningCollected marks an expected earning as collected.
func (fm *FinancoManager) MarkEarningCollected(earningID string) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	for i := range fm.appData.Earnings {
		if fm.appData.Earnings[i].ID == earningID && fm.appData.Earnings[i].Status == "expected" {
			now := time.Now()
			fm.appData.Earnings[i].CollectedDate = &now
			fm.appData.Earnings[i].Status = "collected"
			// Optionally, record as income to an account
			fm.saveAllData()
			return models.FinancialError{Type: models.Success}
		}
	}
	return models.FinancialError{Type: models.DataNotFound, Message: "Expected earning not found or already collected."}
}

// GetExpectedEarnings returns a list of expected (uncollected) earnings.
func (fm *FinancoManager) GetExpectedEarnings() []models.Earning {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	var filtered []models.Earning
	for _, e := range fm.appData.Earnings {
		if e.Status == "expected" {
			filtered = append(filtered, e)
		}
	}
	return filtered
}

// GetTotalCollectedEarnings calculates the total amount of collected earnings.
func (fm *FinancoManager) GetTotalCollectedEarnings() float64 {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	total := 0.0
	for _, e := range fm.appData.Earnings {
		if e.Status == "collected" {
			total += e.Amount
		}
	}
	return total
}

// GetFinancialAdvice fetches financial advice from the AI backend.
func (fm *FinancoManager) GetFinancialAdvice() ([]string, models.FinancialError) {
	if !fm.IsAuthenticated() {
		return nil, models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	session := fm.currentSession // Get session details while holding mutex
	fm.mu.Unlock()

	// In a real scenario, you'd send relevant financial data (anonymized/encrypted)
	// to the AI backend for personalized advice.
	// For this demo, just fetch generic advice.
	type AIAdviceResponse struct {
		Advice []string `json:"advice"`
	}
	var adviceResponse AIAdviceResponse

	err := fm.networkClient.Get(fm.cfg.APIBaseURL+"/finance/advice", session.JWTToken, &adviceResponse)
	if err.Type != models.Success {
		return nil, err
	}
	return adviceResponse.Advice, models.FinancialError{Type: models.Success}
}

// --- Internal Persistence Methods (using encrypted JSON files for demo) ---

const (
	sessionFile = "session.bin.enc"
	dataFile    = "data.bin.enc"
)

// loadSession attempts to load the encrypted user session.
func (fm *FinancoManager) loadSession() {
	file, err := os.Open(sessionFile)
	if err != nil {
		if !os.IsNotExist(err) {
			log.Printf("Error opening session file: %v", err)
		}
		return // File doesn't exist or other error, session remains empty
	}
	defer file.Close()

	encryptedData, err := io.ReadAll(file)
	if err != nil {
		log.Printf("Error reading encrypted session data: %v", err)
		return
	}

	// For session decryption, we use the (insecure) hardcoded secret for this demo.
	// In production, JWTs might be managed directly by OS keystores or hardware.
	decryptedBytes, err := cryptoutil.Decrypt(string(encryptedData), cryptoutil.SHA256(fm.cfg.MasterEncryptionSecret)) // Using SHA256 of dummy secret as key
	if err != nil {
		log.Printf("Failed to decrypt session data (key mismatch?): %v", err)
		return
	}
	cryptoutil.SecureWipe(decryptedBytes) // Wipe plaintext after use

	var session models.UserSession
	if err := json.Unmarshal(decryptedBytes, &session); err != nil {
		log.Printf("Failed to unmarshal session JSON: %v", err)
		return
	}

	if time.Now().After(session.ExpiryTime) {
		log.Println("Loaded session expired. Clearing.")
		fm.currentSession = models.UserSession{}
		fm.masterEncryptionKeyHex = ""
		os.Remove(sessionFile) // Remove expired session file
		return
	}

	fm.currentSession = session
	fm.masterEncryptionKeyHex = session.MasterEncryptionKeyHex // Crucial: load the data encryption key
	log.Println("Session loaded successfully.")
}

// saveSession saves the current user session encrypted.
func (fm *FinancoManager) saveSession() {
	if fm.currentSession.UserID == "" {
		return // No session to save
	}

	sessionJSON, err := json.Marshal(fm.currentSession)
	if err != nil {
		log.Printf("Failed to marshal session JSON for saving: %v", err)
		return
	}

	// For session encryption, we use the (insecure) hardcoded secret for this demo.
	encryptedHex, err := cryptoutil.Encrypt(sessionJSON, cryptoutil.SHA256(fm.cfg.MasterEncryptionSecret)) // Using SHA256 of dummy secret as key
	if err != nil {
		log.Printf("Failed to encrypt session data: %v", err)
		return
	}

	if err := os.WriteFile(sessionFile, []byte(encryptedHex), 0600); err != nil { // Permissions: read/write for owner only
		log.Printf("Failed to write encrypted session file: %v", err)
	}
	log.Println("Session saved successfully.")
}

// loadAllData loads all encrypted financial data.
func (fm *FinancoManager) loadAllData() {
	if fm.masterEncryptionKeyHex == "" {
		log.Println("No master encryption key available. Cannot load local financial data.")
		return
	}

	file, err := os.Open(dataFile)
	if err != nil {
		if !os.IsNotExist(err) {
			log.Printf("Error opening data file: %v", err)
		}
		return // File doesn't exist or other error
	}
	defer file.Close()

	encryptedData, err := io.ReadAll(file)
	if err != nil {
		log.Printf("Error reading encrypted data: %v", err)
		return
	}

	decryptedBytes, err := cryptoutil.Decrypt(string(encryptedData), fm.masterEncryptionKeyHex)
	if err != nil {
		log.Printf("Failed to decrypt financial data (key mismatch? corruption?): %v", err)
		return
	}
	cryptoutil.SecureWipe(decryptedBytes) // Wipe plaintext after use

	var loadedAppData models.AppData
	if err := json.Unmarshal(decryptedBytes, &loadedAppData); err != nil {
		log.Printf("Failed to unmarshal financial data JSON: %v", err)
		return
	}

	fm.appData = loadedAppData // Update in-memory data
	log.Println("Financial data loaded and decrypted successfully.")
}

// saveAllData saves all financial data encrypted.
func (fm *FinancoManager) saveAllData() {
	if fm.masterEncryptionKeyHex == "" {
		log.Println("No master encryption key available. Cannot save local financial data.")
		return
	}

	appDataJSON, err := json.Marshal(fm.appData)
	if err != nil {
		log.Printf("Failed to marshal app data JSON for saving: %v", err)
		return
	}

	encryptedHex, err := cryptoutil.Encrypt(appDataJSON, fm.masterEncryptionKeyHex)
	if err != nil {
		log.Printf("Failed to encrypt app data: %v", err)
		return
	}

	if err := os.WriteFile(dataFile, []byte(encryptedHex), 0600); err != nil {
		log.Printf("Failed to write encrypted data file: %v", err)
	}
	log.Println("Financial data saved and encrypted successfully.")
}

8. cmd/main.go (Main Application Entry Point - CLI)
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"gilbert-finance-ai/internal/config"
	"gilbert-finance-ai/internal/financomanager"
	"gilbert-finance-ai/internal/models"
	"gilbert-finance-ai/internal/network"
	"gilbert-finance-ai/internal/security/antispy"
	"gilbert-finance-ai/internal/security/cryptoutil" // For initial binary hash check

	"github.com/google/uuid"
)

// EXPECTED_BINARY_HASH is a placeholder. In a real app, this would be
// calculated during the build process and securely embedded.
// Example: go build -ldflags "-X main.BinaryHash=$(sha256sum your_binary | awk '{print $1}')"
// And then refer to it as `main.BinaryHash` if using `-X` flag.
const EXPECTED_BINARY_HASH = "REPLACE_THIS_WITH_YOUR_ACTUAL_BINARY_SHA256_HASH" // Example: "a1b2c3d4e5f6..."

var appConfig *config.Config
var networkClient *network.NetworkClient
var antiSpyModule *antispy.AntiSpyModule
var financeManager *financomanager.FinancoManager

func init() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	appConfig = config.LoadConfig()

	// Initialize security modules
	antiSpyModule = antispy.NewAntiSpyModule(appConfig)

	// Initialize network client with TLS pinning
	var err error
	networkClient, err = network.NewNetworkClient(network.TrustedCertificatesPEM)
	if err != nil {
		log.Fatalf("Failed to initialize network client: %v", err)
	}

	// Initialize financial manager
	financeManager = financomanager.NewFinancoManager(appConfig, networkClient, antiSpyModule)
}

func getLineInput(prompt string) string {
	fmt.Print(prompt)
	reader := bufio.NewReader(os.Stdin)
	input, _ := reader.ReadString('\n')
	return strings.TrimSpace(input)
}

func getDoubleInput(prompt string) float64 {
	for {
		input := getLineInput(prompt)
		value, err := strconv.ParseFloat(input, 64)
		if err != nil {
			fmt.Println("Invalid input. Please enter a number.")
			continue
		}
		return value
	}
}

func printError(err models.FinancialError) {
	if err.Type != models.Success {
		fmt.Fprintf(os.Stderr, "Error: %s\n", err.Message)
	}
}

func displayMainMenu() {
	fmt.Println("\n--- Main Menu ---")
	fmt.Println("1. Manage Accounts")
	fmt.Println("2. Record Transaction")
	fmt.Println("3. Earnings Collector")
	fmt.Println("4. Get Financial Advice (AI)")
	fmt.Println("5. View Transactions")
	fmt.Println("6. Logout")
	fmt.Println("7. Exit")
	fmt.Print("Enter your choice: ")
}

func displayAccountMenu() {
	fmt.Println("\n--- Account Management ---")
	fmt.Println("1. List Accounts")
	fmt.Println("2. Add New Account")
	fmt.Println("3. Back to Main Menu")
	fmt.Print("Enter your choice: ")
}

func displayEarningsMenu() {
	fmt.Println("\n--- Earnings Collector ---")
	fmt.Println("1. List Expected Earnings")
	fmt.Println("2. Add Expected Earning")
	fmt.Println("3. Mark Earning Collected")
	fmt.Println("4. View Total Collected")
	fmt.Println("5. Back to Main Menu")
	fmt.Print("Enter your choice: ")
}

func main() {
	// Initial security checks on startup
	if antiSpyModule.IsDebuggerAttached() {
		log.Println("CRITICAL SECURITY ALERT: DEBUGGER DETECTED! Terminating application.")
		antiSpyModule.LogSecurityEvent("system", "DebuggerDetectedCritical", "Application terminated due to debugger detection at launch.")
		os.Exit(1) // Exit immediately
	}

	if !antiSpyModule.CheckBinaryIntegrity(EXPECTED_BINARY_HASH) {
		log.Println("CRITICAL SECURITY ALERT: BINARY TAMPERING DETECTED! Terminating application.")
		antiSpyModule.LogSecurityEvent("system", "BinaryTamperedCritical", "Application terminated due to binary integrity check failure at launch.")
		os.Exit(1) // Exit immediately
	}
	fmt.Println("Initial security checks passed.")

	if !financeManager.IsAuthenticated() {
		fmt.Println("Please log in.")
		username := getLineInput("Enter username (email): ")
		password := getLineInput("Enter password: ")
		authErr := financeManager.Authenticate(username, password)
		if authErr.Type != models.Success {
			printError(authErr)
			fmt.Println("Authentication failed. Exiting.")
			os.Exit(1)
		}
		fmt.Println("Login successful! Welcome, Gilbert Algordo.")
	} else {
		fmt.Println("Already logged in. Welcome back, Gilbert Algordo.")
	}

	for {
		displayMainMenu()
		choiceStr := getLineInput("")
		choice, err := strconv.Atoi(choiceStr)
		if err != nil {
			fmt.Println("Invalid input. Please enter a number.")
			continue
		}

		switch choice {
		case 1: // Manage Accounts
			for {
				displayAccountMenu()
				accChoiceStr := getLineInput("")
				accChoice, err := strconv.Atoi(accChoiceStr)
				if err != nil {
					fmt.Println("Invalid input. Please enter a number.")
					continue
				}

				switch accChoice {
				case 1: // List Accounts
					fmt.Println("\n--- Your Accounts ---")
					accounts := financeManager.GetAccounts()
					if len(accounts) == 0 {
						fmt.Println("No accounts found.")
					} else {
						for _, acc := range accounts {
							fmt.Printf("ID: %s, Name: %s, Type: %s, Balance: $%.2f\n",
								acc.ID, acc.Name, acc.Type, acc.Balance)
						}
					}
				case 2: // Add New Account
					name := getLineInput("Enter account name: ")
					accountType := getLineInput("Enter account type (e.g., checking, savings, credit_card): ")
					initialBalance := getDoubleInput("Enter initial balance: $")
					printError(financeManager.AddAccount(name, accountType, initialBalance))
					fmt.Println("Account added.")
				case 3: // Back
					break
				default:
					fmt.Println("Invalid choice. Please try again.")
				}
				if accChoice == 3 {
					break
				}
			}
		case 2: // Record Transaction
			accountID := getLineInput("Enter account ID for transaction: ")
			description := getLineInput("Enter transaction description: ")
			amount := getDoubleInput("Enter amount: $")
			txnType := getLineInput("Enter transaction type (income/expense): ")
			category := getLineInput("Enter category (e.g., Food, Salary, Rent): ")
			printError(financeManager.RecordTransaction(accountID, time.Now(), description, amount, txnType, category))
			fmt.Println("Transaction recorded.")
		case 3: // Earnings Collector
			for {
				displayEarningsMenu()
				earnChoiceStr := getLineInput("")
				earnChoice, err := strconv.Atoi(earnChoiceStr)
				if err != nil {
					fmt.Println("Invalid input. Please enter a number.")
					continue
				}

				switch earnChoice {
				case 1: // List Expected Earnings
					fmt.Println("\n--- Pending Expected Earnings ---")
					expected := financeManager.GetExpectedEarnings()
					if len(expected) == 0 {
						fmt.Println("No pending expected earnings.")
					} else {
						for _, ear := range expected {
							fmt.Printf("ID: %s, Source: %s, Amount: $%.2f, Due: %s\n",
								ear.ID, ear.Source, ear.Amount, ear.DueDate.Format("2006-01-02"))
						}
					}
				case 2: // Add Expected Earning
					source := getLineInput("Enter earning source: ")
					amount := getDoubleInput("Enter expected amount: $")
					// For simplicity, due date is current time. In real app, parse date input.
					printError(financeManager.AddExpectedEarning(source, amount, time.Now()))
					fmt.Println("Expected earning added.")
				case 3: // Mark Earning Collected
					earningID := getLineInput("Enter ID of earning to mark as collected: ")
					printError(financeManager.MarkEarningCollected(earningID))
					fmt.Println("Earning marked as collected.")
				case 4: // View Total Collected
					totalCollected := financeManager.GetTotalCollectedEarnings()
					fmt.Printf("\nTotal Collected Earnings: $%.2f\n", totalCollected)
				case 5: // Back
					break
				default:
					fmt.Println("Invalid choice. Please try again.")
				}
				if earnChoice == 5 {
					break
				}
			}
		case 4: // Get Financial Advice (AI)
			fmt.Println("\n--- Financial AI Assistant ---")
			adviceList, aiErr := financeManager.GetFinancialAdvice()
			if aiErr.Type == models.Success {
				if len(adviceList) == 0 {
					fmt.Println("No specific advice available at this time.")
				} else {
					for _, advice := range adviceList {
						fmt.Printf("- %s\n", advice)
					}
				}
			} else {
				printError(aiErr)
			}
		case 5: // View Transactions
			fmt.Println("\n--- Your Transactions ---")
			transactions := financeManager.GetTransactions()
			if len(transactions) == 0 {
				fmt.Println("No transactions found.")
			} else {
				for _, txn := range transactions {
					fmt.Printf("ID: %s, Account: %s, Date: %s, Desc: %s, Amount: $%.2f, Type: %s, Category: %s\n",
						txn.ID, txn.AccountID, txn.Date.Format("2006-01-02"), txn.Description, txn.Amount, txn.Type, txn.Category)
				}
			}
		case 6: // Logout
			financeManager.Logout()
			fmt.Println("Logged out. Please restart the application to log in again.")
			return // Exit after logout
		case 7: // Exit
			fmt.Println("Exiting application. Goodbye, Gilbert Algordo!")
			return
		default:
			fmt.Println("Invalid choice. Please try again.")
		}
	}
}

// SHA256 returns the SHA256 hash of a string. Used for dummy key in config/cryptoutil.
// In real use, this would be a secure KDF like scrypt or Argon2.
func (c *CryptoUtil) SHA256(data string) string {
	hasher := sha256.New()
	hasher.Write([]byte(data))
	return hex.EncodeToString(hasher.Sum(nil))
}

// We need to implement SHA256 in cryptoutil.go for the dummy master key logic.
// Add this method to internal/security/cryptoutil/cryptoutil.go
func SHA256(data string) string {
	hasher := sha256.New()
	hasher.Write([]byte(data))
	return hex.EncodeToString(hasher.Sum(nil))
}

Build and Run Instructions:
 * Initialize Go Module:
   cd gilbert-finance-ai
go mod tidy

 * Generate Binary Hash:
   Before building, you need to set EXPECTED_BINARY_HASH. For a real scenario, this would be part of your CI/CD pipeline. For testing, you can build once, get the hash, and then put it in main.go.
   # Step 1: Build without the hash first (temporary)
go build -o gilbert-finance-ai-temp ./cmd

# Step 2: Calculate SHA256 hash of the temporary binary
# For Linux/macOS:
sha256sum gilbert-finance-ai-temp

# For Windows (PowerShell):
Get-FileHash -Algorithm SHA256 .\gilbert-finance-ai-temp.exe | Select-Object -ExpandProperty Hash

   Copy the generated hash.
 * Update cmd/main.go:
   Replace "REPLACE_THIS_WITH_YOUR_ACTUAL_BINARY_SHA256_HASH" in cmd/main.go with the hash you just calculated.
 * Final Build:
   go build -o gilbert-finance-ai ./cmd

 * Run:
   ./gilbert-finance-ai

CRITICAL SECURITY NOTES FOR GO FINANCIAL APPLICATIONS:
 * Password Hashing: Use golang.org/x/crypto/bcrypt or golang.org/x/crypto/argon2 for password hashing. NEVER use plain SHA256 for passwords. The cryptoutil.HashPassword uses bcrypt.
 * Key Derivation Functions (KDFs): For deriving encryption keys from user passwords, use golang.org/x/crypto/scrypt or Argon2. The cryptoutil.DeriveKeyFromPassword uses scrypt. This is crucial for securing local data.
 * Key Storage:
   * NEVER store raw passwords.
   * The masterEncryptionKeyHex in UserSession is for demonstration only. In a real application, this key should be re-derived from the user's password (which is not stored) every time they authenticate.
   * For persistent storage of sensitive data like JWTs or actual encryption keys, use platform-specific secure storage (e.g., macOS Keychain using github.com/keybase/go-keychain, Windows Credential Manager using golang.org/x/sys/windows).
 * Secure Wiping: Go's garbage collector makes true memory wiping difficult to guarantee. cryptoutil.SecureWipe is a best-effort. For extremely sensitive data, consider CGo to interface with OS-level memory locking (e.g., mlock).
 * TLS Pinning: The network.TrustedCertificatesPEM constant should contain the actual public certificate of your backend server, or its public key hash. This prevents MITM attacks even if a CA is compromised. Update this carefully.
 * Anti-Tampering: The antispy module provides basic checks. Robust anti-tampering is extremely complex and involves:
   * Code Obfuscation: Tools to make reverse engineering harder.
   * Runtime Integrity Checks: Continuously verify code sections, data structures, and environmental factors.
   * Anti-Debugging: More advanced techniques to detect and thwart debuggers (highly OS-specific).
   * Root/Jailbreak Detection: For mobile deployments.
   * Environment Checks: Detecting virtual machines or unusual system configurations.
 * Input Validation: Always validate and sanitize all user inputs and data received from external sources (APIs) to prevent injection attacks and other vulnerabilities.
 * Error Handling & Logging: Go's explicit error handling (if err != nil) is a strength. Use structured logging. NEVER log sensitive data (passwords, PII, keys) in plaintext. Mask or redact them.
 * Concurrency Safety: Use mutexes (sync.Mutex) or channels (chan) to protect shared data from race conditions, especially when goroutines are involved. The FinancoManager uses sync.Mutex.
 * Backend Security: The Go application relies on a secure backend (your Node.js service). Ensure the backend also follows best practices for authentication, authorization, data encryption, and API security.
 * Regulatory Compliance: Financial applications must adhere to strict regulations (e.g., PCI DSS, GDPR, CCPA). Consult with legal and compliance experts.
This Go codebase provides a strong starting point for Gilbert Algordo's financial AI assistant, emphasizing Go's capabilities for building performant and secure applications. However, significant hardening and expansion would be necessary for a production environment.



module gilbert-finance-ai

go 1.22

require (
	github.com/google/uuid v1.6.0
	golang.org/x/crypto v0.24.0 // For bcrypt, scrypt etc.
	// github.com/mattn/go-sqlite3 v1.14.22 // If using SQLite for local storage
)



package models

import (
	"fmt"
	"time"
)

// FinancialErrorType defines types of errors in the application.
type FinancialErrorType int

const (
	Success FinancialErrorType = iota
	AuthenticationFailed
	NetworkError
	SerializationError
	DeserializationError
	DataNotFound
	InvalidInput
	SecurityAlert
	OtherError
)

// FinancialError holds error details.
type FinancialError struct {
	Type    FinancialErrorType
	Message string
}

func (e FinancialError) Error() string {
	return fmt.Sprintf("[%d] %s", e.Type, e.Message)
}

// FinancialTransaction represents a single financial transaction.
type FinancialTransaction struct {
	ID          string    `json:"id"`
	AccountID   string    `json:"account_id"`
	Date        time.Time `json:"date"`
	Description string    `json:"description"`
	Amount      float64   `json:"amount"`
	Type        string    `json:"type"`     // e.g., "expense", "income"
	Category    string    `json:"category"` // e.g., "Food", "Salary", "Rent"
	CreatedAt   time.Time `json:"created_at"`
}

// FinancialAccount represents a user's financial account.
type FinancialAccount struct {
	ID        string    `json:"id"`
	UserID    string    `json:"user_id"`
	Name      string    `json:"name"`
	Type      string    `json:"type"` // e.g., "checking", "savings", "credit_card"
	Balance   float64   `json:"balance"`
	CreatedAt time.Time `json:"created_at"`
}

// Earning represents an expected or collected earning.
type Earning struct {
	ID           string    `json:"id"`
	UserID       string    `json:"user_id"`
	Source       string    `json:"source"`
	Amount       float64   `json:"amount"`
	DueDate      time.Time `json:"due_date"`
	CollectedDate *time.Time `json:"collected_date,omitempty"` // Pointer to allow nil for not collected
	Status       string    `json:"status"`       // "expected", "collected"
	CreatedAt    time.Time `json:"created_at"`
}

// UserSession holds current user session data.
type UserSession struct {
	UserID     string    `json:"user_id"`
	JWTToken   string    `json:"jwt_token"`
	ExpiryTime time.Time `json:"expiry_time"`
	// MasterEncryptionKeyHex is the hex-encoded key derived from user password
	// used to encrypt local financial data. NEVER store raw password.
	MasterEncryptionKeyHex string `json:"master_encryption_key_hex"`
}

// AIAdvice represents a piece of advice from the AI.
type AIAdvice struct {
	ID          string    `json:"id"`
	UserID      string    `json:"user_id"`
	AdviceText  string    `json:"advice_text"`
	GeneratedAt time.Time `json:"generated_at"`
}

// AppData combines all local data for storage.
type AppData struct {
	Accounts    []FinancialAccount    `json:"accounts"`
	Transactions []FinancialTransaction `json:"transactions"`
	Earnings    []Earning             `json:"earnings"`
}



package config

import (
	"log"
	"os"
)

// Config holds application configuration.
type Config struct {
	APIBaseURL             string
	AntiSpyLogURL          string
	MasterEncryptionSecret string // ONLY FOR DEMO. In production, derive from user input or secure hardware.
}

// LoadConfig loads configuration from environment variables or defaults.
func LoadConfig() *Config {
	apiBaseURL := os.Getenv("FINANCE_API_URL")
	if apiBaseURL == "" {
		apiBaseURL = "http://localhost:3000/api" // Default for local Node.js backend
	}

	antiSpyLogURL := os.Getenv("ANTI_SPY_LOG_URL")
	if antiSpyLogURL == "" {
		antiSpyLogURL = "http://localhost:3000/api/anti-spy/log" // Default
	}

	// This is highly insecure for a real application.
	// The master encryption secret should be derived from the user's password
	// using a strong KDF (like Argon2 or scrypt) *at login time* and never stored.
	// For persistent data at rest, you'd use OS-level keystores (e.g., macOS Keychain, Windows Credential Manager)
	// or a hardware security module (HSM) for storing the root key that encrypts other keys.
	masterEncryptionSecret := os.Getenv("MASTER_ENCRYPTION_SECRET")
	if masterEncryptionSecret == "" {
		masterEncryptionSecret = "ThisIsAVeryWeakDummySecretForGilbertAlgordoFinanceAI" // DO NOT USE IN PRODUCTION!
		log.Println("WARNING: Using a weak, hardcoded MASTER_ENCRYPTION_SECRET. DO NOT USE IN PRODUCTION!")
	}

	return &Config{
		APIBaseURL:             apiBaseURL,
		AntiSpyLogURL:          antiSpyLogURL,
		MasterEncryptionSecret: masterEncryptionSecret,
	}
}


package cryptoutil

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"log"

	"golang.org/x/crypto/bcrypt"
	"golang.org/x/crypto/scrypt"
)

// GenerateRandomBytes generates a cryptographically secure random byte slice of specified size.
func GenerateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return nil, fmt.Errorf("failed to read random bytes: %w", err)
	}
	return b, nil
}

// Encrypt encrypts plaintext using AES-256 GCM.
// keyHex is the hex-encoded AES key.
// Returns hex-encoded ciphertext, which includes nonce (IV) and GCM tag.
func Encrypt(plaintext []byte, keyHex string) (string, error) {
	key, err := hex.DecodeString(keyHex)
	if err != nil {
		return "", fmt.Errorf("invalid key hex string: %w", err)
	}
	if len(key) != 32 { // AES-256 requires a 32-byte key
		return "", fmt.Errorf("invalid key size: expected 32 bytes for AES-256, got %d", len(key))
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("failed to create AES cipher: %w", err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("failed to create GCM cipher: %w", err)
	}

	nonce, err := GenerateRandomBytes(aesGCM.NonceSize()) // GCM nonce size typically 12 bytes
	if err != nil {
		return "", fmt.Errorf("failed to generate nonce: %w", err)
	}

	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil) // nonce is prepended to ciphertext
	return hex.EncodeToString(ciphertext), nil
}

// Decrypt decrypts hex-encoded ciphertext using AES-256 GCM.
// keyHex is the hex-encoded AES key.
func Decrypt(encryptedHex string, keyHex string) ([]byte, error) {
	key, err := hex.DecodeString(keyHex)
	if err != nil {
		return nil, fmt.Errorf("invalid key hex string: %w", err)
	}
	if len(key) != 32 {
		return nil, fmt.Errorf("invalid key size: expected 32 bytes for AES-256, got %d", len(key))
	}

	ciphertext, err := hex.DecodeString(encryptedHex)
	if err != nil {
		return nil, fmt.Errorf("invalid encrypted hex string: %w", err)
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("failed to create AES cipher: %w", err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCM cipher: %w", err)
	}

	nonceSize := aesGCM.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, fmt.Errorf("ciphertext too short")
	}

	nonce, encryptedMessage := ciphertext[:nonceSize], ciphertext[nonceSize:]
	plaintext, err := aesGCM.Open(nil, nonce, encryptedMessage, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt: %w", err)
	}
	return plaintext, nil
}

// HashPassword hashes a password using bcrypt.
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}
	return string(bytes), nil
}

// CheckPasswordHash compares a plaintext password with a bcrypt hash.
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// DeriveKeyFromPassword uses scrypt to derive a strong key from a password and salt.
// Returns hex-encoded key.
func DeriveKeyFromPassword(password, saltHex string) (string, error) {
	salt, err := hex.DecodeString(saltHex)
	if err != nil {
		return "", fmt.Errorf("invalid salt hex string: %w", err)
	}
	// N, R, P are scrypt parameters. Adjust for desired security and performance.
	// N = 2^14 (16384), R = 8, P = 1 is a common balance. Higher values are more secure but slower.
	key, err := scrypt.Key([]byte(password), salt, 16384, 8, 1, 32) // 32-byte key for AES-256
	if err != nil {
		return "", fmt.Errorf("failed to derive key from password: %w", err)
	}
	return hex.EncodeToString(key), nil
}

// GenerateSalt generates a random salt (e.g., 16 bytes for scrypt).
func GenerateSalt(size int) (string, error) {
	salt, err := GenerateRandomBytes(size)
	if err != nil {
		return "", fmt.Errorf("failed to generate salt: %w", err)
	}
	return hex.EncodeToString(salt), nil
}

// SecureWipe attempts to zero out a byte slice to prevent sensitive data from lingering in memory.
// Note: Go's garbage collector and memory management make true secure wiping difficult
// and not guaranteed. This is a best-effort approach.
func SecureWipe(b []byte) {
	for i := range b {
		b[i] = 0
	}
	// For critical secrets, consider using memory regions that are explicitly locked
	// or handled outside of Go's GC, e.g., using CGo with mlock.
}



package antispy

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"runtime"
	"time"

	"gilbert-finance-ai/internal/config"
	"gilbert-finance-ai/internal/models"
)

// AntiSpyModule provides functions for security checks.
type AntiSpyModule struct {
	cfg *config.Config
}

// NewAntiSpyModule creates a new AntiSpyModule instance.
func NewAntiSpyModule(cfg *config.Config) *AntiSpyModule {
	return &AntiSpyModule{cfg: cfg}
}

// GetExecutablePath returns the path to the currently running executable.
func (a *AntiSpyModule) GetExecutablePath() (string, error) {
	execPath, err := os.Executable()
	if err != nil {
		return "", fmt.Errorf("could not get executable path: %w", err)
	}
	return execPath, nil
}

// CheckBinaryIntegrity calculates the SHA256 hash of the current executable
// and compares it to a pre-calculated, securely embedded hash.
// For demonstration, `expectedHash` is hardcoded. In a real app, it would be
// securely embedded at build time (e.g., as a build flag) or fetched from a trusted source.
func (a *AntiSpyModule) CheckBinaryIntegrity(expectedHash string) bool {
	execPath, err := a.GetExecutablePath()
	if err != nil {
		log.Printf("AntiSpy: Failed to get executable path for integrity check: %v", err)
		return false
	}

	file, err := os.Open(execPath)
	if err != nil {
		log.Printf("AntiSpy: Failed to open executable for integrity check: %v", err)
		return false
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		log.Printf("AntiSpy: Failed to hash executable: %v", err)
		return false
	}
	currentHash := hex.EncodeToString(hasher.Sum(nil))

	if currentHash != expectedHash {
		log.Printf("AntiSpy: Binary integrity check FAILED! Expected: %s, Current: %s", expectedHash, currentHash)
		return false
	}

	log.Println("AntiSpy: Binary integrity check PASSED.")
	return true
}

// IsDebuggerAttached attempts to detect if a debugger is attached.
// This is highly platform-specific and easily bypassed by sophisticated attackers.
func (a *AntiSpyModule) IsDebuggerAttached() bool {
	// Dummy implementation for demonstration.
	// Real detection involves checking process flags, parent process, timing attacks, etc.
	// For Linux, check /proc/self/status for TracerPid.
	// For Windows, use IsDebuggerPresent() via syscalls or CGo.
	// For macOS, similar sysctl checks.
	switch runtime.GOOS {
	case "windows":
		// Placeholder: Use syscalls for IsDebuggerPresent
		// E.g., via "golang.org/x/sys/windows"
		// var isDebuggerPresent bool
		// r, _, _ := syscall.Syscall(windows.NewLazyDLL("kernel32.dll").NewProc("IsDebuggerPresent").Addr(), 0, 0, 0, 0)
		// isDebuggerPresent = r != 0
		// return isDebuggerPresent
		log.Println("AntiSpy: Debugger detection not implemented for Windows in this demo.")
		return false // Assume false for demo
	case "linux":
		// Check /proc/self/status for TracerPid
		// Simplified for brevity. A real implementation would read the file.
		// E.g., content, _ := os.ReadFile("/proc/self/status")
		// if strings.Contains(string(content), "TracerPid:\t0") { ... }
		log.Println("AntiSpy: Debugger detection not implemented for Linux in this demo.")
		return false // Assume false for demo
	case "darwin":
		// Check sysctl kern.proc.acflag
		log.Println("AntiSpy: Debugger detection not implemented for macOS in this demo.")
		return false // Assume false for demo
	default:
		log.Println("AntiSpy: Debugger detection not supported on this OS.")
		return false
	}
}

// LogSecurityEvent sends a security event to a backend API.
func (a *AntiSpyModule) LogSecurityEvent(userID, eventType, details string) models.FinancialError {
	payload := map[string]interface{}{
		"userId":    userID,
		"eventType": eventType,
		"timestamp": time.Now().Unix(),
		"details":   details,
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return models.FinancialError{Type: models.SerializationError, Message: fmt.Sprintf("Failed to marshal security event payload: %v", err)}
	}

	req, err := http.NewRequest("POST", a.cfg.AntiSpyLogURL, nil) // No body for demo, would attach jsonPayload
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to create security log request: %v", err)}
	}
	req.Header.Set("Content-Type", "application/json")
	// For production, you'd add authentication headers (e.g., API key or JWT)

	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Do(req) // Use client.Do with actual body
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to send security log: %v", err)}
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to log security event. Status: %d, Response: %s", resp.StatusCode, string(bodyBytes))}
	}

	log.Printf("AntiSpy: Security event logged to backend: %s - %s", eventType, details)
	return models.FinancialError{Type: models.Success}
}

// CheckEnvironment performs various environment checks (e.g., VM detection - highly complex).
func (a *AntiSpyModule) CheckEnvironment() bool {
	// This would involve looking for VM-specific files, registry keys (Windows),
	// or specific hardware characteristics. Very complex and often prone to false positives.
	// For a desktop app, this is typically less critical than for mobile.
	return true // Placeholder
}



package network

import (
	"bytes"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"gilbert-finance-ai/internal/models"
)

// NetworkClient handles HTTP/HTTPS requests with TLS pinning.
type NetworkClient struct {
	httpClient *http.Client
}

// NewNetworkClient creates a new NetworkClient with TLS pinning configured.
// trustedCertsPEM is a string containing PEM-encoded certificates of trusted servers.
// For production, these should be carefully managed (e.g., embedded at build time,
// or fetched from a secure out-of-band source).
func NewNetworkClient(trustedCertsPEM string) (*NetworkClient, error) {
	rootCAs := x509.NewCertPool()
	if !rootCAs.AppendCertsFromPEM([]byte(trustedCertsPEM)) {
		// If trustedCertsPEM is empty or invalid, this will still work but without pinning.
		// For strict pinning, return an error here if trustedCertsPEM is expected.
		log.Println("WARNING: Could not append trusted certs for TLS pinning. Proceeding without strict pinning.")
	}

	tlsConfig := &tls.Config{
		RootCAs: rootCAs,
		// InsecureSkipVerify: false, // Always verify for financial apps
		// Optionally, specify exact server name for hostname verification
		// ServerName: "your.backend.domain.com",
		// For client-side certificates if needed:
		// Certificates: []tls.Certificate{clientCert},
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
		Proxy:           http.ProxyFromEnvironment,
		IdleConnTimeout: 30 * time.Second, // Adjust as needed
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second, // Overall request timeout
	}

	return &NetworkClient{httpClient: client}, nil
}

// Get performs an authenticated GET request.
func (nc *NetworkClient) Get(url, jwtToken string, response interface{}) models.FinancialError {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to create GET request: %v", err)}
	}
	if jwtToken != "" {
		req.Header.Set("Authorization", "Bearer "+jwtToken)
	}
	req.Header.Set("Accept", "application/json")

	resp, err := nc.httpClient.Do(req)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("GET request failed: %v", err)}
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("HTTP GET Error: %d - %s", resp.StatusCode, string(bodyBytes))}
	}

	if response != nil {
		if err := json.NewDecoder(resp.Body).Decode(response); err != nil {
			return models.FinancialError{Type: models.DeserializationError, Message: fmt.Sprintf("Failed to decode GET response: %v", err)}
		}
	}
	return models.FinancialError{Type: models.Success}
}

// Post performs an authenticated POST request with a JSON payload.
func (nc *NetworkClient) Post(url, jwtToken string, requestPayload, response interface{}) models.FinancialError {
	var reqBody io.Reader
	if requestPayload != nil {
		jsonPayload, err := json.Marshal(requestPayload)
		if err != nil {
			return models.FinancialError{Type: models.SerializationError, Message: fmt.Sprintf("Failed to marshal request payload: %v", err)}
		}
		reqBody = bytes.NewBuffer(jsonPayload)
	}

	req, err := http.NewRequest("POST", url, reqBody)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("Failed to create POST request: %v", err)}
	}
	if jwtToken != "" {
		req.Header.Set("Authorization", "Bearer "+jwtToken)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := nc.httpClient.Do(req)
	if err != nil {
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("POST request failed: %v", err)}
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return models.FinancialError{Type: models.NetworkError, Message: fmt.Sprintf("HTTP POST Error: %d - %s", resp.StatusCode, string(bodyBytes))}
	}

	if response != nil {
		if err := json.NewDecoder(resp.Body).Decode(response); err != nil {
			return models.FinancialError{Type: models.DeserializationError, Message: fmt.Sprintf("Failed to decode POST response: %v", err)}
		}
	}
	return models.FinancialError{Type: models.Success}
}

// TrustedCertificatesPEM should contain the PEM-encoded public keys of your backend server's
// certificates (or the CA that signs them).
// For strict TLS pinning, this would be the actual server certificate's public key hash.
// Example (replace with your actual backend's certificate):
const TrustedCertificatesPEM = `
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIQAfPqJ5m8jGkXQ74Q0/J4YzANBgkqhkiG9w0BAQsFADBL
... (Your actual PEM encoded certificate from your backend) ...
-----END CERTIFICATE-----
`
// You would obtain this from your Node.js backend server's certificate.
// For robust pinning, consider pinning the *Subject Public Key Info* (SPKI) hash.



package financomanager

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"sync"
	"time"

	"gilbert-finance-ai/internal/config"
	"gilbert-finance-ai/internal/models"
	"gilbert-finance-ai/internal/network"
	"gilbert-finance-ai/internal/security/antispy"
	"gilbert-finance-ai/internal/security/cryptoutil"

	"github.com/google/uuid"
)

// financomanager manages financial data and operations.
type FinancoManager struct {
	cfg                    *config.Config
	networkClient          *network.NetworkClient
	antiSpyModule          *antispy.AntiSpyModule
	currentSession         models.UserSession
	masterEncryptionKeyHex string // Derived from password at login, used for local data encryption
	mu                     sync.Mutex // Mutex for protecting in-memory data
	appData                models.AppData // In-memory representation of all local data
}

// NewFinancoManager creates and initializes a new FinancoManager.
func NewFinancoManager(cfg *config.Config, netClient *network.NetworkClient, aspy *antispy.AntiSpyModule) *FinancoManager {
	fm := &FinancoManager{
		cfg:           cfg,
		networkClient: netClient,
		antiSpyModule: aspy,
		appData: models.AppData{
			Accounts:     []models.FinancialAccount{},
			Transactions: []models.FinancialTransaction{},
			Earnings:     []models.Earning{},
		},
	}
	fm.loadSession() // Attempt to load previous session
	fm.loadAllData() // Attempt to load local data (will fail if no key)
	return fm
}

// IsAuthenticated checks if a user is currently authenticated.
func (fm *FinancoManager) IsAuthenticated() bool {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.currentSession.UserID != "" && time.Now().Before(fm.currentSession.ExpiryTime)
}

// GetCurrentSession returns the current user session (copy).
func (fm *FinancoManager) GetCurrentSession() models.UserSession {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.currentSession
}

// Authenticate handles user login.
func (fm *FinancoManager) Authenticate(username, password string) models.FinancialError {
	// In a real application, this would involve:
	// 1. Sending credentials (over HTTPS) to your Node.js backend.
	// 2. Backend verifies and returns a JWT token and possibly a user-specific encryption salt.
	// 3. Derive masterEncryptionKeyHex using `scrypt.Key` with the user's password and the unique salt
	//    from the backend or a securely generated local salt.
	// 4. Store the JWT token and masterEncryptionKeyHex in `currentSession` and persist it securely.

	// --- SIMPLIFIED DEMO AUTHENTICATION ---
	if username == "gilbert.algordo@example.com" && password == "SecurePa$$w0rd" {
		fm.mu.Lock()
		defer fm.mu.Unlock()

		fm.currentSession.UserID = "gilbert_algordo_user_id"
		fm.currentSession.JWTToken = "dummy_jwt_token_for_gilbert"
		fm.currentSession.ExpiryTime = time.Now().Add(time.Hour) // 1 hour expiry

		// For demo, derive key from password directly with a fixed salt. HIGHLY INSECURE FOR PROD.
		// In production, the salt would be unique per user and stored/retrieved securely.
		dummySalt := "deadbeef0123456789abcdef" // DO NOT USE FIXED SALT IN PROD
		derivedKey, err := cryptoutil.DeriveKeyFromPassword(password, dummySalt)
		if err != nil {
			log.Printf("Error deriving key: %v", err)
			return models.FinancialError{Type: models.SecurityAlert, Message: "Failed to derive encryption key."}
		}
		fm.masterEncryptionKeyHex = derivedKey
		fm.currentSession.MasterEncryptionKeyHex = derivedKey // Store this for persistence

		fm.saveSession()
		fm.loadAllData() // Load data with the newly derived key
		fm.antiSpyModule.LogSecurityEvent(fm.currentSession.UserID, "LoginSuccess", "User successfully logged in.")
		return models.FinancialError{Type: models.Success}
	} else {
		fm.antiSpyModule.LogSecurityEvent("unknown", "LoginFailure", "Invalid credentials attempted.")
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Invalid username or password."}
	}
}

// Logout clears the current session.
func (fm *FinancoManager) Logout() {
	fm.mu.Lock()
	defer fm.mu.Unlock()

	fm.antiSpyModule.LogSecurityEvent(fm.currentSession.UserID, "Logout", "User logged out.")

	// Securely wipe sensitive data from memory (best effort)
	cryptoutil.SecureWipe([]byte(fm.currentSession.JWTToken))
	cryptoutil.SecureWipe([]byte(fm.masterEncryptionKeyHex))

	fm.currentSession = models.UserSession{} // Reset session
	fm.masterEncryptionKeyHex = ""
	fm.appData = models.AppData{} // Clear in-memory data

	// Remove persistent session and data files
	os.Remove("session.bin.enc")
	os.Remove("data.bin.enc")

	log.Println("User logged out and session data cleared.")
}

// AddAccount adds a new financial account.
func (fm *FinancoManager) AddAccount(name, accountType string, initialBalance float64) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	newAccount := models.FinancialAccount{
		ID:        uuid.New().String(),
		UserID:    fm.currentSession.UserID,
		Name:      name,
		Type:      accountType,
		Balance:   initialBalance,
		CreatedAt: time.Now(),
	}
	fm.appData.Accounts = append(fm.appData.Accounts, newAccount)
	fm.saveAllData()
	return models.FinancialError{Type: models.Success}
}

// GetAccounts returns all financial accounts for the current user.
func (fm *FinancoManager) GetAccounts() []models.FinancialAccount {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.appData.Accounts // Return a copy for safety
}

// UpdateAccountBalance updates an account's balance by adding/subtracting amount.
func (fm *FinancoManager) UpdateAccountBalance(accountID string, amount float64) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	for i := range fm.appData.Accounts {
		if fm.appData.Accounts[i].ID == accountID {
			fm.appData.Accounts[i].Balance += amount
			fm.saveAllData()
			return models.FinancialError{Type: models.Success}
		}
	}
	return models.FinancialError{Type: models.DataNotFound, Message: "Account not found."}
}

// RecordTransaction records a new financial transaction.
func (fm *FinancoManager) RecordTransaction(accountID string, date time.Time, description string, amount float64, txnType, category string) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	newTxn := models.FinancialTransaction{
		ID:          uuid.New().String(),
		AccountID:   accountID,
		Date:        date,
		Description: description,
		Amount:      amount,
		Type:        txnType,
		Category:    category,
		CreatedAt:   time.Now(),
	}
	fm.appData.Transactions = append(fm.appData.Transactions, newTxn)

	// Update account balance
	balanceChange := amount
	if txnType == "expense" {
		balanceChange = -amount
	}
	// Temporarily release mutex for UpdateAccountBalance to avoid deadlock if it locks internally
	// In a real system, you'd carefully design your locking strategy (e.g., using a single global lock or more granular locks).
	fm.mu.Unlock()
	err := fm.UpdateAccountBalance(accountID, balanceChange)
	fm.mu.Lock() // Re-acquire mutex
	if err.Type != models.Success {
		log.Printf("Warning: Failed to update account balance for transaction %s: %v", newTxn.ID, err.Message)
		// Decide if transaction should still be recorded if balance update fails
	}
	fm.saveAllData()
	return models.FinancialError{Type: models.Success}
}

// GetTransactions returns all financial transactions for the current user.
func (fm *FinancoManager) GetTransactions() []models.FinancialTransaction {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	return fm.appData.Transactions // Return a copy for safety
}

// AddExpectedEarning adds a new expected earning.
func (fm *FinancoManager) AddExpectedEarning(source string, amount float64, dueDate time.Time) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	newEarning := models.Earning{
		ID:        uuid.New().String(),
		UserID:    fm.currentSession.UserID,
		Source:    source,
		Amount:    amount,
		DueDate:   dueDate,
		Status:    "expected",
		CreatedAt: time.Now(),
	}
	fm.appData.Earnings = append(fm.appData.Earnings, newEarning)
	fm.saveAllData()
	return models.FinancialError{Type: models.Success}
}

// MarkEarningCollected marks an expected earning as collected.
func (fm *FinancoManager) MarkEarningCollected(earningID string) models.FinancialError {
	if !fm.IsAuthenticated() {
		return models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	defer fm.mu.Unlock()

	for i := range fm.appData.Earnings {
		if fm.appData.Earnings[i].ID == earningID && fm.appData.Earnings[i].Status == "expected" {
			now := time.Now()
			fm.appData.Earnings[i].CollectedDate = &now
			fm.appData.Earnings[i].Status = "collected"
			// Optionally, record as income to an account
			fm.saveAllData()
			return models.FinancialError{Type: models.Success}
		}
	}
	return models.FinancialError{Type: models.DataNotFound, Message: "Expected earning not found or already collected."}
}

// GetExpectedEarnings returns a list of expected (uncollected) earnings.
func (fm *FinancoManager) GetExpectedEarnings() []models.Earning {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	var filtered []models.Earning
	for _, e := range fm.appData.Earnings {
		if e.Status == "expected" {
			filtered = append(filtered, e)
		}
	}
	return filtered
}

// GetTotalCollectedEarnings calculates the total amount of collected earnings.
func (fm *FinancoManager) GetTotalCollectedEarnings() float64 {
	fm.mu.Lock()
	defer fm.mu.Unlock()
	total := 0.0
	for _, e := range fm.appData.Earnings {
		if e.Status == "collected" {
			total += e.Amount
		}
	}
	return total
}

// GetFinancialAdvice fetches financial advice from the AI backend.
func (fm *FinancoManager) GetFinancialAdvice() ([]string, models.FinancialError) {
	if !fm.IsAuthenticated() {
		return nil, models.FinancialError{Type: models.AuthenticationFailed, Message: "Not authenticated."}
	}
	fm.mu.Lock()
	session := fm.currentSession // Get session details while holding mutex
	fm.mu.Unlock()

	// In a real scenario, you'd send relevant financial data (anonymized/encrypted)
	// to the AI backend for personalized advice.
	// For this demo, just fetch generic advice.
	type AIAdviceResponse struct {
		Advice []string `json:"advice"`
	}
	var adviceResponse AIAdviceResponse

	err := fm.networkClient.Get(fm.cfg.APIBaseURL+"/finance/advice", session.JWTToken, &adviceResponse)
	if err.Type != models.Success {
		return nil, err
	}
	return adviceResponse.Advice, models.FinancialError{Type: models.Success}
}

// --- Internal Persistence Methods (using encrypted JSON files for demo) ---

const (
	sessionFile = "session.bin.enc"
	dataFile    = "data.bin.enc"
)

// loadSession attempts to load the encrypted user session.
func (fm *FinancoManager) loadSession() {
	file, err := os.Open(sessionFile)
	if err != nil {
		if !os.IsNotExist(err) {
			log.Printf("Error opening session file: %v", err)
		}
		return // File doesn't exist or other error, session remains empty
	}
	defer file.Close()

	encryptedData, err := io.ReadAll(file)
	if err != nil {
		log.Printf("Error reading encrypted session data: %v", err)
		return
	}

	// For session decryption, we use the (insecure) hardcoded secret for this demo.
	// In production, JWTs might be managed directly by OS keystores or hardware.
	decryptedBytes, err := cryptoutil.Decrypt(string(encryptedData), cryptoutil.SHA256(fm.cfg.MasterEncryptionSecret)) // Using SHA256 of dummy secret as key
	if err != nil {
		log.Printf("Failed to decrypt session data (key mismatch?): %v", err)
		return
	}
	cryptoutil.SecureWipe(decryptedBytes) // Wipe plaintext after use

	var session models.UserSession
	if err := json.Unmarshal(decryptedBytes, &session); err != nil {
		log.Printf("Failed to unmarshal session JSON: %v", err)
		return
	}

	if time.Now().After(session.ExpiryTime) {
		log.Println("Loaded session expired. Clearing.")
		fm.currentSession = models.UserSession{}
		fm.masterEncryptionKeyHex = ""
		os.Remove(sessionFile) // Remove expired session file
		return
	}

	fm.currentSession = session
	fm.masterEncryptionKeyHex = session.MasterEncryptionKeyHex // Crucial: load the data encryption key
	log.Println("Session loaded successfully.")
}

// saveSession saves the current user session encrypted.
func (fm *FinancoManager) saveSession() {
	if fm.currentSession.UserID == "" {
		return // No session to save
	}

	sessionJSON, err := json.Marshal(fm.currentSession)
	if err != nil {
		log.Printf("Failed to marshal session JSON for saving: %v", err)
		return
	}

	// For session encryption, we use the (insecure) hardcoded secret for this demo.
	encryptedHex, err := cryptoutil.Encrypt(sessionJSON, cryptoutil.SHA256(fm.cfg.MasterEncryptionSecret)) // Using SHA256 of dummy secret as key
	if err != nil {
		log.Printf("Failed to encrypt session data: %v", err)
		return
	}

	if err := os.WriteFile(sessionFile, []byte(encryptedHex), 0600); err != nil { // Permissions: read/write for owner only
		log.Printf("Failed to write encrypted session file: %v", err)
	}
	log.Println("Session saved successfully.")
}

// loadAllData loads all encrypted financial data.
func (fm *FinancoManager) loadAllData() {
	if fm.masterEncryptionKeyHex == "" {
		log.Println("No master encryption key available. Cannot load local financial data.")
		return
	}

	file, err := os.Open(dataFile)
	if err != nil {
		if !os.IsNotExist(err) {
			log.Printf("Error opening data file: %v", err)
		}
		return // File doesn't exist or other error
	}
	defer file.Close()

	encryptedData, err := io.ReadAll(file)
	if err != nil {
		log.Printf("Error reading encrypted data: %v", err)
		return
	}

	decryptedBytes, err := cryptoutil.Decrypt(string(encryptedData), fm.masterEncryptionKeyHex)
	if err != nil {
		log.Printf("Failed to decrypt financial data (key mismatch? corruption?): %v", err)
		return
	}
	cryptoutil.SecureWipe(decryptedBytes) // Wipe plaintext after use

	var loadedAppData models.AppData
	if err := json.Unmarshal(decryptedBytes, &loadedAppData); err != nil {
		log.Printf("Failed to unmarshal financial data JSON: %v", err)
		return
	}

	fm.appData = loadedAppData // Update in-memory data
	log.Println("Financial data loaded and decrypted successfully.")
}

// saveAllData saves all financial data encrypted.
func (fm *FinancoManager) saveAllData() {
	if fm.masterEncryptionKeyHex == "" {
		log.Println("No master encryption key available. Cannot save local financial data.")
		return
	}

	appDataJSON, err := json.Marshal(fm.appData)
	if err != nil {
		log.Printf("Failed to marshal app data JSON for saving: %v", err)
		return
	}

	encryptedHex, err := cryptoutil.Encrypt(appDataJSON, fm.masterEncryptionKeyHex)
	if err != nil {
		log.Printf("Failed to encrypt app data: %v", err)
		return
	}

	if err := os.WriteFile(dataFile, []byte(encryptedHex), 0600); err != nil {
		log.Printf("Failed to write encrypted data file: %v", err)
	}
	log.Println("Financial data saved and encrypted successfully.")
}



package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"gilbert-finance-ai/internal/config"
	"gilbert-finance-ai/internal/financomanager"
	"gilbert-finance-ai/internal/models"
	"gilbert-finance-ai/internal/network"
	"gilbert-finance-ai/internal/security/antispy"
	"gilbert-finance-ai/internal/security/cryptoutil" // For initial binary hash check

	"github.com/google/uuid"
)

// EXPECTED_BINARY_HASH is a placeholder. In a real app, this would be
// calculated during the build process and securely embedded.
// Example: go build -ldflags "-X main.BinaryHash=$(sha256sum your_binary | awk '{print $1}')"
// And then refer to it as `main.BinaryHash` if using `-X` flag.
const EXPECTED_BINARY_HASH = "REPLACE_THIS_WITH_YOUR_ACTUAL_BINARY_SHA256_HASH" // Example: "a1b2c3d4e5f6..."

var appConfig *config.Config
var networkClient *network.NetworkClient
var antiSpyModule *antispy.AntiSpyModule
var financeManager *financomanager.FinancoManager

func init() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	appConfig = config.LoadConfig()

	// Initialize security modules
	antiSpyModule = antispy.NewAntiSpyModule(appConfig)

	// Initialize network client with TLS pinning
	var err error
	networkClient, err = network.NewNetworkClient(network.TrustedCertificatesPEM)
	if err != nil {
		log.Fatalf("Failed to initialize network client: %v", err)
	}

	// Initialize financial manager
	financeManager = financomanager.NewFinancoManager(appConfig, networkClient, antiSpyModule)
}

func getLineInput(prompt string) string {
	fmt.Print(prompt)
	reader := bufio.NewReader(os.Stdin)
	input, _ := reader.ReadString('\n')
	return strings.TrimSpace(input)
}

func getDoubleInput(prompt string) float64 {
	for {
		input := getLineInput(prompt)
		value, err := strconv.ParseFloat(input, 64)
		if err != nil {
			fmt.Println("Invalid input. Please enter a number.")
			continue
		}
		return value
	}
}

func printError(err models.FinancialError) {
	if err.Type != models.Success {
		fmt.Fprintf(os.Stderr, "Error: %s\n", err.Message)
	}
}

func displayMainMenu() {
	fmt.Println("\n--- Main Menu ---")
	fmt.Println("1. Manage Accounts")
	fmt.Println("2. Record Transaction")
	fmt.Println("3. Earnings Collector")
	fmt.Println("4. Get Financial Advice (AI)")
	fmt.Println("5. View Transactions")
	fmt.Println("6. Logout")
	fmt.Println("7. Exit")
	fmt.Print("Enter your choice: ")
}

func displayAccountMenu() {
	fmt.Println("\n--- Account Management ---")
	fmt.Println("1. List Accounts")
	fmt.Println("2. Add New Account")
	fmt.Println("3. Back to Main Menu")
	fmt.Print("Enter your choice: ")
}

func displayEarningsMenu() {
	fmt.Println("\n--- Earnings Collector ---")
	fmt.Println("1. List Expected Earnings")
	fmt.Println("2. Add Expected Earning")
	fmt.Println("3. Mark Earning Collected")
	fmt.Println("4. View Total Collected")
	fmt.Println("5. Back to Main Menu")
	fmt.Print("Enter your choice: ")
}

func main() {
	// Initial security checks on startup
	if antiSpyModule.IsDebuggerAttached() {
		log.Println("CRITICAL SECURITY ALERT: DEBUGGER DETECTED! Terminating application.")
		antiSpyModule.LogSecurityEvent("system", "DebuggerDetectedCritical", "Application terminated due to debugger detection at launch.")
		os.Exit(1) // Exit immediately
	}

	if !antiSpyModule.CheckBinaryIntegrity(EXPECTED_BINARY_HASH) {
		log.Println("CRITICAL SECURITY ALERT: BINARY TAMPERING DETECTED! Terminating application.")
		antiSpyModule.LogSecurityEvent("system", "BinaryTamperedCritical", "Application terminated due to binary integrity check failure at launch.")
		os.Exit(1) // Exit immediately
	}
	fmt.Println("Initial security checks passed.")

	if !financeManager.IsAuthenticated() {
		fmt.Println("Please log in.")
		username := getLineInput("Enter username (email): ")
		password := getLineInput("Enter password: ")
		authErr := financeManager.Authenticate(username, password)
		if authErr.Type != models.Success {
			printError(authErr)
			fmt.Println("Authentication failed. Exiting.")
			os.Exit(1)
		}
		fmt.Println("Login successful! Welcome, Gilbert Algordo.")
	} else {
		fmt.Println("Already logged in. Welcome back, Gilbert Algordo.")
	}

	for {
		displayMainMenu()
		choiceStr := getLineInput("")
		choice, err := strconv.Atoi(choiceStr)
		if err != nil {
			fmt.Println("Invalid input. Please enter a number.")
			continue
		}

		switch choice {
		case 1: // Manage Accounts
			for {
				displayAccountMenu()
				accChoiceStr := getLineInput("")
				accChoice, err := strconv.Atoi(accChoiceStr)
				if err != nil {
					fmt.Println("Invalid input. Please enter a number.")
					continue
				}

				switch accChoice {
				case 1: // List Accounts
					fmt.Println("\n--- Your Accounts ---")
					accounts := financeManager.GetAccounts()
					if len(accounts) == 0 {
						fmt.Println("No accounts found.")
					} else {
						for _, acc := range accounts {
							fmt.Printf("ID: %s, Name: %s, Type: %s, Balance: $%.2f\n",
								acc.ID, acc.Name, acc.Type, acc.Balance)
						}
					}
				case 2: // Add New Account
					name := getLineInput("Enter account name: ")
					accountType := getLineInput("Enter account type (e.g., checking, savings, credit_card): ")
					initialBalance := getDoubleInput("Enter initial balance: $")
					printError(financeManager.AddAccount(name, accountType, initialBalance))
					fmt.Println("Account added.")
				case 3: // Back
					break
				default:
					fmt.Println("Invalid choice. Please try again.")
				}
				if accChoice == 3 {
					break
				}
			}
		case 2: // Record Transaction
			accountID := getLineInput("Enter account ID for transaction: ")
			description := getLineInput("Enter transaction description: ")
			amount := getDoubleInput("Enter amount: $")
			txnType := getLineInput("Enter transaction type (income/expense): ")
			category := getLineInput("Enter category (e.g., Food, Salary, Rent): ")
			printError(financeManager.RecordTransaction(accountID, time.Now(), description, amount, txnType, category))
			fmt.Println("Transaction recorded.")
		case 3: // Earnings Collector
			for {
				displayEarningsMenu()
				earnChoiceStr := getLineInput("")
				earnChoice, err := strconv.Atoi(earnChoiceStr)
				if err != nil {
					fmt.Println("Invalid input. Please enter a number.")
					continue
				}

				switch earnChoice {
				case 1: // List Expected Earnings
					fmt.Println("\n--- Pending Expected Earnings ---")
					expected := financeManager.GetExpectedEarnings()
					if len(expected) == 0 {
						fmt.Println("No pending expected earnings.")
					} else {
						for _, ear := range expected {
							fmt.Printf("ID: %s, Source: %s, Amount: $%.2f, Due: %s\n",
								ear.ID, ear.Source, ear.Amount, ear.DueDate.Format("2006-01-02"))
						}
					}
				case 2: // Add Expected Earning
					source := getLineInput("Enter earning source: ")
					amount := getDoubleInput("Enter expected amount: $")
					// For simplicity, due date is current time. In real app, parse date input.
					printError(financeManager.AddExpectedEarning(source, amount, time.Now()))
					fmt.Println("Expected earning added.")
				case 3: // Mark Earning Collected
					earningID := getLineInput("Enter ID of earning to mark as collected: ")
					printError(financeManager.MarkEarningCollected(earningID))
					fmt.Println("Earning marked as collected.")
				case 4: // View Total Collected
					totalCollected := financeManager.GetTotalCollectedEarnings()
					fmt.Printf("\nTotal Collected Earnings: $%.2f\n", totalCollected)
				case 5: // Back
					break
				default:
					fmt.Println("Invalid choice. Please try again.")
				}
				if earnChoice == 5 {
					break
				}
			}
		case 4: // Get Financial Advice (AI)
			fmt.Println("\n--- Financial AI Assistant ---")
			adviceList, aiErr := financeManager.GetFinancialAdvice()
			if aiErr.Type == models.Success {
				if len(adviceList) == 0 {
					fmt.Println("No specific advice available at this time.")
				} else {
					for _, advice := range adviceList {
						fmt.Printf("- %s\n", advice)
					}
				}
			} else {
				printError(aiErr)
			}
		case 5: // View Transactions
			fmt.Println("\n--- Your Transactions ---")
			transactions := financeManager.GetTransactions()
			if len(transactions) == 0 {
				fmt.Println("No transactions found.")
			} else {
				for _, txn := range transactions {
					fmt.Printf("ID: %s, Account: %s, Date: %s, Desc: %s, Amount: $%.2f, Type: %s, Category: %s\n",
						txn.ID, txn.AccountID, txn.Date.Format("2006-01-02"), txn.Description, txn.Amount, txn.Type, txn.Category)
				}
			}
		case 6: // Logout
			financeManager.Logout()
			fmt.Println("Logged out. Please restart the application to log in again.")
			return // Exit after logout
		case 7: // Exit
			fmt.Println("Exiting application. Goodbye, Gilbert Algordo!")
			return
		default:
			fmt.Println("Invalid choice. Please try again.")
		}
	}
}

// SHA256 returns the SHA256 hash of a string. Used for dummy key in config/cryptoutil.
// In real use, this would be a secure KDF like scrypt or Argon2.
func (c *CryptoUtil) SHA256(data string) string {
	hasher := sha256.New()
	hasher.Write([]byte(data))
	return hex.EncodeToString(hasher.Sum(nil))
}

// We need to implement SHA256 in cryptoutil.go for the dummy master key logic.
// Add this method to internal/security/cryptoutil/cryptoutil.go
func SHA256(data string) string {
	hasher := sha256.New()
	hasher.Write([]byte(data))
	return hex.EncodeToString(hasher.Sum(nil))
}



cd gilbert-finance-ai
go mod tidy


# Step 1: Build without the hash first (temporary)
go build -o gilbert-finance-ai-temp ./cmd

# Step 2: Calculate SHA256 hash of the temporary binary
# For Linux/macOS:
sha256sum gilbert-finance-ai-temp

# For Windows (PowerShell):
Get-FileHash -Algorithm SHA256 .\gilbert-finance-ai-temp.exe | Select-Object -ExpandProperty Hash




go build -o gilbert-finance-ai ./cmd



./gilbert-finance-ai





