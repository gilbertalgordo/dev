import pandas as pd
import numpy as np
from datetime import datetime

class ActiveEBITDA_AI:
    """
    An AI-driven financial agent designed with Kaizen principles 
    for real-time margin optimization.
    """
    def __init__(self, ticker_name):
        self.ticker = ticker_name
        self.history = []
        
    def calculate_base_ebitda(self, net_income, interest, taxes, depr, amort):
        """Standard EBITDA calculation: $EBITDA = NI + I + T + D + A$"""
        return net_income + interest + taxes + depr + amort

    def active_kaizen_adjustment(self, op_expenses_df):
        """
        AI Logic: Scans operational expenses for 'Active' add-backs 
        (one-time legal fees, R&D spikes, or inefficiencies).
        """
        # Simulated AI logic: Identify expenses 2 standard deviations above mean
        threshold = op_expenses_df['amount'].mean() + (2 * op_expenses_df['amount'].std())
        extraordinary_items = op_expenses_df[op_expenses_df['amount'] > threshold]
        
        adjustment_total = extraordinary_items['amount'].sum()
        return adjustment_total, extraordinary_items

    def generate_report(self, financials, expenses):
        # 1. Base EBITDA
        base_ebitda = self.calculate_base_ebitda(
            financials['net_income'], financials['interest'], 
            financials['taxes'], financials['depr'], financials['amort']
        )
        
        # 2. Active Adjustment (The 'AI' Layer)
        adj_value, items = self.active_kaizen_adjustment(expenses)
        active_ebitda = base_ebitda + adj_value
        
        # 3. Kaizen Metric: EBITDA Margin
        margin = (active_ebitda / financials['revenue']) * 100
        
        return {
            "Timestamp": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "Base_EBITDA": f"${base_ebitda:,.2f}",
            "Active_Adjustments": f"${adj_value:,.2f}",
            "Adjusted_EBITDA": f"${active_ebitda:,.2f}",
            "Active_Margin": f"{margin:.2f}%",
            "Anomalies_Found": items['description'].tolist()
        }

# --- Execution Example ---
data = {
    'revenue': 1000000, 'net_income': 150000, 
    'interest': 20000, 'taxes': 30000, 'depr': 15000, 'amort': 5000
}

# Real-time expense stream for AI analysis
expenses_log = pd.DataFrame([
    {'description': 'Cloud Servers', 'amount': 5000},
    {'description': 'One-time Legal Settlement', 'amount': 45000}, # Anomaly
    {'description': 'Payroll', 'amount': 60000},
    {'description': 'Urgent Server Repair', 'amount': 12000}
])

ai_agent = ActiveEBITDA_AI("GA_CORP_DEV")
result = ai_agent.generate_report(data, expenses_log)

print(f"--- ACTIVE EBITDA AI HUD ---")
for k, v in result.items():
    print(f"{k}: {v}")




import asyncio
import pandas as pd
from typing import List, Dict
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FinancialEvent:
    source: str
    amount: float
    category: str
    is_recurring: bool
    timestamp: datetime = datetime.now()

class ActiveEBITDAEngine:
    """
    Advanced AI Engine using Archangel-inspired logic:
    - Michael: Vigilance (Anomaly Detection)
    - Jophiel: Beauty (Optimization of Ledger Structure)
    """
    def __init__(self, target_margin: float = 0.25):
        self.target_margin = target_margin
        self.active_add_backs = []
        self.revenue_stream = 0.0
        self.opex_stream = 0.0

    async def archangel_vigilance_monitor(self, event: FinancialEvent):
        """Michael Logic: Detects and classifies anomalies for Active Add-Backs."""
        # Active AI Reasoning: If a cost is non-recurring and > 15% of monthly avg, 
        # it is flagged as an EBITDA Add-back automatically.
        if not event.is_recurring and event.amount > (self.opex_stream * 0.15 if self.opex_stream > 0 else 0):
            self.active_add_backs.append(event)
            return f"ðŸ›¡ï¸ Michael: Flagged {event.category} as Active Add-back: ${event.amount:,.2f}"
        return None

    async def calculate_live_metrics(self, net_income: float, tax_rate: float, interest: float):
        """
        Calculates the 'Active' EBITDA where adjustments are handled in real-time.
        Formula: $EBITDA_{Active} = NI + I + T + \sum(Active\_AddBacks)$
        """
        taxes = net_income * tax_rate
        depreciation_amortization = self.opex_stream * 0.05 # Predictive DA
        
        add_back_total = sum(item.amount for item in self.active_add_backs)
        
        ebitda = net_income + interest + taxes + depreciation_amortization + add_back_total
        margin = ebitda / self.revenue_stream if self.revenue_stream > 0 else 0
        
        return {
            "ebitda": ebitda,
            "margin": margin,
            "status": "KAISEN_OPTIMIZED" if margin >= self.target_margin else "INTERVENTION_REQ"
        }

async def developer_hud_stream():
    """Simulates a superfast Kaizen stream of financial events."""
    engine = ActiveEBITDAEngine(target_margin=0.30)
    engine.revenue_stream = 5000000  # $5M Base
    
    events = [
        FinancialEvent("Stripe", 12000, "Server Maintenance", True),
        FinancialEvent("Legal", 85000, "Patent Defense", False), # The Anomaly
        FinancialEvent("Marketing", 20000, "Ad Spend", True),
    ]

    print(f"--- ACTIVE EBITDA AI: INITIALIZING HUD ---")
    for event in events:
        engine.opex_stream += event.amount
        alert = await engine.archangel_vigilance_monitor(event)
        if alert: print(alert)

    # Final Pulse Check
    metrics = await engine.calculate_live_metrics(net_income=1200000, tax_rate=0.21, interest=45000)
    
    print("\n--- KAIZEN ANALYTICS ---")
    print(f"Active EBITDA: ${metrics['ebitda']:,.2f}")
    print(f"Real-time Margin: {metrics['margin']*100:.2f}%")
    print(f"System State: {metrics['status']}")

if __name__ == "__main__":
    asyncio.run(developer_hud_stream())
