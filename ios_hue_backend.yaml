// MARK: - Main iOS App

import SwiftUI
import CoreBluetooth // For hypothetical backcover interaction
import HueSDK // Assuming you've integrated the Philips Hue SDK

@main
struct HueLightApp: App {
    @StateObject var hueController = HueLightController()
    @StateObject var backcoverController = BackcoverLEDController() // For hypothetical backcover

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(hueController)
                .environmentObject(backcoverController)
                // Add gesture recognizers here or in subviews
        }
    }
}

// MARK: - Hue Light Controller (Handles Philips Hue API)

class HueLightController: ObservableObject {
    @Published var lights: [HueLight] = [] // Custom struct for your lights
    @Published var selectedLight: HueLight?

    // Initialize Hue SDK, discover bridges, authenticate, fetch lights
    init() {
        // Placeholder: Implement Hue SDK initialization and discovery
        // Example: PHHueSDK.sharedInstance().startUp()
        // Example: PHBridgeSearching.sharedInstance().startSearch(for: .upnp)
    }

    func turnOn(_ light: HueLight) {
        // Use Hue SDK to turn on light
        // Example: PHBridgeAPI.sharedInstance().updateLightState(...)
    }

    func setBrightness(_ light: HueLight, brightness: CGFloat) {
        // Use Hue SDK to set brightness
    }

    func setHue(_ light: HueLight, hue: CGFloat) {
        // Use Hue SDK to set hue
    }

    // ... other Hue control methods
}

// MARK: - Content View (Main UI)

struct ContentView: View {
    @EnvironmentObject var hueController: HueLightController
    @EnvironmentObject var backcoverController: BackcoverLEDController // For hypothetical backcover

    // State for "tap to surface" animation/interaction
    @State private var showingSurfaceUI = false
    @State private var offset: CGSize = .zero // For drag gestures

    var body: some View {
        ZStack {
            // Background / Main App Content
            VStack {
                Text("Your Main App Content")
                Button("Discover Hue Lights") {
                    // Trigger Hue discovery
                }
                List(hueController.lights) { light in
                    Text(light.name)
                        .onTapGesture {
                            hueController.selectedLight = light
                            // Maybe show a detail view or control panel
                        }
                }
            }

            // "Tap to Surface" Overlay UI
            if showingSurfaceUI {
                VStack {
                    Text("Surface Controls")
                        .font(.largeTitle)
                    Slider(value: Binding(
                        get: { hueController.selectedLight?.brightness ?? 0 },
                        set: { newValue in
                            if let light = hueController.selectedLight {
                                hueController.setBrightness(light, brightness: newValue)
                            }
                        }
                    ), in: 0...1)
                    .padding()
                    Button("Close Surface") {
                        withAnimation {
                            showingSurfaceUI = false
                        }
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(Color.blue.opacity(0.8))
                .cornerRadius(20)
                .transition(.scale) // Or other custom transitions
                .offset(offset) // Apply drag offset
                .gesture(
                    DragGesture()
                        .onChanged { gesture in
                            self.offset = gesture.translation
                        }
                        .onEnded { _ in
                            // Optional: Animate back to original position or dismiss
                            withAnimation {
                                self.offset = .zero
                            }
                        }
                )
            }
        }
        .onTapGesture {
            // This is a simple tap to show/hide the surface.
            // You'd likely want more sophisticated gesture logic.
            withAnimation {
                showingSurfaceUI.toggle()
            }
        }
        .onChange(of: hueController.selectedLight) { light in
            // When a light is selected, potentially send commands to backcover LED
            if let light = light {
                backcoverController.updateBackcoverLED(with: light.hueColor)
            }
        }
    }
}

// MARK: - Backcover LED Controller (Hypothetical CoreBluetooth)

class BackcoverLEDController: NSObject, ObservableObject, CBCentralManagerDelegate, CBPeripheralDelegate {
    @Published var isConnectedToBackcover: Bool = false
    private var centralManager: CBCentralManager!
    private var backcoverPeripheral: CBPeripheral?

    // Define UUIDs for your custom BLE service and characteristic
    let backcoverServiceUUID = CBUUID(string: "YOUR_SERVICE_UUID")
    let backcoverCharacteristicUUID = CBUUID(string: "YOUR_CHARACTERISTIC_UUID")

    override init() {
        super.init()
        centralManager = CBCentralManager(delegate: self, queue: nil)
    }

    // CBCentralManagerDelegate methods
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        if central.state == .poweredOn {
            centralManager.scanForPeripherals(withServices: [backcoverServiceUUID], options: nil)
        } else {
            // Handle other states (e.g., Bluetooth not available)
        }
    }

    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
        // Discovered your backcover accessory
        backcoverPeripheral = peripheral
        backcoverPeripheral?.delegate = self
        centralManager.stopScan()
        centralManager.connect(peripheral, options: nil)
    }

    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        isConnectedToBackcover = true
        peripheral.discoverServices([backcoverServiceUUID])
    }

    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        isConnectedToBackcover = false
        // Reconnect or handle disconnection
    }

    // CBPeripheralDelegate methods
    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        guard let services = peripheral.services else { return }
        for service in services where service.uuid == backcoverServiceUUID {
            peripheral.discoverCharacteristics([backcoverCharacteristicUUID], for: service)
        }
    }

    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        guard let characteristics = service.characteristics else { return }
        for characteristic in characteristics where characteristic.uuid == backcoverCharacteristicUUID {
            // You can now write data to this characteristic
            print("Found backcover LED characteristic!")
        }
    }

    // Function to send data to the backcover LED
    func updateBackcoverLED(with color: Color) {
        guard let peripheral = backcoverPeripheral,
              let service = peripheral.services?.first(where: { $0.uuid == backcoverServiceUUID }),
              let characteristic = service.characteristics?.first(where: { $0.uuid == backcoverCharacteristicUUID }) else {
            print("Backcover LED not ready.")
            return
        }

        // Convert SwiftUI Color to a format your backcover firmware understands (e.g., RGB bytes)
        let uiColor = UIColor(color)
        var r: CGFloat = 0, g: CGFloat = 0, b: CGFloat = 0, a: CGFloat = 0
        uiColor.getRed(&r, green: &g, blue: &b, alpha: &a)

        let rgbData = Data([UInt8(r * 255), UInt8(g * 255), UInt8(b * 255)])
        peripheral.writeValue(rgbData, for: characteristic, type: .withResponse) // Or .withoutResponse
    }
}

// MARK: - Widget Extension (WidgetKit)

// In your separate Widget Extension target:

import WidgetKit
import SwiftUI

struct HueLightWidgetEntry: TimelineEntry {
    let date: Date
    let lightStatus: String // Example: "Living Room: On (80%)"
    let lightColor: Color // For a representative color in the widget
}

struct HueLightWidgetProvider: TimelineProvider {
    func placeholder(in context: Context) -> HueLightWidgetEntry {
        HueLightWidgetEntry(date: Date(), lightStatus: "Loading Hue...", lightColor: .gray)
    }

    func getSnapshot(in context: Context, completion: @escaping (HueLightWidgetEntry) -> Void) {
        // Fetch current light status from shared data (e.g., App Group UserDefaults)
        let entry = HueLightWidgetEntry(date: Date(), lightStatus: "Living Room: On", lightColor: .yellow)
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<HueLightWidgetEntry>) -> Void) {
        var entries: [HueLightWidgetEntry] = []

        // Generate a timeline with updates (e.g., every 15 minutes, or based on significant changes)
        let currentDate = Date()
        for hourOffset in 0 ..< 5 {
            let entryDate = Calendar.current.date(byAdding: .minute, value: hourOffset * 15, to: currentDate)!
            // In a real app, you'd fetch real-time light status here or from shared container
            let status = "Light Status \(hourOffset)"
            let color: Color = (hourOffset % 2 == 0) ? .orange : .purple
            let entry = HueLightWidgetEntry(date: entryDate, lightStatus: status, lightColor: color)
            entries.append(entry)
        }

        let timeline = Timeline(entries: entries, policy: .atEnd) // Or .after(someDate)
        completion(timeline)
    }
}

struct HueLightWidgetView: View {
    var entry: HueLightWidgetProvider.Entry

    var body: some View {
        VStack(alignment: .leading) {
            Text("Hue Light Status")
                .font(.headline)
            Text(entry.lightStatus)
                .font(.subheadline)
            Circle()
                .fill(entry.lightColor)
                .frame(width: 30, height: 30)
        }
        .containerBackground(for: .widget) {
            Color.clear
        }
    }
}

@main
struct HueLightWidget: Widget {
    let kind: String = "HueLightWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: HueLightWidgetProvider()) { entry in
            HueLightWidgetView(entry: entry)
        }
        .configurationDisplayName("Hue Light Control")
        .description("View and control your Hue lights.")
        .supportedFamilies([.systemSmall, .systemMedium]) // Or other sizes
    }
}



mkdir hue-led-backend
cd hue-led-backend
npm init -y
npm install express ws node-hue-api # noble bleno (if using local BLE gateway)


// server.js

const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const { HueApi, lightState, nupnpSearch } = require('node-hue-api').v3; // Using v3 for modern API

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

const PORT = process.env.PORT || 3000;

// --- Philips Hue Configuration (Replace with your bridge IP and username) ---
const HUE_BRIDGE_IP = process.env.HUE_BRIDGE_IP || 'YOUR_HUE_BRIDGE_IP'; // e.g., '192.168.1.100'
const HUE_USERNAME = process.env.HUE_USERNAME || 'YOUR_HUE_USERNAME'; // Generated after first connection
let hueApi;

// --- Hypothetical Backcover LED (via WebSocket or a local BLE gateway) ---
// If backcover is controlled via a local Node.js BLE gateway, this server would send commands to it.
// For simplicity, we'll assume the main Node.js server acts as the "BLE gateway" if you ran it on a Pi.
// If not, the iOS app might directly connect to the backcover via BLE, or the main server proxies.

// Example: Using 'noble' for BLE Central mode (requires Linux/macOS with Bluetooth)
// If you're running this Node.js server on a Raspberry Pi connected to your backcover LED:
// const noble = require('noble'); // npm install noble
const BACKCOVER_LED_SERVICE_UUID = 'YOUR_CUSTOM_SERVICE_UUID'; // e.g., '180A' or a custom UUID
const BACKCOVER_LED_CHARACTERISTIC_UUID = 'YOUR_CUSTOM_CHARACTERISTIC_UUID'; // e.g., '2A57' or a custom UUID
let backcoverPeripheral;
let backcoverCharacteristic;

// --- Middleware ---
app.use(express.json()); // For parsing JSON request bodies

// --- Hue Initialization ---
async function initializeHue() {
    try {
        if (!HUE_BRIDGE_IP) {
            console.warn('HUE_BRIDGE_IP not set. Attempting NUPNP search...');
            const searchResults = await nupnpSearch();
            if (searchResults.length > 0) {
                HUE_BRIDGE_IP = searchResults[0].ipaddress;
                console.log(`Discovered Hue Bridge at: ${HUE_BRIDGE_IP}`);
            } else {
                console.error('No Hue Bridges found via NUPNP search. Please set HUE_BRIDGE_IP manually.');
                return;
            }
        }

        hueApi = new HueApi(HUE_BRIDGE_IP, HUE_USERNAME);
        const config = await hueApi.configuration.get();
        console.log(`Connected to Hue Bridge: ${config.name}`);
        // Optionally, register a new user if HUE_USERNAME is not set (requires pressing bridge button)
        // const user = await hueApi.users.createUser(HUE_BRIDGE_IP, 'your-app-name');
        // console.log('New Hue User created (press bridge button):', user.username);
        // HUE_USERNAME = user.username; // Save this username for future use
    } catch (error) {
        console.error('Failed to initialize Hue API:', error.message);
        console.warn('Ensure HUE_BRIDGE_IP and HUE_USERNAME are correct. If first time, press the bridge button for a new user.');
    }
}

// --- Hypothetical BLE Initialization for Backcover LED (if this server acts as gateway) ---
/*
function initializeBLE() {
    noble.on('stateChange', async (state) => {
        if (state === 'poweredOn') {
            console.log('BLE adapter powered on, starting scan...');
            noble.startScanning([BACKCOVER_LED_SERVICE_UUID], false);
        } else {
            console.log('BLE adapter state:', state);
            noble.stopScanning();
        }
    });

    noble.on('discover', (peripheral) => {
        console.log('Discovered BLE peripheral:', peripheral.advertisement.localName, peripheral.id);
        if (peripheral.advertisement.serviceUuids.includes(BACKCOVER_LED_SERVICE_UUID.toLowerCase())) {
            noble.stopScanning();
            backcoverPeripheral = peripheral;
            console.log('Connecting to backcover LED peripheral:', peripheral.id);
            peripheral.connect();
        }
    });

    noble.on('connect', (peripheralId) => {
        console.log('Connected to backcover LED:', peripheralId);
        backcoverPeripheral.discoverServices([BACKCOVER_LED_SERVICE_UUID], (error, services) => {
            if (error) { console.error('Error discovering services:', error); return; }
            const backcoverService = services.find(s => s.uuid === BACKCOVER_LED_SERVICE_UUID.toLowerCase());
            if (backcoverService) {
                backcoverService.discoverCharacteristics([BACKCOVER_LED_CHARACTERISTIC_UUID], (error, characteristics) => {
                    if (error) { console.error('Error discovering characteristics:', error); return; }
                    backcoverCharacteristic = characteristics.find(c => c.uuid === BACKCOVER_LED_CHARACTERISTIC_UUID.toLowerCase());
                    if (backcoverCharacteristic) {
                        console.log('Backcover LED characteristic found. Ready to send commands.');
                        // You can also subscribe for notifications if the backcover sends data back
                        // backcoverCharacteristic.subscribe(() => console.log('Subscribed to backcover notifications'));
                        // backcoverCharacteristic.on('data', (data, isNotification) => console.log('Backcover data:', data));
                    } else {
                        console.error('Backcover LED characteristic not found.');
                    }
                });
            } else {
                console.error('Backcover LED service not found.');
            }
        });
    });

    noble.on('disconnect', (peripheralId) => {
        console.log('Disconnected from backcover LED:', peripheralId);
        backcoverPeripheral = null;
        backcoverCharacteristic = null;
        console.log('Attempting to re-scan for backcover LED...');
        noble.startScanning([BACKCOVER_LED_SERVICE_UUID], false);
    });
}
*/

// --- WebSocket Server ---
wss.on('connection', ws => {
    console.log('Client connected to WebSocket.');

    ws.on('message', async message => {
        console.log('Received message from client:', message.toString());
        try {
            const data = JSON.parse(message.toString());

            switch (data.type) {
                case 'getLights':
                    if (hueApi) {
                        const lights = await hueApi.lights.getAll();
                        ws.send(JSON.stringify({ type: 'lightsList', lights: lights }));
                    } else {
                        ws.send(JSON.stringify({ type: 'error', message: 'Hue API not initialized.' }));
                    }
                    break;
                case 'setLightState':
                    if (hueApi && data.lightId && data.state) {
                        const state = new lightState.create().on(data.state.on);
                        if (data.state.brightness !== undefined) state.brightness(Math.round(data.state.brightness * 254));
                        if (data.state.hue !== undefined) state.hue(Math.round(data.state.hue * 65535));
                        if (data.state.saturation !== undefined) state.saturation(Math.round(data.state.saturation * 254));

                        await hueApi.lights.setLightState(data.lightId, state);
                        ws.send(JSON.stringify({ type: 'lightStateUpdated', lightId: data.lightId, newState: data.state }));
                        console.log(`Light ${data.lightId} state updated.`);
                    }
                    break;
                case 'updateBackcoverLED':
                    // This command would come from iOS app to update backcover
                    if (backcoverCharacteristic /* && noble initialized */) {
                        const { r, g, b } = data.color; // Assuming color is sent as {r, g, b} 0-1
                        const rgbBytes = Buffer.from([Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)]);
                        // await backcoverCharacteristic.write(rgbBytes, false); // For write without response
                        console.log(`Sent color to backcover LED: R:${r}, G:${g}, B:${b}`);
                        ws.send(JSON.stringify({ type: 'backcoverLEDUpdated', color: data.color }));
                    } else {
                        ws.send(JSON.stringify({ type: 'error', message: 'Backcover LED gateway not connected.' }));
                    }
                    break;
                // Add more cases for specific gestures if your "tap to surface" sends specific triggers
                // e.g., 'tapToSurfaceTriggered', 'swipeToChangeScene'
                case 'tapToSurfaceTriggered':
                    // Logic for tap to surface, maybe adjust a specific light or scene
                    console.log('Tap to surface triggered on iOS app.');
                    // Example: Cycle a specific light color
                    if (hueApi) {
                         const firstLightId = 1; // Assuming a light with ID 1
                         const currentColor = await hueApi.lights.getLightState(firstLightId);
                         const newState = new lightState.create();
                         // Simple color cycle example
                         if (currentColor.on) {
                             if (currentColor.hue < 20000) { // If it's warm, make it cool
                                 newState.hue(45000); // Blueish
                             } else { // If it's cool, make it warm
                                 newState.hue(10000); // Redish
                             }
                             await hueApi.lights.setLightState(firstLightId, newState);
                             ws.send(JSON.stringify({ type: 'lightStateUpdated', lightId: firstLightId, newState: newState.getLightState() }));
                         }
                    }
                    break;
                default:
                    console.warn('Unknown message type:', data.type);
            }
        } catch (error) {
            console.error('Error processing WebSocket message:', error);
            ws.send(JSON.stringify({ type: 'error', message: `Server error: ${error.message}` }));
        }
    });

    ws.on('close', () => {
        console.log('Client disconnected from WebSocket.');
    });

    ws.on('error', error => {
        console.error('WebSocket error:', error);
    });
});

// --- HTTP API Endpoints (for less frequent or initial setup tasks) ---

// Get all lights
app.get('/api/lights', async (req, res) => {
    if (!hueApi) {
        return res.status(500).json({ error: 'Hue API not initialized.' });
    }
    try {
        const lights = await hueApi.lights.getAll();
        res.json(lights);
    } catch (error) {
        console.error('Error getting lights:', error);
        res.status(500).json({ error: 'Failed to retrieve lights.' });
    }
});

// Set state of a specific light
app.post('/api/lights/:id/state', async (req, res) => {
    if (!hueApi) {
        return res.status(500).json({ error: 'Hue API not initialized.' });
    }
    const lightId = req.params.id;
    const { on, brightness, hue, saturation } = req.body;

    try {
        const state = new lightState.create().on(on);
        if (brightness !== undefined) state.brightness(Math.round(brightness * 254)); // Hue brightness is 0-254
        if (hue !== undefined) state.hue(Math.round(hue * 65535)); // Hue hue is 0-65535
        if (saturation !== undefined) state.saturation(Math.round(saturation * 254)); // Hue saturation is 0-254

        await hueApi.lights.setLightState(lightId, state);
        res.json({ message: `Light ${lightId} state updated.` });

        // Broadcast update to all connected WebSocket clients
        wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(JSON.stringify({ type: 'lightStateUpdated', lightId: lightId, newState: req.body }));
            }
        });

    } catch (error) {
        console.error(`Error setting light ${lightId} state:`, error);
        res.status(500).json({ error: 'Failed to set light state.' });
    }
});

// For widgets: Get current light status (simple example)
app.get('/api/widget-status', async (req, res) => {
    if (!hueApi) {
        return res.status(500).json({ error: 'Hue API not initialized.' });
    }
    try {
        const allLights = await hueApi.lights.getAll();
        // Just send a summary for a widget
        const summary = allLights.map(light => ({
            id: light.id,
            name: light.name,
            on: light.state.on,
            brightness: light.state.bri ? light.state.bri / 254 : 0, // Convert to 0-1
            hue: light.state.hue ? light.state.hue / 65535 : 0, // Convert to 0-1
            saturation: light.state.sat ? light.state.sat / 254 : 0 // Convert to 0-1
        }));
        res.json(summary);
    } catch (error) {
        console.error('Error getting widget status:', error);
        res.status(500).json({ error: 'Failed to get widget status.' });
    }
});

// --- Server Start ---
server.listen(PORT, async () => {
    console.log(`Node.js backend listening on port ${PORT}`);
    await initializeHue();
    // if (process.env.RUN_BLE_GATEWAY === 'true') {
    //    initializeBLE(); // Only run if configured as a BLE gateway
    // }
});



{
    "type": "setLightState",
    "lightId": "1",
    "state": {
        "on": true,
        "brightness": 0.8, // 0.0 - 1.0
        "hue": 0.5,       // 0.0 - 1.0
        "saturation": 0.7 // 0.0 - 1.0
    }
}


{
    "type": "updateBackcoverLED",
    "color": { "r": 1.0, "g": 0.5, "b": 0.0 } // RGB values 0.0 - 1.0
}


mkdir hue-led-python-backend
cd hue-led-python-backend
pip install Flask Flask-SocketIO python-dotenv phue bleak # bleak requires specific OS setup for Bluetooth



# app.py

import os
from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from dotenv import load_dotenv
import asyncio
import time

# For Philips Hue
from phue import Bridge

# For Bluetooth LE (Bleak) - Requires a Bluetooth adapter on the machine running this
from bleak import BleakClient, BleakScanner
import struct # For packing/unpacking BLE data

load_dotenv() # Load environment variables from .env file

app = Flask(__name__)
# Enable CORS for development (adjust in production)
app.config['CORS_HEADERS'] = 'Content-Type'
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='gevent') # or 'threading', 'eventlet'

PORT = os.getenv('PORT', 5000)

# --- Philips Hue Configuration ---
HUE_BRIDGE_IP = os.getenv('HUE_BRIDGE_IP') # e.g., '192.168.1.100'
HUE_USERNAME = os.getenv('HUE_USERNAME') # Generated after first connection
hue_bridge = None

# --- Hypothetical Backcover LED (via Bleak if running on a local gateway) ---
BACKCOVER_LED_SERVICE_UUID = os.getenv('BACKCOVER_SERVICE_UUID', 'YOUR_CUSTOM_SERVICE_UUID') # e.g., "180A" or your custom UUID
BACKCOVER_LED_CHARACTERISTIC_UUID = os.getenv('BACKCOVER_CHARACTERISTIC_UUID', 'YOUR_CUSTOM_CHARACTERISTIC_UUID') # e.g., "2A57" or your custom UUID
backcover_client = None # BleakClient instance
backcover_connected = False

# --- Hue Initialization ---
def initialize_hue():
    global hue_bridge
    if not HUE_BRIDGE_IP:
        print("HUE_BRIDGE_IP not set in .env. Attempting NUPNP search...")
        # phue library doesn't have built-in nupnp, you might need another library or manual input
        # For simplicity, assume IP is manually set for this example.
        print("Please set HUE_BRIDGE_IP in your .env file or discover manually.")
        return False
    try:
        hue_bridge = Bridge(HUE_BRIDGE_IP)
        # If no username, the bridge.connect() will guide you to press the button
        if not HUE_USERNAME:
            print("No HUE_USERNAME found. Press the Hue bridge button now...")
            hue_bridge.connect() # This will block until button is pressed or timeout
            # After successful connect, the username will be stored, retrieve it:
            # You might need to manually find the generated username after the first run.
            # print(f"New username generated: {hue_bridge.username}") # This property might not be directly exposed by phue
            # For `phue`, you typically set `HUE_USERNAME` after the first successful connection.
            # Example: print(hue_bridge.get_api()['config']['name']) # Access config
        else:
            print(f"Connecting to Hue bridge at {HUE_BRIDGE_IP} with username.")
            # Verify connection, a simple call like get_light will do
            hue_bridge.get_light('1') # Just to test connection
        print(f"Successfully connected to Hue Bridge at {HUE_BRIDGE_IP}")
        return True
    except Exception as e:
        print(f"Failed to initialize Hue API: {e}")
        return False

# --- BLE Initialization for Backcover LED (if this server acts as gateway) ---
async def initialize_ble():
    global backcover_client, backcover_connected
    print("Starting BLE scan for backcover LED...")
    try:
        devices = await BleakScanner.discover()
        target_device = None
        for device in devices:
            print(f"Found BLE device: {device.name} ({device.address})")
            if BACKCOVER_LED_SERVICE_UUID.lower() in [s.lower() for s in device.metadata.get('uuids', [])]:
                target_device = device
                break
            # Alternative: Search by name if you have a specific device name
            # if device.name and "MyBackcoverLED" in device.name:
            #     target_device = device
            #     break

        if target_device:
            print(f"Connecting to backcover LED: {target_device.name} ({target_device.address})")
            backcover_client = BleakClient(target_device.address)
            await backcover_client.connect()
            backcover_connected = True
            print("Backcover LED connected.")
            # You can discover services and characteristics here if needed,
            # or rely on direct UUIDs if you know them.
        else:
            print("Backcover LED device not found.")
            backcover_connected = False
    except Exception as e:
        print(f"BLE connection error: {e}")
        backcover_connected = False

# --- WebSocket Event Handlers ---
@socketio.on('connect')
def handle_connect():
    print('Client connected to WebSocket.')

@socketio.on('disconnect')
def handle_disconnect():
    print('Client disconnected from WebSocket.')

@socketio.on('message')
def handle_message(data):
    print('Received message from client:', data)
    try:
        msg_type = data.get('type')

        if msg_type == 'getLights':
            if hue_bridge:
                lights = hue_bridge.get_light_objects('id') # 'id' or 'name'
                light_list = []
                for light_id, light_obj in lights.items():
                    # phue returns a lot of data, simplify for the client
                    light_list.append({
                        'id': light_id,
                        'name': light_obj.name,
                        'on': light_obj.on,
                        'brightness': light_obj.brightness / 254 if light_obj.brightness is not None else 0,
                        'hue': light_obj.hue / 65535 if light_obj.hue is not None else 0,
                        'saturation': light_obj.saturation / 254 if light_obj.saturation is not None else 0,
                        'reachable': light_obj.reachable
                    })
                emit('lightsList', {'lights': light_list}, broadcast=True)
            else:
                emit('error', {'message': 'Hue API not initialized.'})

        elif msg_type == 'setLightState':
            light_id = str(data.get('lightId'))
            state_data = data.get('state')
            if hue_bridge and light_id and state_data:
                # phue uses direct properties
                light_state_dict = {}
                if 'on' in state_data: light_state_dict['on'] = state_data['on']
                if 'brightness' in state_data: light_state_dict['bri'] = int(state_data['brightness'] * 254)
                if 'hue' in state_data: light_state_dict['hue'] = int(state_data['hue'] * 65535)
                if 'saturation' in state_data: light_state_dict['sat'] = int(state_data['saturation'] * 254)

                hue_bridge.set_light(light_id, light_state_dict)
                emit('lightStateUpdated', {'lightId': light_id, 'newState': state_data}, broadcast=True)
                print(f"Light {light_id} state updated.")
            else:
                emit('error', {'message': 'Invalid light ID or state data.'})

        elif msg_type == 'updateBackcoverLED':
            color_data = data.get('color') # Expecting {r: 0-1, g: 0-1, b: 0-1}
            if backcover_client and backcover_connected and color_data:
                r = int(color_data.get('r', 0) * 255)
                g = int(color_data.get('g', 0) * 255)
                b = int(color_data.get('b', 0) * 255)
                # Pack RGB bytes into a format your BLE device expects (e.g., Little Endian, 3 bytes)
                rgb_bytes = struct.pack('<BBB', r, g, b) # Example: Little Endian byte order

                try:
                    await backcover_client.write_gatt_char(BACKCOVER_LED_CHARACTERISTIC_UUID, rgb_bytes, response=True)
                    print(f"Sent color to backcover LED: R:{r}, G:{g}, B:{b}")
                    emit('backcoverLEDUpdated', {'color': color_data}, broadcast=True)
                except Exception as e:
                    print(f"Failed to write to BLE characteristic: {e}")
                    emit('error', {'message': f'Failed to write to backcover LED: {e}'})
            else:
                emit('error', {'message': 'Backcover LED gateway not connected or invalid color data.'})

        elif msg_type == 'tapToSurfaceTriggered':
            print("Tap to surface gesture received from iOS app!")
            # Implement backend logic for this gesture, e.g., toggle a light
            if hue_bridge:
                try:
                    light_id = '1' # Example: Affect light with ID 1
                    current_state = hue_bridge.get_light(light_id, 'on')
                    hue_bridge.set_light(light_id, 'on', not current_state)
                    print(f"Toggled light {light_id} to: {not current_state}")
                    # Notify clients of the update
                    emit('lightStateUpdated', {'lightId': light_id, 'newState': {'on': not current_state}}, broadcast=True)
                except Exception as e:
                    print(f"Error toggling light: {e}")
                    emit('error', {'message': f'Error toggling light: {e}'})

        else:
            print(f"Unknown message type: {msg_type}")
            emit('error', {'message': f'Unknown message type: {msg_type}'})

    except Exception as e:
        print(f"Error processing WebSocket message: {e}")
        emit('error', {'message': f'Server error: {e}'})

# --- HTTP API Endpoints (for widgets or initial data) ---
@app.route('/api/lights', methods=['GET'])
def get_lights_http():
    if not hue_bridge:
        return jsonify({'error': 'Hue API not initialized.'}), 500
    try:
        lights = hue_bridge.get_light_objects('id')
        light_list = []
        for light_id, light_obj in lights.items():
            light_list.append({
                'id': light_id,
                'name': light_obj.name,
                'on': light_obj.on,
                'brightness': light_obj.brightness / 254 if light_obj.brightness is not None else 0,
                'hue': light_obj.hue / 65535 if light_obj.hue is not None else 0,
                'saturation': light_obj.saturation / 254 if light_obj.saturation is not None else 0,
                'reachable': light_obj.reachable
            })
        return jsonify(light_list)
    except Exception as e:
        print(f"Error getting lights via HTTP: {e}")
        return jsonify({'error': 'Failed to retrieve lights.'}), 500

@app.route('/api/widget-status', methods=['GET'])
def get_widget_status():
    if not hue_bridge:
        return jsonify({'error': 'Hue API not initialized.'}), 500
    try:
        all_lights = hue_bridge.get_light_objects('id')
        summary = []
        for light_id, light_obj in all_lights.items():
            summary.append({
                'id': light_id,
                'name': light_obj.name,
                'on': light_obj.on,
                'brightness': light_obj.brightness / 254 if light_obj.brightness is not None else 0,
                'hue': light_obj.hue / 65535 if light_obj.hue is not None else 0,
                'saturation': light_obj.saturation / 254 if light_obj.saturation is not None else 0
            })
        return jsonify(summary)
    except Exception as e:
        print(f"Error getting widget status: {e}")
        return jsonify({'error': 'Failed to get widget status.'}), 500

# --- Startup ---
if __name__ == '__main__':
    # Initialize Hue Bridge
    initialize_hue()

    # Initialize BLE (if running on a dedicated gateway)
    # Note: Bleak requires the main loop to run. For Flask-SocketIO,
    # you might need to run Bleak in a separate thread or process,
    # or use an async Flask setup (e.g., FastAPI or Quart).
    # For simplicity, we'll assume it's part of the main process if enabled.
    run_ble_gateway = os.getenv('RUN_BLE_GATEWAY', 'false').lower() == 'true'
    if run_ble_gateway:
        # This will run the async BLE init. In a production Flask-SocketIO setup,
        # you might daemonize this or run it in a separate process.
        # For simple testing:
        print("Attempting to initialize BLE gateway...")
        asyncio.run(initialize_ble())
        # Or, if running in a separate thread/process:
        # from threading import Thread
        # Thread(target=lambda: asyncio.run(initialize_ble())).start()

    print(f"Python backend starting on port {PORT}...")
    socketio.run(app, host='0.0.0.0', port=PORT, allow_unsafe_werkzeug=True, debug=True)



You're asking for a very ambitious project, combining a custom iOS UI with external hardware control (Philips Hue and a hypothetical backcover LED) using Python.
Similar to the Node.js answer, it's crucial to understand:
 * Python is NOT native for iOS UI. While you can write iOS apps in Python, they typically use cross-platform frameworks like Kivy or BeeWare. These frameworks translate your Python code into a native or near-native app, but they have their own limitations compared to writing directly in Swift/SwiftUI.
 * Python is excellent for the backend/logic. You can use Python for:
   * Communicating with Philips Hue bridges.
   * Potentially acting as a BLE gateway on a local device (like a Raspberry Pi) to control your "backcover LED."
   * Providing a backend API (e.g., with Flask or FastAPI) that your iOS app consumes.
 * Widgets are iOS-native. WidgetKit is a Swift-only framework. If you build your main app with Kivy/BeeWare, your widgets will still need to be written in Swift, and they'll communicate with your Python backend (or a shared data container) to get their data.
Given this, I'll provide:
 * Conceptual Architecture: How Python fits into this.
 * Python Backend Code: For Philips Hue control and a hypothetical BLE gateway.
 * Python (Kivy/BeeWare) UI Concepts: How you might structure the iOS app.
 * Integration Notes: How the pieces connect.
Conceptual Architecture
 * iOS App (Kivy/BeeWare Python + Swift for Widgets):
   * Main App (Python): Handles the "tap to surface" UI, animations, gestures, and sends commands to the Python backend via HTTP/WebSocket.
   * Widgets (Swift/WidgetKit): Native iOS widgets that fetch data from the Python backend (or shared data) and display it. They might deep-link back into the Python app.
 * Python Backend Server (Flask/FastAPI + WebSockets):
   * Acts as the central hub.
   * HTTP/WebSocket API: For the iOS app to send commands (e.g., "turn on light", "set backcover color") and receive updates.
   * Philips Hue Integration: Uses a Python library to talk to the Hue bridge.
   * BLE Gateway (Optional/Recommended for Backcover): A separate Python script running on a device with Bluetooth (e.g., Raspberry Pi) that communicates with your custom backcover LED. This script could then expose a local API (HTTP/WebSocket) that the main Python backend calls.
 * Custom Backcover LED Hardware:
   * A physical device (e.g., ESP32, Arduino with BLE) with custom firmware to receive BLE commands and control LEDs. (Not Python code).
Python Backend Code Structure (Conceptual)
We'll use Flask for a simple HTTP server and Flask-SocketIO for WebSockets. For Philips Hue, phue is a common library. For BLE, bleak is a modern, async-friendly option.
1. Project Setup:
mkdir hue-led-python-backend
cd hue-led-python-backend
pip install Flask Flask-SocketIO python-dotenv phue bleak # bleak requires specific OS setup for Bluetooth

2. app.py (Main Backend Logic)
# app.py

import os
from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from dotenv import load_dotenv
import asyncio
import time

# For Philips Hue
from phue import Bridge

# For Bluetooth LE (Bleak) - Requires a Bluetooth adapter on the machine running this
from bleak import BleakClient, BleakScanner
import struct # For packing/unpacking BLE data

load_dotenv() # Load environment variables from .env file

app = Flask(__name__)
# Enable CORS for development (adjust in production)
app.config['CORS_HEADERS'] = 'Content-Type'
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='gevent') # or 'threading', 'eventlet'

PORT = os.getenv('PORT', 5000)

# --- Philips Hue Configuration ---
HUE_BRIDGE_IP = os.getenv('HUE_BRIDGE_IP') # e.g., '192.168.1.100'
HUE_USERNAME = os.getenv('HUE_USERNAME') # Generated after first connection
hue_bridge = None

# --- Hypothetical Backcover LED (via Bleak if running on a local gateway) ---
BACKCOVER_LED_SERVICE_UUID = os.getenv('BACKCOVER_SERVICE_UUID', 'YOUR_CUSTOM_SERVICE_UUID') # e.g., "180A" or your custom UUID
BACKCOVER_LED_CHARACTERISTIC_UUID = os.getenv('BACKCOVER_CHARACTERISTIC_UUID', 'YOUR_CUSTOM_CHARACTERISTIC_UUID') # e.g., "2A57" or your custom UUID
backcover_client = None # BleakClient instance
backcover_connected = False

# --- Hue Initialization ---
def initialize_hue():
    global hue_bridge
    if not HUE_BRIDGE_IP:
        print("HUE_BRIDGE_IP not set in .env. Attempting NUPNP search...")
        # phue library doesn't have built-in nupnp, you might need another library or manual input
        # For simplicity, assume IP is manually set for this example.
        print("Please set HUE_BRIDGE_IP in your .env file or discover manually.")
        return False
    try:
        hue_bridge = Bridge(HUE_BRIDGE_IP)
        # If no username, the bridge.connect() will guide you to press the button
        if not HUE_USERNAME:
            print("No HUE_USERNAME found. Press the Hue bridge button now...")
            hue_bridge.connect() # This will block until button is pressed or timeout
            # After successful connect, the username will be stored, retrieve it:
            # You might need to manually find the generated username after the first run.
            # print(f"New username generated: {hue_bridge.username}") # This property might not be directly exposed by phue
            # For `phue`, you typically set `HUE_USERNAME` after the first successful connection.
            # Example: print(hue_bridge.get_api()['config']['name']) # Access config
        else:
            print(f"Connecting to Hue bridge at {HUE_BRIDGE_IP} with username.")
            # Verify connection, a simple call like get_light will do
            hue_bridge.get_light('1') # Just to test connection
        print(f"Successfully connected to Hue Bridge at {HUE_BRIDGE_IP}")
        return True
    except Exception as e:
        print(f"Failed to initialize Hue API: {e}")
        return False

# --- BLE Initialization for Backcover LED (if this server acts as gateway) ---
async def initialize_ble():
    global backcover_client, backcover_connected
    print("Starting BLE scan for backcover LED...")
    try:
        devices = await BleakScanner.discover()
        target_device = None
        for device in devices:
            print(f"Found BLE device: {device.name} ({device.address})")
            if BACKCOVER_LED_SERVICE_UUID.lower() in [s.lower() for s in device.metadata.get('uuids', [])]:
                target_device = device
                break
            # Alternative: Search by name if you have a specific device name
            # if device.name and "MyBackcoverLED" in device.name:
            #     target_device = device
            #     break

        if target_device:
            print(f"Connecting to backcover LED: {target_device.name} ({target_device.address})")
            backcover_client = BleakClient(target_device.address)
            await backcover_client.connect()
            backcover_connected = True
            print("Backcover LED connected.")
            # You can discover services and characteristics here if needed,
            # or rely on direct UUIDs if you know them.
        else:
            print("Backcover LED device not found.")
            backcover_connected = False
    except Exception as e:
        print(f"BLE connection error: {e}")
        backcover_connected = False

# --- WebSocket Event Handlers ---
@socketio.on('connect')
def handle_connect():
    print('Client connected to WebSocket.')

@socketio.on('disconnect')
def handle_disconnect():
    print('Client disconnected from WebSocket.')

@socketio.on('message')
def handle_message(data):
    print('Received message from client:', data)
    try:
        msg_type = data.get('type')

        if msg_type == 'getLights':
            if hue_bridge:
                lights = hue_bridge.get_light_objects('id') # 'id' or 'name'
                light_list = []
                for light_id, light_obj in lights.items():
                    # phue returns a lot of data, simplify for the client
                    light_list.append({
                        'id': light_id,
                        'name': light_obj.name,
                        'on': light_obj.on,
                        'brightness': light_obj.brightness / 254 if light_obj.brightness is not None else 0,
                        'hue': light_obj.hue / 65535 if light_obj.hue is not None else 0,
                        'saturation': light_obj.saturation / 254 if light_obj.saturation is not None else 0,
                        'reachable': light_obj.reachable
                    })
                emit('lightsList', {'lights': light_list}, broadcast=True)
            else:
                emit('error', {'message': 'Hue API not initialized.'})

        elif msg_type == 'setLightState':
            light_id = str(data.get('lightId'))
            state_data = data.get('state')
            if hue_bridge and light_id and state_data:
                # phue uses direct properties
                light_state_dict = {}
                if 'on' in state_data: light_state_dict['on'] = state_data['on']
                if 'brightness' in state_data: light_state_dict['bri'] = int(state_data['brightness'] * 254)
                if 'hue' in state_data: light_state_dict['hue'] = int(state_data['hue'] * 65535)
                if 'saturation' in state_data: light_state_dict['sat'] = int(state_data['saturation'] * 254)

                hue_bridge.set_light(light_id, light_state_dict)
                emit('lightStateUpdated', {'lightId': light_id, 'newState': state_data}, broadcast=True)
                print(f"Light {light_id} state updated.")
            else:
                emit('error', {'message': 'Invalid light ID or state data.'})

        elif msg_type == 'updateBackcoverLED':
            color_data = data.get('color') # Expecting {r: 0-1, g: 0-1, b: 0-1}
            if backcover_client and backcover_connected and color_data:
                r = int(color_data.get('r', 0) * 255)
                g = int(color_data.get('g', 0) * 255)
                b = int(color_data.get('b', 0) * 255)
                # Pack RGB bytes into a format your BLE device expects (e.g., Little Endian, 3 bytes)
                rgb_bytes = struct.pack('<BBB', r, g, b) # Example: Little Endian byte order

                try:
                    await backcover_client.write_gatt_char(BACKCOVER_LED_CHARACTERISTIC_UUID, rgb_bytes, response=True)
                    print(f"Sent color to backcover LED: R:{r}, G:{g}, B:{b}")
                    emit('backcoverLEDUpdated', {'color': color_data}, broadcast=True)
                except Exception as e:
                    print(f"Failed to write to BLE characteristic: {e}")
                    emit('error', {'message': f'Failed to write to backcover LED: {e}'})
            else:
                emit('error', {'message': 'Backcover LED gateway not connected or invalid color data.'})

        elif msg_type == 'tapToSurfaceTriggered':
            print("Tap to surface gesture received from iOS app!")
            # Implement backend logic for this gesture, e.g., toggle a light
            if hue_bridge:
                try:
                    light_id = '1' # Example: Affect light with ID 1
                    current_state = hue_bridge.get_light(light_id, 'on')
                    hue_bridge.set_light(light_id, 'on', not current_state)
                    print(f"Toggled light {light_id} to: {not current_state}")
                    # Notify clients of the update
                    emit('lightStateUpdated', {'lightId': light_id, 'newState': {'on': not current_state}}, broadcast=True)
                except Exception as e:
                    print(f"Error toggling light: {e}")
                    emit('error', {'message': f'Error toggling light: {e}'})

        else:
            print(f"Unknown message type: {msg_type}")
            emit('error', {'message': f'Unknown message type: {msg_type}'})

    except Exception as e:
        print(f"Error processing WebSocket message: {e}")
        emit('error', {'message': f'Server error: {e}'})

# --- HTTP API Endpoints (for widgets or initial data) ---
@app.route('/api/lights', methods=['GET'])
def get_lights_http():
    if not hue_bridge:
        return jsonify({'error': 'Hue API not initialized.'}), 500
    try:
        lights = hue_bridge.get_light_objects('id')
        light_list = []
        for light_id, light_obj in lights.items():
            light_list.append({
                'id': light_id,
                'name': light_obj.name,
                'on': light_obj.on,
                'brightness': light_obj.brightness / 254 if light_obj.brightness is not None else 0,
                'hue': light_obj.hue / 65535 if light_obj.hue is not None else 0,
                'saturation': light_obj.saturation / 254 if light_obj.saturation is not None else 0,
                'reachable': light_obj.reachable
            })
        return jsonify(light_list)
    except Exception as e:
        print(f"Error getting lights via HTTP: {e}")
        return jsonify({'error': 'Failed to retrieve lights.'}), 500

@app.route('/api/widget-status', methods=['GET'])
def get_widget_status():
    if not hue_bridge:
        return jsonify({'error': 'Hue API not initialized.'}), 500
    try:
        all_lights = hue_bridge.get_light_objects('id')
        summary = []
        for light_id, light_obj in all_lights.items():
            summary.append({
                'id': light_id,
                'name': light_obj.name,
                'on': light_obj.on,
                'brightness': light_obj.brightness / 254 if light_obj.brightness is not None else 0,
                'hue': light_obj.hue / 65535 if light_obj.hue is not None else 0,
                'saturation': light_obj.saturation / 254 if light_obj.saturation is not None else 0
            })
        return jsonify(summary)
    except Exception as e:
        print(f"Error getting widget status: {e}")
        return jsonify({'error': 'Failed to get widget status.'}), 500

# --- Startup ---
if __name__ == '__main__':
    # Initialize Hue Bridge
    initialize_hue()

    # Initialize BLE (if running on a dedicated gateway)
    # Note: Bleak requires the main loop to run. For Flask-SocketIO,
    # you might need to run Bleak in a separate thread or process,
    # or use an async Flask setup (e.g., FastAPI or Quart).
    # For simplicity, we'll assume it's part of the main process if enabled.
    run_ble_gateway = os.getenv('RUN_BLE_GATEWAY', 'false').lower() == 'true'
    if run_ble_gateway:
        # This will run the async BLE init. In a production Flask-SocketIO setup,
        # you might daemonize this or run it in a separate process.
        # For simple testing:
        print("Attempting to initialize BLE gateway...")
        asyncio.run(initialize_ble())
        # Or, if running in a separate thread/process:
        # from threading import Thread
        # Thread(target=lambda: asyncio.run(initialize_ble())).start()

    print(f"Python backend starting on port {PORT}...")
    socketio.run(app, host='0.0.0.0', port=PORT, allow_unsafe_werkzeug=True, debug=True)

3. .env file (in the same directory as app.py)
PORT=5000
HUE_BRIDGE_IP=192.168.1.XXX # Replace with your Hue bridge IP
HUE_USERNAME=YOUR_GENERATED_HUE_USERNAME # Get this after the first successful bridge.connect()
RUN_BLE_GATEWAY=false # Set to 'true' if this server should also manage BLE for backcover
BACKCOVER_SERVICE_UUID=YOUR_CUSTOM_SERVICE_UUID # Match your custom BLE device
BACKCOVER_CHARACTERISTIC_UUID=YOUR_CUSTOM_CHARACTERISTIC_UUID # Match your custom BLE device

Python for iOS App UI (Kivy / BeeWare Concepts)
A. Kivy (for highly custom UI, cross-platform)
Kivy is good for visually rich, custom UIs. It's less "native-looking" but offers flexibility.
# main.py (Kivy app for iOS)
import json
import requests
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.slider import Slider
from kivy.uix.label import Label
from kivy.properties import BooleanProperty, NumericProperty, StringProperty, ListProperty
from kivy.clock import Clock
from kivy.network.urlrequest import UrlRequest # For HTTP requests
from websocket import create_connection # pip install websocket-client

# Replace with your backend URL
BACKEND_URL = "http://YOUR_BACKEND_IP:5000"
WEBSOCKET_URL = "ws://YOUR_BACKEND_IP:5000"

class HueLightController(BoxLayout):
    is_surface_visible = BooleanProperty(False)
    selected_light_name = StringProperty("No Light Selected")
    selected_light_brightness = NumericProperty(0.0)
    selected_light_hue = NumericProperty(0.0)
    selected_light_saturation = NumericProperty(0.0)
    lights_list = ListProperty([])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.orientation = 'vertical'
        self.spacing = 10
        self.padding = 10
        self.ws = None
        self.selected_light_id = None
        self.build_ui()
        self.connect_to_websocket()
        Clock.schedule_once(self.fetch_lights, 1) # Fetch lights after UI is built

    def build_ui(self):
        # Main content
        self.add_widget(Label(text="Tap anywhere to surface controls", size_hint_y=0.1))
        self.main_content_area = BoxLayout(orientation='vertical')
        self.lights_display = Label(text="Loading lights...", size_hint_y=0.8)
        self.main_content_area.add_widget(self.lights_display)
        self.add_widget(self.main_content_area)

        # "Tap to Surface" Overlay
        self.surface_layout = BoxLayout(
            orientation='vertical',
            size_hint=(0.8, 0.8),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            opacity=0,
            disabled=True # Disabled when not visible
        )
        self.surface_layout.add_widget(Label(text="Hue Controls", size_hint_y=0.2))
        self.surface_layout.add_widget(Label(text=self.selected_light_name, size_hint_y=0.1, id='light_name_label'))

        brightness_slider = Slider(min=0, max=1, value=self.selected_light_brightness, size_hint_y=0.2)
        brightness_slider.bind(value=self.on_brightness_change)
        self.surface_layout.add_widget(brightness_slider)

        hue_slider = Slider(min=0, max=1, value=self.selected_light_hue, size_hint_y=0.2)
        hue_slider.bind(value=self.on_hue_change)
        self.surface_layout.add_widget(hue_slider)

        saturation_slider = Slider(min=0, max=1, value=self.selected_light_saturation, size_hint_y=0.2)
        saturation_slider.bind(value=self.on_saturation_change)
        self.surface_layout.add_widget(saturation_slider)

        close_button = Button(text="Close Controls", size_hint_y=0.2)
        close_button.bind(on_press=self.toggle_surface)
        self.surface_layout.add_widget(close_button)

        self.add_widget(self.surface_layout)

    def on_touch_down(self, touch):
        # Simple tap to toggle surface visibility
        if self.collide_point(*touch.pos):
            if not self.is_surface_visible and not self.surface_layout.collide_point(*touch.pos):
                self.toggle_surface()
                return True
            elif self.is_surface_visible and self.surface_layout.collide_point(*touch.pos):
                # Allow interaction with controls if surface is visible
                return super().on_touch_down(touch)
            elif self.is_surface_visible and not self.surface_layout.collide_point(*touch.pos):
                 self.toggle_surface() # Tap outside to close
                 return True
        return super().on_touch_down(touch)

    def toggle_surface(self, *args):
        self.is_surface_visible = not self.is_surface_visible
        if self.is_surface_visible:
            self.surface_layout.opacity = 1
            self.surface_layout.disabled = False
            # Send a "tapToSurfaceTriggered" message to the backend
            if self.ws and self.ws.connected:
                self.ws.send(json.dumps({"type": "tapToSurfaceTriggered"}))
        else:
            self.surface_layout.opacity = 0
            self.surface_layout.disabled = True

    def fetch_lights(self, dt):
        print("Fetching lights...")
        req = UrlRequest(f"{BACKEND_URL}/api/lights", on_success=self.on_lights_fetched, on_failure=self.on_request_error, on_error=self.on_request_error)

    def on_lights_fetched(self, request, result):
        self.lights_list = result
        light_names = [light['name'] for light in result]
        self.lights_display.text = "Available Lights:\n" + "\n".join(light_names)
        if result:
            self.selected_light_id = result[0]['id']
            self.selected_light_name = result[0]['name']
            self.selected_light_brightness = result[0]['brightness']
            self.selected_light_hue = result[0]['hue']
            self.selected_light_saturation = result[0]['saturation']
            # Update the label in the surface layout
            self.surface_layout.ids.light_name_label.text = self.selected_light_name


    def on_request_error(self, request, error):
        print(f"Request failed: {error}")
        self.lights_display.text = f"Error fetching lights: {error}"

    def connect_to_websocket(self):
        try:
            self.ws = create_connection(WEBSOCKET_URL)
            print("WebSocket connected.")
            Clock.schedule_interval(self.websocket_read_loop, 0.1) # Read messages periodically
        except Exception as e:
            print(f"WebSocket connection failed: {e}")

    def websocket_read_loop(self, dt):
        if self.ws and self.ws.connected:
            try:
                result = self.ws.recv()
                data = json.loads(result)
                self.handle_websocket_message(data)
            except Exception as e:
                # print(f"No new WS message or WS error: {e}") # Suppress if no message
                pass
        else:
            # Attempt to reconnect if disconnected
            print("WebSocket disconnected, attempting to reconnect...")
            self.connect_to_websocket()


    def handle_websocket_message(self, data):
        print(f"WS message received: {data}")
        if data.get('type') == 'lightStateUpdated':
            light_id = data['lightId']
            new_state = data['newState']
            if light_id == self.selected_light_id:
                if 'on' in new_state: self.selected_light_brightness = new_state['brightness'] if 'brightness' in new_state else self.selected_light_brightness
                if 'brightness' in new_state: self.selected_light_brightness = new_state['brightness']
                if 'hue' in new_state: self.selected_light_hue = new_state['hue']
                if 'saturation' in new_state: self.selected_light_saturation = new_state['saturation']
                # Update UI elements
                self.surface_layout.children[2].value = self.selected_light_brightness # Assuming order
                self.surface_layout.children[1].value = self.selected_light_hue
                self.surface_layout.children[0].value = self.selected_light_saturation
        elif data.get('type') == 'backcoverLEDUpdated':
            print(f"Backcover LED updated to color: {data['color']}")
            # You could update a visual representation of the backcover here if desired
        elif data.get('type') == 'error':
            print(f"Backend error: {data['message']}")


    def send_light_command(self, state_key, value):
        if self.ws and self.ws.connected and self.selected_light_id:
            payload = {
                "type": "setLightState",
                "lightId": self.selected_light_id,
                "state": {state_key: value}
            }
            self.ws.send(json.dumps(payload))

            # Also send to backcover if it's related
            if state_key == 'hue' or state_key == 'saturation':
                # Map hue/saturation to RGB for backcover
                # This is a simplified conversion. Actual conversion is complex.
                # For demo, just send a representative color based on hue.
                r, g, b = self._hue_to_rgb(self.selected_light_hue, self.selected_light_saturation, self.selected_light_brightness)
                self.send_backcover_command(r, g, b)


    def on_brightness_change(self, instance, value):
        self.selected_light_brightness = value
        self.send_light_command('brightness', value)

    def on_hue_change(self, instance, value):
        self.selected_light_hue = value
        self.send_light_command('hue', value)

    def on_saturation_change(self, instance, value):
        self.selected_light_saturation = value
        self.send_light_command('saturation', value)

    def send_backcover_command(self, r, g, b):
        if self.ws and self.ws.connected:
            payload = {
                "type": "updateBackcoverLED",
                "color": {"r": r, "g": g, "b": b}
            }
            self.ws.send(json.dumps(payload))

    def _hue_to_rgb(self, h, s, v):
        # A simple, approximate HSL/HSV to RGB conversion for visualization.
        # For accurate Hue behavior, you'd use the Hue API's color capabilities.
        h_deg = h * 360
        s_val = s
        v_val = v # using brightness as value for now

        if s_val == 0:
            return v_val, v_val, v_val # achromatic
        i = int(h_deg / 60) % 6
        f = (h_deg / 60) - i
        p = v_val * (1 - s_val)
        q = v_val * (1 - f * s_val)
        t = v_val * (1 - (1 - f) * s_val)

        if i == 0: return v_val, t, p
        if i == 1: return q, v_val, p
        if i == 2: return p, v_val, t
        if i == 3: return p, q, v_val
        if i == 4: return t, p, v_val
        if i == 5: return v_val, p, q
        return 0,0,0 # Should not reach here

class HueApp(App):
    def build(self):
        return HueLightController()

if __name__ == '__main__':
    HueApp().run()

To convert Kivy to iOS: You'd use Buildozer (pip install buildozer) and follow the Kivy iOS documentation (which involves setting up Xcode tools, dependencies, etc.).
B. BeeWare (for more native-looking UIs)
BeeWare aims for a native look and feel. It would use Toga for the UI. Bluetooth LE integration directly in the iOS app (via CoreBluetooth wrappers in BeeWare, if available, or custom Objective-C/Swift bridges) would be more feasible here than in Kivy.
# app.py (BeeWare app for iOS) - Conceptual, BLE part would need more advanced Toga/platform integration
import asyncio
import toga
from toga.style import Pack
from toga.style.pack import COLUMN, ROW
import json
import httpx # pip install httpx for async HTTP
import websockets # pip install websockets for async WS

# Replace with your backend URL
BACKEND_URL = "http://YOUR_BACKEND_IP:5000"
WEBSOCKET_URL = "ws://YOUR_BACKEND_IP:5000"

class HueLightControlApp(toga.App):
    def startup(self):
        self.main_window = toga.MainWindow(title=self.formal_name)
        self.ws = None
        self.selected_light_id = None
        self.lights_data = []

        # Main UI
        main_box = toga.Box(style=Pack(direction=COLUMN, padding=10))

        self.status_label = toga.Label("Loading lights...", style=Pack(flex=1))
        main_box.add(self.status_label)

        self.tap_area = toga.Button(
            "Tap to Surface Controls",
            on_press=self.toggle_surface,
            style=Pack(flex=1, background_color='lightblue')
        )
        main_box.add(self.tap_area)

        # "Tap to Surface" Overlay (a modal dialog or another window)
        self.surface_box = toga.Box(
            style=Pack(direction=COLUMN, padding=20, background_color='lightgray')
        )
        self.surface_box.add(toga.Label("Hue Light Controls", style=Pack(font_size=20)))
        self.selected_light_name_label = toga.Label("No Light Selected", style=Pack(font_size=16))
        self.surface_box.add(self.selected_light_name_label)

        self.brightness_slider = toga.Slider(range=(0, 1), on_change=self.on_brightness_change)
        self.surface_box.add(toga.Box(children=[toga.Label("Brightness:"), self.brightness_slider], style=Pack(direction=ROW)))

        self.hue_slider = toga.Slider(range=(0, 1), on_change=self.on_hue_change)
        self.surface_box.add(toga.Box(children=[toga.Label("Hue:"), self.hue_slider], style=Pack(direction=ROW)))

        self.saturation_slider = toga.Slider(range=(0, 1), on_change=self.on_saturation_change)
        self.surface_box.add(toga.Box(children=[toga.Label("Saturation:"), self.saturation_slider], style=Pack(direction=ROW)))

        close_button = toga.Button("Close Controls", on_press=self.toggle_surface)
        self.surface_box.add(close_button)

        self.main_window.content = main_box
        self.main_window.show()

        # Start background tasks
        self.add_background_task(self.fetch_lights_task)
        self.add_background_task(self.connect_to_websocket_task)


    async def fetch_lights_task(self, app):
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(f"{BACKEND_URL}/api/lights")
                response.raise_for_status()
                self.lights_data = response.json()
                light_names = [light['name'] for light in self.lights_data]
                self.status_label.text = "Available Lights:\n" + "\n".join(light_names)
                if self.lights_data:
                    # Select first light by default
                    self.selected_light_id = self.lights_data[0]['id']
                    self.selected_light_name_label.text = self.lights_data[0]['name']
                    self.brightness_slider.value = self.lights_data[0]['brightness']
                    self.hue_slider.value = self.lights_data[0]['hue']
                    self.saturation_slider.value = self.lights_data[0]['saturation']
        except httpx.HTTPStatusError as e:
            self.status_label.text = f"HTTP Error fetching lights: {e}"
            print(f"HTTP Error fetching lights: {e}")
        except Exception as e:
            self.status_label.text = f"Error fetching lights: {e}"
            print(f"Error fetching lights: {e}")

    async def connect_to_websocket_task(self, app):
        while True:
            try:
                print("Attempting WebSocket connection...")
                async with websockets.connect(WEBSOCKET_URL) as ws:
                    self.ws = ws
                    print("WebSocket connected.")
                    await self.websocket_listen_loop(ws)
            except Exception as e:
                print(f"WebSocket connection failed: {e}. Retrying in 5 seconds...")
                await asyncio.sleep(5)

    async def websocket_listen_loop(self, ws):
        try:
            async for message in ws:
                data = json.loads(message)
                self.handle_websocket_message(data)
        except websockets.exceptions.ConnectionClosedOK:
            print("WebSocket closed normally.")
        except Exception as e:
            print(f"WebSocket error in listen loop: {e}")
        finally:
            self.ws = None # Mark as disconnected


    def handle_websocket_message(self, data):
        print(f"WS message received: {data}")
        self.app.main_window.show_message_dialog("WS Message", str(data)) # For debugging on device

        if data.get('type') == 'lightStateUpdated':
            light_id = data['lightId']
            new_state = data['newState']
            if light_id == self.selected_light_id:
                if 'brightness' in new_state: self.brightness_slider.value = new_state['brightness']
                if 'hue' in new_state: self.hue_slider.value = new_state['hue']
                if 'saturation' in new_state: self.saturation_slider.value = new_state['saturation']
        elif data.get('type') == 'backcoverLEDUpdated':
            print(f"Backcover LED updated to color: {data['color']}")
        elif data.get('type') == 'error':
            self.app.main_window.show_error_dialog("Backend Error", data['message'])

    async def send_websocket_message(self, payload):
        if self.ws and self.ws.connected:
            try:
                await self.ws.send(json.dumps(payload))
            except Exception as e:
                print(f"Failed to send WS message: {e}")
                self.app.main_window.show_error_dialog("WS Send Error", f"Failed to send command: {e}")
        else:
            print("WebSocket not connected. Cannot send message.")
            self.app.main_window.show_error_dialog("WS Error", "Not connected to backend.")

    def toggle_surface(self, widget):
        if self.main_window.content == self.main_window._impl.container: # If main content is visible
            self.main_window.content = self.surface_box
            # Send tap to surface trigger to backend
            asyncio.create_task(self.send_websocket_message({"type": "tapToSurfaceTriggered"}))
        else:
            self.main_window.content = self.main_window._impl.container # Go back to main content

    def on_brightness_change(self, slider):
        asyncio.create_task(self.send_light_command('brightness', slider.value))

    def on_hue_change(self, slider):
        asyncio.create_task(self.send_light_command('hue', slider.value))
        # Also send to backcover if it's related
        r, g, b = self._hue_to_rgb(self.hue_slider.value, self.saturation_slider.value, self.brightness_slider.value)
        asyncio.create_task(self.send_backcover_command(r, g, b))

    def on_saturation_change(self, slider):
        asyncio.create_task(self.send_light_command('saturation', slider.value))
        r, g, b = self._hue_to_rgb(self.hue_slider.value, self.saturation_slider.value, self.brightness_slider.value)
        asyncio.create_task(self.send_backcover_command(r, g, b))

    async def send_light_command(self, state_key, value):
        if self.selected_light_id:
            payload = {
                "type": "setLightState",
                "lightId": self.selected_light_id,
                "state": {state_key: value}
            }
            await self.send_websocket_message(payload)

    async def send_backcover_command(self, r, g, b):
        payload = {
            "type": "updateBackcoverLED",
            "color": {"r": r, "g": g, "b": b}
        }
        await self.send_websocket_message(payload)

    def _hue_to_rgb(self, h, s, v):
        # Simplified conversion - implement full logic for accuracy
        h_deg = h * 360
        s_val = s
        v_val = v
        # ... (same logic as in Kivy example)
        return h, s, v # Placeholder, return actual RGB

def main():
    return HueLightControlApp('Hue Control', 'com.example.huecontrol')

if __name__ == '__main__':
    main().main_loop()


To convert BeeWare to iOS: Use Briefcase (pip install briefcase) and follow the BeeWare documentation, which handles Xcode project generation and packaging.
Integration Notes
 * Backend Deployment: Your Python backend needs to be running and accessible from your iOS device (same Wi-Fi network, or deployed to a cloud server with a public IP).
 * Widget Data: Python mobile frameworks generally don't directly integrate with WidgetKit.
   * Option 1 (Recommended): Widgets are written purely in Swift. They use URLSession to call your Python backend's HTTP /api/widget-status endpoint for their data. Use App Groups to share a small amount of data locally if real-time backend calls are too slow for widget updates.
   * Option 2 (Advanced/Complex): If you need real-time push to widgets, your Python backend would need to integrate with Apple Push Notification Service (APNs) to send silent push notifications to your Swift widget extension, prompting it to refresh its timeline. This requires APNs setup and a Python library for APNs (e.g., PyAPNs2).
 * BLE on iOS (Python):
   * Kivy: Direct BLE interaction within Kivy on iOS is challenging and usually requires writing custom Objective-C/Swift plugins that Kivy can call.
   * BeeWare: Toga might offer some basic BLE capabilities, or you'd need to use BeeWare's platform-specific API access to interact with CoreBluetooth. This is an area where Python on iOS can be complex.
   * Best Practice: For BLE control of custom hardware, a dedicated Python script running on a local device (like a Raspberry Pi) acting as a gateway is usually the most robust and flexible approach. Your iOS app talks to the backend, and the backend talks to the gateway.
 * Build Process: Building Python apps for iOS (especially with BLE or complex native features) can be intricate and involve setting up Xcode, signing certificates, and handling dependencies specific to iOS.
This provides a strong starting point for using Python to tackle this advanced iOS project, emphasizing the division of labor between Python's strengths (backend logic, hardware comms via gateway) and Swift/native iOS for the ultimate user experience where Python frameworks might fall short.


# main.py (Kivy app for iOS)
import json
import requests
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.slider import Slider
from kivy.uix.label import Label
from kivy.properties import BooleanProperty, NumericProperty, StringProperty, ListProperty
from kivy.clock import Clock
from kivy.network.urlrequest import UrlRequest # For HTTP requests
from websocket import create_connection # pip install websocket-client

# Replace with your backend URL
BACKEND_URL = "http://YOUR_BACKEND_IP:5000"
WEBSOCKET_URL = "ws://YOUR_BACKEND_IP:5000"

class HueLightController(BoxLayout):
    is_surface_visible = BooleanProperty(False)
    selected_light_name = StringProperty("No Light Selected")
    selected_light_brightness = NumericProperty(0.0)
    selected_light_hue = NumericProperty(0.0)
    selected_light_saturation = NumericProperty(0.0)
    lights_list = ListProperty([])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.orientation = 'vertical'
        self.spacing = 10
        self.padding = 10
        self.ws = None
        self.selected_light_id = None
        self.build_ui()
        self.connect_to_websocket()
        Clock.schedule_once(self.fetch_lights, 1) # Fetch lights after UI is built

    def build_ui(self):
        # Main content
        self.add_widget(Label(text="Tap anywhere to surface controls", size_hint_y=0.1))
        self.main_content_area = BoxLayout(orientation='vertical')
        self.lights_display = Label(text="Loading lights...", size_hint_y=0.8)
        self.main_content_area.add_widget(self.lights_display)
        self.add_widget(self.main_content_area)

        # "Tap to Surface" Overlay
        self.surface_layout = BoxLayout(
            orientation='vertical',
            size_hint=(0.8, 0.8),
            pos_hint={'center_x': 0.5, 'center_y': 0.5},
            opacity=0,
            disabled=True # Disabled when not visible
        )
        self.surface_layout.add_widget(Label(text="Hue Controls", size_hint_y=0.2))
        self.surface_layout.add_widget(Label(text=self.selected_light_name, size_hint_y=0.1, id='light_name_label'))

        brightness_slider = Slider(min=0, max=1, value=self.selected_light_brightness, size_hint_y=0.2)
        brightness_slider.bind(value=self.on_brightness_change)
        self.surface_layout.add_widget(brightness_slider)

        hue_slider = Slider(min=0, max=1, value=self.selected_light_hue, size_hint_y=0.2)
        hue_slider.bind(value=self.on_hue_change)
        self.surface_layout.add_widget(hue_slider)

        saturation_slider = Slider(min=0, max=1, value=self.selected_light_saturation, size_hint_y=0.2)
        saturation_slider.bind(value=self.on_saturation_change)
        self.surface_layout.add_widget(saturation_slider)

        close_button = Button(text="Close Controls", size_hint_y=0.2)
        close_button.bind(on_press=self.toggle_surface)
        self.surface_layout.add_widget(close_button)

        self.add_widget(self.surface_layout)

    def on_touch_down(self, touch):
        # Simple tap to toggle surface visibility
        if self.collide_point(*touch.pos):
            if not self.is_surface_visible and not self.surface_layout.collide_point(*touch.pos):
                self.toggle_surface()
                return True
            elif self.is_surface_visible and self.surface_layout.collide_point(*touch.pos):
                # Allow interaction with controls if surface is visible
                return super().on_touch_down(touch)
            elif self.is_surface_visible and not self.surface_layout.collide_point(*touch.pos):
                 self.toggle_surface() # Tap outside to close
                 return True
        return super().on_touch_down(touch)

    def toggle_surface(self, *args):
        self.is_surface_visible = not self.is_surface_visible
        if self.is_surface_visible:
            self.surface_layout.opacity = 1
            self.surface_layout.disabled = False
            # Send a "tapToSurfaceTriggered" message to the backend
            if self.ws and self.ws.connected:
                self.ws.send(json.dumps({"type": "tapToSurfaceTriggered"}))
        else:
            self.surface_layout.opacity = 0
            self.surface_layout.disabled = True

    def fetch_lights(self, dt):
        print("Fetching lights...")
        req = UrlRequest(f"{BACKEND_URL}/api/lights", on_success=self.on_lights_fetched, on_failure=self.on_request_error, on_error=self.on_request_error)

    def on_lights_fetched(self, request, result):
        self.lights_list = result
        light_names = [light['name'] for light in result]
        self.lights_display.text = "Available Lights:\n" + "\n".join(light_names)
        if result:
            self.selected_light_id = result[0]['id']
            self.selected_light_name = result[0]['name']
            self.selected_light_brightness = result[0]['brightness']
            self.selected_light_hue = result[0]['hue']
            self.selected_light_saturation = result[0]['saturation']
            # Update the label in the surface layout
            self.surface_layout.ids.light_name_label.text = self.selected_light_name


    def on_request_error(self, request, error):
        print(f"Request failed: {error}")
        self.lights_display.text = f"Error fetching lights: {error}"

    def connect_to_websocket(self):
        try:
            self.ws = create_connection(WEBSOCKET_URL)
            print("WebSocket connected.")
            Clock.schedule_interval(self.websocket_read_loop, 0.1) # Read messages periodically
        except Exception as e:
            print(f"WebSocket connection failed: {e}")

    def websocket_read_loop(self, dt):
        if self.ws and self.ws.connected:
            try:
                result = self.ws.recv()
                data = json.loads(result)
                self.handle_websocket_message(data)
            except Exception as e:
                # print(f"No new WS message or WS error: {e}") # Suppress if no message
                pass
        else:
            # Attempt to reconnect if disconnected
            print("WebSocket disconnected, attempting to reconnect...")
            self.connect_to_websocket()


    def handle_websocket_message(self, data):
        print(f"WS message received: {data}")
        if data.get('type') == 'lightStateUpdated':
            light_id = data['lightId']
            new_state = data['newState']
            if light_id == self.selected_light_id:
                if 'on' in new_state: self.selected_light_brightness = new_state['brightness'] if 'brightness' in new_state else self.selected_light_brightness
                if 'brightness' in new_state: self.selected_light_brightness = new_state['brightness']
                if 'hue' in new_state: self.selected_light_hue = new_state['hue']
                if 'saturation' in new_state: self.selected_light_saturation = new_state['saturation']
                # Update UI elements
                self.surface_layout.children[2].value = self.selected_light_brightness # Assuming order
                self.surface_layout.children[1].value = self.selected_light_hue
                self.surface_layout.children[0].value = self.selected_light_saturation
        elif data.get('type') == 'backcoverLEDUpdated':
            print(f"Backcover LED updated to color: {data['color']}")
            # You could update a visual representation of the backcover here if desired
        elif data.get('type') == 'error':
            print(f"Backend error: {data['message']}")


    def send_light_command(self, state_key, value):
        if self.ws and self.ws.connected and self.selected_light_id:
            payload = {
                "type": "setLightState",
                "lightId": self.selected_light_id,
                "state": {state_key: value}
            }
            self.ws.send(json.dumps(payload))

            # Also send to backcover if it's related
            if state_key == 'hue' or state_key == 'saturation':
                # Map hue/saturation to RGB for backcover
                # This is a simplified conversion. Actual conversion is complex.
                # For demo, just send a representative color based on hue.
                r, g, b = self._hue_to_rgb(self.selected_light_hue, self.selected_light_saturation, self.selected_light_brightness)
                self.send_backcover_command(r, g, b)


    def on_brightness_change(self, instance, value):
        self.selected_light_brightness = value
        self.send_light_command('brightness', value)

    def on_hue_change(self, instance, value):
        self.selected_light_hue = value
        self.send_light_command('hue', value)

    def on_saturation_change(self, instance, value):
        self.selected_light_saturation = value
        self.send_light_command('saturation', value)

    def send_backcover_command(self, r, g, b):
        if self.ws and self.ws.connected:
            payload = {
                "type": "updateBackcoverLED",
                "color": {"r": r, "g": g, "b": b}
            }
            self.ws.send(json.dumps(payload))

    def _hue_to_rgb(self, h, s, v):
        # A simple, approximate HSL/HSV to RGB conversion for visualization.
        # For accurate Hue behavior, you'd use the Hue API's color capabilities.
        h_deg = h * 360
        s_val = s
        v_val = v # using brightness as value for now

        if s_val == 0:
            return v_val, v_val, v_val # achromatic
        i = int(h_deg / 60) % 6
        f = (h_deg / 60) - i
        p = v_val * (1 - s_val)
        q = v_val * (1 - f * s_val)
        t = v_val * (1 - (1 - f) * s_val)

        if i == 0: return v_val, t, p
        if i == 1: return q, v_val, p
        if i == 2: return p, v_val, t
        if i == 3: return p, q, v_val
        if i == 4: return t, p, v_val
        if i == 5: return v_val, p, q
        return 0,0,0 # Should not reach here

class HueApp(App):
    def build(self):
        return HueLightController()

if __name__ == '__main__':
    HueApp().run()



# app.py (BeeWare app for iOS) - Conceptual, BLE part would need more advanced Toga/platform integration
import asyncio
import toga
from toga.style import Pack
from toga.style.pack import COLUMN, ROW
import json
import httpx # pip install httpx for async HTTP
import websockets # pip install websockets for async WS

# Replace with your backend URL
BACKEND_URL = "http://YOUR_BACKEND_IP:5000"
WEBSOCKET_URL = "ws://YOUR_BACKEND_IP:5000"

class HueLightControlApp(toga.App):
    def startup(self):
        self.main_window = toga.MainWindow(title=self.formal_name)
        self.ws = None
        self.selected_light_id = None
        self.lights_data = []

        # Main UI
        main_box = toga.Box(style=Pack(direction=COLUMN, padding=10))

        self.status_label = toga.Label("Loading lights...", style=Pack(flex=1))
        main_box.add(self.status_label)

        self.tap_area = toga.Button(
            "Tap to Surface Controls",
            on_press=self.toggle_surface,
            style=Pack(flex=1, background_color='lightblue')
        )
        main_box.add(self.tap_area)

        # "Tap to Surface" Overlay (a modal dialog or another window)
        self.surface_box = toga.Box(
            style=Pack(direction=COLUMN, padding=20, background_color='lightgray')
        )
        self.surface_box.add(toga.Label("Hue Light Controls", style=Pack(font_size=20)))
        self.selected_light_name_label = toga.Label("No Light Selected", style=Pack(font_size=16))
        self.surface_box.add(self.selected_light_name_label)

        self.brightness_slider = toga.Slider(range=(0, 1), on_change=self.on_brightness_change)
        self.surface_box.add(toga.Box(children=[toga.Label("Brightness:"), self.brightness_slider], style=Pack(direction=ROW)))

        self.hue_slider = toga.Slider(range=(0, 1), on_change=self.on_hue_change)
        self.surface_box.add(toga.Box(children=[toga.Label("Hue:"), self.hue_slider], style=Pack(direction=ROW)))

        self.saturation_slider = toga.Slider(range=(0, 1), on_change=self.on_saturation_change)
        self.surface_box.add(toga.Box(children=[toga.Label("Saturation:"), self.saturation_slider], style=Pack(direction=ROW)))

        close_button = toga.Button("Close Controls", on_press=self.toggle_surface)
        self.surface_box.add(close_button)

        self.main_window.content = main_box
        self.main_window.show()

        # Start background tasks
        self.add_background_task(self.fetch_lights_task)
        self.add_background_task(self.connect_to_websocket_task)


    async def fetch_lights_task(self, app):
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(f"{BACKEND_URL}/api/lights")
                response.raise_for_status()
                self.lights_data = response.json()
                light_names = [light['name'] for light in self.lights_data]
                self.status_label.text = "Available Lights:\n" + "\n".join(light_names)
                if self.lights_data:
                    # Select first light by default
                    self.selected_light_id = self.lights_data[0]['id']
                    self.selected_light_name_label.text = self.lights_data[0]['name']
                    self.brightness_slider.value = self.lights_data[0]['brightness']
                    self.hue_slider.value = self.lights_data[0]['hue']
                    self.saturation_slider.value = self.lights_data[0]['saturation']
        except httpx.HTTPStatusError as e:
            self.status_label.text = f"HTTP Error fetching lights: {e}"
            print(f"HTTP Error fetching lights: {e}")
        except Exception as e:
            self.status_label.text = f"Error fetching lights: {e}"
            print(f"Error fetching lights: {e}")

    async def connect_to_websocket_task(self, app):
        while True:
            try:
                print("Attempting WebSocket connection...")
                async with websockets.connect(WEBSOCKET_URL) as ws:
                    self.ws = ws
                    print("WebSocket connected.")
                    await self.websocket_listen_loop(ws)
            except Exception as e:
                print(f"WebSocket connection failed: {e}. Retrying in 5 seconds...")
                await asyncio.sleep(5)

    async def websocket_listen_loop(self, ws):
        try:
            async for message in ws:
                data = json.loads(message)
                self.handle_websocket_message(data)
        except websockets.exceptions.ConnectionClosedOK:
            print("WebSocket closed normally.")
        except Exception as e:
            print(f"WebSocket error in listen loop: {e}")
        finally:
            self.ws = None # Mark as disconnected


    def handle_websocket_message(self, data):
        print(f"WS message received: {data}")
        self.app.main_window.show_message_dialog("WS Message", str(data)) # For debugging on device

        if data.get('type') == 'lightStateUpdated':
            light_id = data['lightId']
            new_state = data['newState']
            if light_id == self.selected_light_id:
                if 'brightness' in new_state: self.brightness_slider.value = new_state['brightness']
                if 'hue' in new_state: self.hue_slider.value = new_state['hue']
                if 'saturation' in new_state: self.saturation_slider.value = new_state['saturation']
        elif data.get('type') == 'backcoverLEDUpdated':
            print(f"Backcover LED updated to color: {data['color']}")
        elif data.get('type') == 'error':
            self.app.main_window.show_error_dialog("Backend Error", data['message'])

    async def send_websocket_message(self, payload):
        if self.ws and self.ws.connected:
            try:
                await self.ws.send(json.dumps(payload))
            except Exception as e:
                print(f"Failed to send WS message: {e}")
                self.app.main_window.show_error_dialog("WS Send Error", f"Failed to send command: {e}")
        else:
            print("WebSocket not connected. Cannot send message.")
            self.app.main_window.show_error_dialog("WS Error", "Not connected to backend.")

    def toggle_surface(self, widget):
        if self.main_window.content == self.main_window._impl.container: # If main content is visible
            self.main_window.content = self.surface_box
            # Send tap to surface trigger to backend
            asyncio.create_task(self.send_websocket_message({"type": "tapToSurfaceTriggered"}))
        else:
            self.main_window.content = self.main_window._impl.container # Go back to main content

    def on_brightness_change(self, slider):
        asyncio.create_task(self.send_light_command('brightness', slider.value))

    def on_hue_change(self, slider):
        asyncio.create_task(self.send_light_command('hue', slider.value))
        # Also send to backcover if it's related
        r, g, b = self._hue_to_rgb(self.hue_slider.value, self.saturation_slider.value, self.brightness_slider.value)
        asyncio.create_task(self.send_backcover_command(r, g, b))

    def on_saturation_change(self, slider):
        asyncio.create_task(self.send_light_command('saturation', slider.value))
        r, g, b = self._hue_to_rgb(self.hue_slider.value, self.saturation_slider.value, self.brightness_slider.value)
        asyncio.create_task(self.send_backcover_command(r, g, b))

    async def send_light_command(self, state_key, value):
        if self.selected_light_id:
            payload = {
                "type": "setLightState",
                "lightId": self.selected_light_id,
                "state": {state_key: value}
            }
            await self.send_websocket_message(payload)

    async def send_backcover_command(self, r, g, b):
        payload = {
            "type": "updateBackcoverLED",
            "color": {"r": r, "g": g, "b": b}
        }
        await self.send_websocket_message(payload)

    def _hue_to_rgb(self, h, s, v):
        # Simplified conversion - implement full logic for accuracy
        h_deg = h * 360
        s_val = s
        v_val = v
        # ... (same logic as in Kivy example)
        return h, s, v # Placeholder, return actual RGB

def main():
    return HueLightControlApp('Hue Control', 'com.example.huecontrol')

if __name__ == '__main__':
    main().main_loop()




npx react-native init HueLedApp
cd HueLedApp
npm install react-native-gesture-handler react-native-reanimated @react-navigation/native @react-navigation/stack
npm install @react-native-community/netinfo # For network status (optional)
npm install react-native-ble-plx # For BLE integration (if needed)
# Don't forget to link native modules: npx pod-install (for iOS)



// App.js
import 'react-native-gesture-handler'; // Must be imported at the top
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import HomeScreen from './screens/HomeScreen';
import LightDetailScreen from './screens/LightDetailScreen';
import { HueProvider } from './context/HueContext';

const Stack = createStackNavigator();

function App() {
  return (
    <HueProvider>
      <NavigationContainer>
        <Stack.Navigator initialRouteName="Home">
          <Stack.Screen name="Home" component={HomeScreen} options={{ headerShown: false }} />
          <Stack.Screen name="LightDetail" component={LightDetailScreen} options={{ title: 'Light Controls' }} />
        </Stack.Navigator>
      </NavigationContainer>
    </HueProvider>
  );
}

export default App;



// context/HueContext.js
import React, { createContext, useState, useEffect, useContext, useRef } from 'react';
import { Alert } from 'react-native';
import WebSocket from 'react-native-websocket'; // If you're using this library
import { BleManager } from 'react-native-ble-plx'; // For direct BLE control on device

// Replace with your backend URL
const BACKEND_HTTP_URL = 'http://YOUR_BACKEND_IP:5000';
const BACKEND_WS_URL = 'ws://YOUR_BACKEND_IP:5000';

const HueContext = createContext();

export const HueProvider = ({ children }) => {
  const [lights, setLights] = useState([]);
  const [selectedLight, setSelectedLight] = useState(null);
  const [backcoverColor, setBackcoverColor] = useState({ r: 0, g: 0, b: 0 }); // Current color of backcover LED
  const wsRef = useRef(null);
  const bleManager = useRef(new BleManager()).current; // For BLE-PLX

  // --- WebSocket Communication ---
  const connectWebSocket = () => {
    wsRef.current = new WebSocket(BACKEND_WS_URL);

    wsRef.current.onopen = () => {
      console.log('WebSocket Connected!');
      // Request initial light data
      wsRef.current.send(JSON.stringify({ type: 'getLights' }));
    };

    wsRef.current.onmessage = (event) => {
      const data = JSON.parse(event.data);
      console.log('WS Message:', data);
      switch (data.type) {
        case 'lightsList':
          setLights(data.lights);
          break;
        case 'lightStateUpdated':
          setLights(prevLights =>
            prevLights.map(light =>
              light.id === data.lightId ? { ...light, ...data.newState } : light
            )
          );
          if (selectedLight && selectedLight.id === data.lightId) {
              setSelectedLight(prev => ({...prev, ...data.newState}));
              // Also update backcover LED if it's following the selected light's color
              if (data.newState.hue !== undefined || data.newState.saturation !== undefined || data.newState.brightness !== undefined) {
                  const updatedLight = lights.find(l => l.id === data.lightId) || { ...selectedLight, ...data.newState };
                  const { r, g, b } = hueToRgb(
                      updatedLight.hue !== undefined ? updatedLight.hue : 0,
                      updatedLight.saturation !== undefined ? updatedLight.saturation : 0,
                      updatedLight.brightness !== undefined ? updatedLight.brightness : 0
                  );
                  updateBackcoverLED(r, g, b);
              }
          }
          break;
        case 'backcoverLEDUpdated':
            setBackcoverColor(data.color);
            break;
        case 'error':
          Alert.alert('Backend Error', data.message);
          break;
        default:
          console.warn('Unknown WS message type:', data.type);
      }
    };

    wsRef.current.onerror = (e) => {
      console.error('WebSocket Error:', e.message);
    };

    wsRef.current.onclose = (e) => {
      console.log('WebSocket Closed:', e.code, e.reason);
      // Attempt to reconnect
      setTimeout(connectWebSocket, 5000);
    };
  };

  useEffect(() => {
    connectWebSocket();
    return () => {
      wsRef.current?.close();
    };
  }, []);

  const sendWsMessage = (message) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket not open. Message not sent:', message);
      Alert.alert('Connection Issue', 'Not connected to backend. Please try again.');
    }
  };

  // --- Hue Light Control Actions ---
  const updateLightState = (lightId, newState) => {
    sendWsMessage({ type: 'setLightState', lightId, state: newState });
  };

  // --- Backcover LED Control Actions (via Backend OR Direct BLE) ---
  const updateBackcoverLED = (r, g, b) => {
      // Option 1: Send to Backend (recommended for most setups)
      sendWsMessage({ type: 'updateBackcoverLED', color: { r, g, b } });

      // Option 2: Direct BLE control (more complex, app directly controls hardware)
      // This would require more sophisticated BLE setup and characteristic writes here.
      // E.g., bleManager.writeCharacteristicWithoutResponse(...)
  };


  // --- Helper: Hue (0-1) to RGB (0-1) conversion for backcover visualization ---
  const hueToRgb = (h, s, v) => {
    let r, g, b;
    h *= 360; // Convert to degrees
    const i = Math.floor(h / 60);
    const f = h / 60 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0: r = v, g = t, b = p; break;
      case 1: r = q, g = v, b = p; break;
      case 2: r = p, g = v, b = t; break;
      case 3: r = p, g = q, b = v; break;
      case 4: r = t, g = p, b = v; break;
      case 5: r = v, g = p, b = q; break;
    }
    return { r: r, g: g, b: b };
  };

  // --- BLE Initialization (if doing direct control from app) ---
  const BACKCOVER_SERVICE_UUID = 'YOUR_CUSTOM_SERVICE_UUID'; // e.g., "0000180A-0000-1000-8000-00805F9B34FB"
  const BACKCOVER_CHAR_UUID = 'YOUR_CUSTOM_CHARACTERISTIC_UUID'; // e.g., "00002A57-0000-1000-8000-00805F9B34FB"
  const [backcoverDevice, setBackcoverDevice] = useState(null);

  useEffect(() => {
    const scanAndConnect = async () => {
      bleManager.onStateChange((state) => {
        if (state === 'PoweredOn') {
          console.log('BLE Powered On, scanning...');
          bleManager.startDeviceScan([BACKCOVER_SERVICE_UUID], null, (error, device) => {
            if (error) {
              console.error('BLE Scan Error:', error);
              return;
            }
            if (device.name && device.name.includes('MyBackcoverLED')) { // Or check by UUID
              console.log('Found Backcover LED:', device.name);
              bleManager.stopDeviceScan();
              device.connect()
                .then((device) => {
                  console.log('Connected to Backcover LED');
                  setBackcoverDevice(device);
                  return device.discoverAllServicesAndCharacteristics();
                })
                .then((device) => {
                  return device.characteristicsForService(BACKCOVER_SERVICE_UUID);
                })
                .then((characteristics) => {
                  const backcoverCharacteristic = characteristics.find(char => char.uuid.toLowerCase() === BACKCOVER_CHAR_UUID.toLowerCase());
                  if (backcoverCharacteristic) {
                    // You can now write to this characteristic
                    console.log('Found Backcover LED Characteristic');
                    // Example: Send a test color (red)
                    // backcoverCharacteristic.writeWithoutResponse(Buffer.from([255, 0, 0]).toString('base64'));
                  }
                })
                .catch((error) => console.error('BLE Connection Error:', error));
            }
          });
        } else {
          console.log('BLE State:', state);
        }
      }, true);
    };

    // Uncomment and implement if you want direct BLE control from the app
    // scanAndConnect();

    return () => {
      bleManager.destroy();
    };
  }, []);

  // Function to send direct BLE command (if doing direct control)
  const sendBackcoverBleCommand = async (r, g, b) => {
    if (backcoverDevice) {
      try {
        const characteristics = await backcoverDevice.characteristicsForService(BACKCOVER_SERVICE_UUID);
        const backcoverCharacteristic = characteristics.find(char => char.uuid.toLowerCase() === BACKCOVER_CHAR_UUID.toLowerCase());
        if (backcoverCharacteristic) {
          const data = Buffer.from([Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)]).toString('base64');
          await backcoverCharacteristic.writeWithoutResponse(data);
          setBackcoverColor({r, g, b}); // Update local state for visualization
          console.log('Sent direct BLE color command.');
        }
      } catch (error) {
        console.error('Failed to send direct BLE command:', error);
        Alert.alert('BLE Error', `Failed to control backcover: ${error.message}`);
      }
    } else {
        console.warn('Backcover BLE device not connected for direct control.');
    }
  };


  return (
    <HueContext.Provider
      value={{
        lights,
        selectedLight,
        setSelectedLight,
        updateLightState,
        updateBackcoverLED, // For backend-proxied control
        backcoverColor,
        sendTapToSurfaceTrigger: () => sendWsMessage({ type: 'tapToSurfaceTriggered' }),
        // For direct BLE control:
        // sendBackcoverBleCommand,
        // isBackcoverConnected: !!backcoverDevice,
      }}
    >
      {children}
    </HueContext.Provider>
  );
};

export const useHue = () => useContext(HueContext);



// screens/HomeScreen.js
import React, { useRef, useState, useEffect } from 'react';
import { View, Text, StyleSheet, TouchableWithoutFeedback, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  FadeIn,
  FadeOut,
  SlideInUp,
  SlideOutDown,
  runOnJS,
} from 'react-native-reanimated';
import { useNavigation } from '@react-navigation/native';
import { useHue } from '../context/HueContext';
import LightControlSurface from '../components/LightControlSurface';

const { height, width } = Dimensions.get('window');

function HomeScreen() {
  const navigation = useNavigation();
  const { lights, selectedLight, setSelectedLight, sendTapToSurfaceTrigger, backcoverColor } = useHue();
  const surfaceVisible = useSharedValue(0); // 0: hidden, 1: visible

  // State to manage actual visibility for rendering performance
  const [isSurfaceMounted, setIsSurfaceMounted] = useState(false);

  useEffect(() => {
    // Select the first light by default if available
    if (lights.length > 0 && !selectedLight) {
      setSelectedLight(lights[0]);
    }
  }, [lights, selectedLight, setSelectedLight]);


  const animatedSurfaceStyle = useAnimatedStyle(() => {
    return {
      opacity: withTiming(surfaceVisible.value, { duration: 300 }),
      transform: [
        {
          translateY: withSpring(surfaceVisible.value === 1 ? 0 : height, {
            damping: 15,
            stiffness: 100,
          }),
        },
      ],
    };
  });

  const toggleSurface = () => {
    if (surfaceVisible.value === 0) {
      setIsSurfaceMounted(true); // Mount the component when making it visible
      surfaceVisible.value = 1;
      sendTapToSurfaceTrigger(); // Notify backend of gesture
    } else {
      surfaceVisible.value = 0;
      // Unmount after animation completes
      setTimeout(() => setIsSurfaceMounted(false), 300); // Match animation duration
    }
  };

  // Simulate backcover LED color
  const backcoverStyle = {
    backgroundColor: `rgb(${backcoverColor.r * 255}, ${backcoverColor.g * 255}, ${backcoverColor.b * 255})`,
  };


  return (
    <TouchableWithoutFeedback onPress={toggleSurface}>
      <View style={styles.container}>
        {/* Simulating Backcover LED */}
        <View style={[styles.backcoverSimulator, backcoverStyle]} />

        {/* Main App Content - Represents the "front" */}
        <View style={styles.frontContent}>
          <Text style={styles.title}>Tap Anywhere for Controls</Text>
          {lights.length === 0 ? (
            <Text style={styles.statusText}>Searching for Hue lights...</Text>
          ) : (
            <>
              <Text style={styles.statusText}>
                Selected Light: {selectedLight ? selectedLight.name : 'None'}
              </Text>
              <Text style={styles.statusText}>
                Status: {selectedLight?.on ? 'On' : 'Off'}
              </Text>
            </>
          )}
          {lights.map(light => (
            <TouchableWithoutFeedback key={light.id} onPress={() => {
                setSelectedLight(light);
                Alert.alert('Light Selected', `Now controlling: ${light.name}`);
                // Immediately show surface when a light is explicitly selected
                if (surfaceVisible.value === 0) {
                    toggleSurface();
                }
            }}>
                <View style={styles.lightListItem}>
                    <Text style={styles.lightName}>{light.name}</Text>
                    <View style={[styles.lightIndicator, { backgroundColor: light.on ? 'green' : 'gray' }]} />
                </View>
            </TouchableWithoutFeedback>
          ))}
        </View>

        {/* "Tap to Surface" Controls Overlay */}
        {isSurfaceMounted && (
          <Animated.View style={[StyleSheet.absoluteFill, styles.surfaceOverlay, animatedSurfaceStyle]}>
            <LightControlSurface
              selectedLight={selectedLight}
              onClose={toggleSurface}
            />
          </Animated.View>
        )}
      </View>
    </TouchableWithoutFeedback>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#333',
    justifyContent: 'center',
    alignItems: 'center',
  },
  backcoverSimulator: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    // This will be dynamic based on `backcoverColor`
  },
  frontContent: {
    flex: 1,
    width: '100%',
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(0,0,0,0.7)', // Overlay to make text readable over backcover
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 20,
  },
  statusText: {
    fontSize: 18,
    color: 'lightgray',
    marginBottom: 10,
  },
  lightListItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    width: '80%',
    padding: 10,
    backgroundColor: '#555',
    borderRadius: 8,
    marginVertical: 5,
  },
  lightName: {
    color: 'white',
    fontSize: 16,
  },
  lightIndicator: {
    width: 20,
    height: 20,
    borderRadius: 10,
  },
  surfaceOverlay: {
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    borderRadius: 20,
    overflow: 'hidden', // Ensures content stays within bounds during animation
  },
});

export default HomeScreen;



// components/LightControlSurface.js
import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, Button, Dimensions } from 'react-native';
import Slider from '@react-native-community/slider'; // npm install @react-native-community/slider
import { useHue } from '../context/HueContext';
import { PanGestureHandler } from 'react-native-gesture-handler';
import Animated, {
  useAnimatedGestureHandler,
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';

const { height, width } = Dimensions.get('window');

function LightControlSurface({ selectedLight, onClose }) {
  const { updateLightState, updateBackcoverLED } = useHue();

  const [brightness, setBrightness] = useState(selectedLight?.brightness || 0);
  const [hue, setHue] = useState(selectedLight?.hue || 0);
  const [saturation, setSaturation] = useState(selectedLight?.saturation || 0);
  const [isOn, setIsOn] = useState(selectedLight?.on || false);

  useEffect(() => {
    if (selectedLight) {
      setBrightness(selectedLight.brightness || 0);
      setHue(selectedLight.hue || 0);
      setSaturation(selectedLight.saturation || 0);
      setIsOn(selectedLight.on || false);
    }
  }, [selectedLight]);

  const handleBrightnessChange = (value) => {
    setBrightness(value);
    if (selectedLight) {
      updateLightState(selectedLight.id, { brightness: value, on: value > 0 });
      // Update backcover LED with current color
      const {r,g,b} = hueToRgb(hue, saturation, value);
      updateBackcoverLED(r,g,b);
    }
  };

  const handleHueChange = (value) => {
    setHue(value);
    if (selectedLight) {
      updateLightState(selectedLight.id, { hue: value });
      const {r,g,b} = hueToRgb(value, saturation, brightness);
      updateBackcoverLED(r,g,b);
    }
  };

  const handleSaturationChange = (value) => {
    setSaturation(value);
    if (selectedLight) {
      updateLightState(selectedLight.id, { saturation: value });
      const {r,g,b} = hueToRgb(hue, value, brightness);
      updateBackcoverLED(r,g,b);
    }
  };

  const togglePower = () => {
    const newState = !isOn;
    setIsOn(newState);
    if (selectedLight) {
      updateLightState(selectedLight.id, { on: newState });
      // If turning off, set backcover to black
      if (!newState) {
          updateBackcoverLED(0,0,0);
      } else {
          // If turning on, restore current light's color
          const {r,g,b} = hueToRgb(hue, saturation, brightness);
          updateBackcoverLED(r,g,b);
      }
    }
  };

  // Helper: Hue (0-1) to RGB (0-1) conversion for backcover visualization
  const hueToRgb = (h, s, v) => {
    let r, g, b;
    h *= 360; // Convert to degrees
    const i = Math.floor(h / 60);
    const f = h / 60 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0: r = v, g = t, b = p; break;
      case 1: r = q, g = v, b = p; break;
      case 2: r = p, g = v, b = t; break;
      case 3: r = p, g = q, b = v; break;
      case 4: r = t, g = p, b = v; break;
      case 5: r = v, g = p, b = q; break;
    }
    return { r: r, g: g, b: b };
  };


  // For drag gesture to dismiss or move surface (optional)
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);

  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, ctx) => {
      ctx.startX = translateX.value;
      ctx.startY = translateY.value;
    },
    onActive: (event, ctx) => {
      translateX.value = ctx.startX + event.translationX;
      translateY.value = ctx.startY + event.translationY;
    },
    onEnd: (event) => {
      if (event.translationY > height / 4 || Math.abs(event.translationX) > width / 3) {
        // Dismiss if dragged far enough
        runOnJS(onClose)();
      } else {
        // Snap back
        translateX.value = withSpring(0);
        translateY.value = withSpring(0);
      }
    },
  });

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
      ],
    };
  });


  return (
    <PanGestureHandler onGestureEvent={gestureHandler}>
      <Animated.View style={[styles.surfaceContainer, animatedStyle]}>
        <Text style={styles.surfaceTitle}>
          {selectedLight ? selectedLight.name : 'Select a Light'}
        </Text>

        <View style={styles.controlRow}>
          <Text style={styles.controlLabel}>Power:</Text>
          <Button title={isOn ? 'Turn Off' : 'Turn On'} onPress={togglePower} />
        </View>

        <View style={styles.controlRow}>
          <Text style={styles.controlLabel}>Brightness:</Text>
          <Slider
            style={styles.slider}
            minimumValue={0}
            maximumValue={1}
            value={brightness}
            onSlidingComplete={handleBrightnessChange}
            minimumTrackTintColor="#FFF"
            maximumTrackTintColor="#AAA"
            thumbTintColor="#FFF"
          />
        </View>

        <View style={styles.controlRow}>
          <Text style={styles.controlLabel}>Hue:</Text>
          <Slider
            style={styles.slider}
            minimumValue={0}
            maximumValue={1}
            value={hue}
            onSlidingComplete={handleHueChange}
            minimumTrackTintColor="red" // Visual aid
            maximumTrackTintColor="blue"
            thumbTintColor="#FFF"
          />
        </View>

        <View style={styles.controlRow}>
          <Text style={styles.controlLabel}>Saturation:</Text>
          <Slider
            style={styles.slider}
            minimumValue={0}
            maximumValue={1}
            value={saturation}
            onSlidingComplete={handleSaturationChange}
            minimumTrackTintColor="gray"
            maximumTrackTintColor="white"
            thumbTintColor="#FFF"
          />
        </View>

        <Button title="Close" onPress={onClose} color="#841584" />
      </Animated.View>
    </PanGestureHandler>
  );
}

const styles = StyleSheet.create({
  surfaceContainer: {
    width: '90%',
    height: 'auto', // Adjust based on content
    backgroundColor: 'rgba(50, 50, 50, 0.95)',
    borderRadius: 20,
    padding: 25,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 5 },
    shadowOpacity: 0.8,
    shadowRadius: 10,
    elevation: 10,
  },
  surfaceTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: 'white',
    marginBottom: 20,
  },
  controlRow: {
    flexDirection: 'row',
    alignItems: 'center',
    width: '100%',
    marginBottom: 15,
  },
  controlLabel: {
    fontSize: 18,
    color: 'lightgray',
    marginRight: 10,
    width: 100,
  },
  slider: {
    flex: 1,
    height: 40,
  },
});

export default LightControlSurface;





// HueWidget.swift (in your Widget Extension target)
import WidgetKit
import SwiftUI
import AppIntents // For interactive widgets iOS 16+

// MARK: - App Group for Shared Data
// IMPORTANT: You MUST set up an App Group for your main React Native app and this Widget Extension
// In Xcode: Select your main app target -> Signing & Capabilities -> + Capability -> App Groups
// Add a group like "group.com.yourcompany.HueLedApp"
// Do the same for your Widget Extension target.

struct SharedDefaults {
    static let suiteName = "group.com.yourcompany.HueLedApp"
    static var shared: UserDefaults {
        return UserDefaults(suiteName: SharedDefaults.suiteName)!
    }
}

// MARK: - Timeline Entry
struct HueLightEntry: TimelineEntry {
    let date: Date
    let lightName: String
    let isOn: Bool
    let brightness: Double
    let hueColor: Color // Represents light color
}

// MARK: - Timeline Provider
struct HueLightProvider: TimelineProvider {
    func placeholder(in context: Context) -> HueLightEntry {
        HueLightEntry(date: Date(), lightName: "Loading Light", isOn: false, brightness: 0, hueColor: .gray)
    }

    func getSnapshot(in context: Context, completion: @escaping (HueLightEntry) -> Void) {
        // Fetch current status, quickly
        fetchLightStatus { (name, on, brightness, hue, sat) in
            let color = Color(hue: hue, saturation: sat, brightness: brightness)
            let entry = HueLightEntry(date: Date(), lightName: name, isOn: on, brightness: brightness, hueColor: color)
            completion(entry)
        }
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<HueLightEntry>) -> Void) {
        fetchLightStatus { (name, on, brightness, hue, sat) in
            let currentDate = Date()
            let color = Color(hue: hue, saturation: sat, brightness: brightness)
            let entry = HueLightEntry(date: currentDate, lightName: name, isOn: on, brightness: brightness, hueColor: color)

            // Reload timeline every 15 minutes, or on demand
            let nextUpdateDate = Calendar.current.date(byAdding: .minute, value: 15, to: currentDate)!
            let timeline = Timeline(entries: [entry], policy: .atEnd)
            completion(timeline)
        }
    }

    // Function to fetch light status (from UserDefaults or Backend)
    func fetchLightStatus(completion: @escaping (String, Bool, Double, Double, Double) -> Void) {
        // Option 1: Read from App Group UserDefaults (React Native app writes here)
        let name = SharedDefaults.shared.string(forKey: "widgetLightName") ?? "Living Room"
        let on = SharedDefaults.shared.bool(forKey: "widgetLightOn")
        let brightness = SharedDefaults.shared.double(forKey: "widgetLightBrightness")
        let hue = SharedDefaults.shared.double(forKey: "widgetLightHue")
        let saturation = SharedDefaults.shared.double(forKey: "widgetLightSaturation")
        completion(name, on, brightness, hue, saturation)

        // Option 2: Directly call your backend API (more reliable for fresh data)
        // This requires network access in widgets (check capabilities)
        /*
        guard let url = URL(string: "http://YOUR_BACKEND_IP:5000/api/widget-status") else {
            completion("Error", false, 0, 0, 0)
            return
        }
        URLSession.shared.dataTask(with: url) { data, response, error in
            if let data = data {
                if let lights = try? JSONDecoder().decode([LightStatus].self, from: data), let firstLight = lights.first {
                    DispatchQueue.main.async {
                         completion(firstLight.name, firstLight.on, firstLight.brightness, firstLight.hue, firstLight.saturation)
                    }
                } else {
                    completion("Parse Error", false, 0, 0, 0)
                }
            } else {
                completion("Network Error", false, 0, 0, 0)
            }
        }.resume()
        */
    }
}

// Struct for decoding backend response if calling directly
struct LightStatus: Codable {
    let id: String
    let name: String
    let on: Bool
    let brightness: Double
    let hue: Double
    let saturation: Double
}


// MARK: - Widget View
struct HueLightWidgetView: View {
    var entry: HueLightProvider.Entry

    var body: some View {
        VStack(alignment: .leading) {
            Text(entry.lightName)
                .font(.headline)
                .foregroundStyle(.primary)
            HStack {
                Circle()
                    .fill(entry.hueColor)
                    .frame(width: 20, height: 20)
                Text(entry.isOn ? "On" : "Off")
                    .font(.subheadline)
                    .foregroundStyle(entry.isOn ? .green : .red)
            }
            if entry.isOn {
                ProgressView(value: entry.brightness)
                    .tint(entry.hueColor)
            } else {
                ProgressView(value: 0)
                    .tint(.gray)
            }

            // iOS 16+ interactive button example
            if #available(iOS 16.0, *) {
                Button(intent: ToggleLightIntent(lightId: "1", lightName: entry.lightName)) {
                    Label(entry.isOn ? "Turn Off" : "Turn On", systemImage: entry.isOn ? "lightbulb.fill" : "lightbulb")
                        .font(.caption)
                }
                .buttonStyle(.bordered)
            }
        }
        .containerBackground(for: .widget) {
            Color.black.opacity(0.8)
        }
    }
}

// MARK: - Interactive Widget Intent (iOS 16+)
@available(iOS 16.0, *)
struct ToggleLightIntent: AppIntent {
    static var title: LocalizedStringResource = "Toggle Light"
    static var description: IntentDescription? = "Toggles the power state of a Hue light."

    @Parameter(title: "Light ID")
    var lightId: String

    @Parameter(title: "Light Name")
    var lightName: String

    init() {} // Default init for AppIntents

    init(lightId: String, lightName: String) {
        self.lightId = lightId
        self.lightName = lightName
    }

    func perform() async throws -> some IntentResult {
        // Option 1: Send command directly to backend
        guard let url = URL(string: "http://YOUR_BACKEND_IP:5000/api/lights/\(lightId)/state") else {
            throw AppIntentError.invalidParameter(lightId, "Invalid Light ID URL")
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Read current state to toggle
        // This is a simplification; ideally, you'd fetch the current state first
        let currentOnStatus = SharedDefaults.shared.bool(forKey: "widgetLightOn")
        let newState = !currentOnStatus

        let body: [String: Any] = ["on": newState]
        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        let (_, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw AppIntentError.processingFailed("Failed to toggle light.")
        }

        // After successful toggle, trigger widget reload
        WidgetCenter.shared.reloadAllTimelines()

        return .result()
    }
}


// MARK: - Widget Bundle
@main
struct HueWidgetBundle: WidgetBundle {
    var body: some Widget {
        HueLightWidget()
    }
}

struct HueLightWidget: Widget {
    let kind: String = "HueLightWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: HueLightProvider()) { entry in
            HueLightWidgetView(entry: entry)
                .containerBackground(for: .widget) {
                    // This is iOS 17+ specific way to apply background
                    Color.black.opacity(0.8)
                }
        }
        .configurationDisplayName("Hue Quick Control")
        .description("View light status and toggle power.")
        .supportedFamilies([.systemSmall, .systemMedium]) // Define widget sizes
    }
}



// AppDelegate.m (after other imports)
#import <React/RCTRootView.h> // Ensure this is imported

// ... in your application:didFinishLaunchingWithOptions: method
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  // ... existing React Native setup

  // Example: Write some initial data to the App Group UserDefaults
  NSUserDefaults *sharedDefaults = [[NSUserDefaults alloc] initWithSuiteName:@"group.com.yourcompany.HueLedApp"];
  [sharedDefaults setBool:NO forKey:@"widgetLightOn"];
  [sharedDefaults setObject:@"Default Light" forKey:@"widgetLightName"];
  [sharedDefaults setDouble:0.0 forKey:@"widgetLightBrightness"];
  [sharedDefaults setDouble:0.0 forKey:@"widgetLightHue"];
  [sharedDefaults setDouble:0.0 forKey:@"widgetLightSaturation"];
  [sharedDefaults synchronize]; // Save changes

  // ... rest of your existing React Native setup
  return YES;
}


// Function to update App Group UserDefaults for the widget
import { NativeModules } from 'react-native';

const updateWidgetData = (light) => {
  // Use NativeModules or a custom native bridge if directly writing from JS isn't working
  // For simplicity, we assume the backend is the source of truth for widgets.
  // If you want RN to update widget directly, you need a NativeModule.

  // Example of a NativeModule method (you'd create this in Objective-C/Swift)
  // NativeModules.SharedDefaultsManager.updateLightStatus(
  //   light.name, light.on, light.brightness, light.hue, light.saturation
  // );

  // Or, rely on the widget making its own calls to your backend HTTP API for status.
  // Then you'd trigger a widget refresh via APNs (complex) or simply reloadAllTimelines().
  // WidgetCenter.shared.reloadAllTimelines() is available via NativeModules or deep linking.
};

// Call `updateWidgetData` whenever `selectedLight` or its status changes
// E.g., in `updateLightState` in HueContext.js:
/*
  const updateLightState = (lightId, newState) => {
    sendWsMessage({ type: 'setLightState', lightId, state: newState });
    // Find the updated light and pass to native module for widget
    const updatedLight = lights.find(light => light.id === lightId);
    if (updatedLight) {
        updateWidgetData({...updatedLight, ...newState}); // Merge new state
    }
  };
*/



// HueController.h
#pragma once

#include <string>
#include <vector>
#include <map>
#include <functional>
#include <mutex>

// Forward declarations for networking if used directly in C++
// #include <boost/asio/io_context.hpp>
// #include <websocketpp/client.hpp>
// #include <websocketpp/config/asio_client.hpp>

// Define structs for light data (similar to JSON structure from backend)
struct LightState {
    bool on = false;
    double brightness = 0.0; // 0.0 - 1.0
    double hue = 0.0;        // 0.0 - 1.0
    double saturation = 0.0; // 0.0 - 1.0

    // Constructor for convenience
    LightState(bool _on = false, double _bri = 0.0, double _hue = 0.0, double _sat = 0.0)
        : on(_on), brightness(_bri), hue(_hue), saturation(_sat) {}
};

struct LightInfo {
    std::string id;
    std::string name;
    LightState state;
    bool reachable = false;
};

// Callback types for communicating with the Objective-C/Swift UI
using LightListCallback = std::function<void(const std::vector<LightInfo>&)>;
using LightStateUpdateCallback = std::function<void(const std::string& lightId, const LightState& newState)>;
using BackcoverColorUpdateCallback = std::function<void(double r, double g, double b)>;
using ErrorCallback = std::function<void(const std::string& errorMessage)>;


class HueController {
public:
    // Singleton pattern if only one instance is needed
    static HueController& getInstance();
    HueController(const HueController&) = delete;
    HueController& operator=(const HueController&) = delete;

    // Call this from Objective-C/Swift to initialize
    void initialize(const std::string& backendHttpUrl, const std::string& backendWsUrl);

    // Callbacks to set from Objective-C/Swift
    void setCallbacks(
        LightListCallback lightListCb,
        LightStateUpdateCallback lightStateCb,
        BackcoverColorUpdateCallback backcoverColorCb,
        ErrorCallback errorCb
    );

    // Public API for Objective-C/Swift to call
    void fetchLights();
    void setLightState(const std::string& lightId, const LightState& newState);
    void updateBackcoverLED(double r, double g, double b); // r,g,b in 0.0-1.0 range
    void sendTapToSurfaceTrigger(); // Notify backend of UI gesture

private:
    HueController(); // Private constructor for singleton
    ~HueController();

    std::string backendHttpUrl_;
    std::string backendWsUrl_;

    std::vector<LightInfo> currentLights_;
    std::mutex lightsMutex_; // For thread-safe access to currentLights_

    // Callbacks held by the controller to notify Objective-C/Swift
    LightListCallback lightListCallback_;
    LightStateUpdateCallback lightStateUpdateCallback_;
    BackcoverColorUpdateCallback backcoverColorUpdateCallback_;
    ErrorCallback errorCallback_;

    // --- Internal Networking Methods ---
    // Example with placeholder `sendHttpRequest` and `setupWebSocket`
    // In a real implementation, these would use a proper C++ networking library.
    void sendHttpRequest(const std::string& url, const std::string& method, const std::string& body = "");
    void setupWebSocket();
    void processWebSocketMessage(const std::string& message);

    // --- Utility ---
    // Simple HSL to RGB conversion (can be optimized)
    void HSLtoRGB(double h, double s, double l, double& r, double& g, double& b);

    // Networking context (e.g., for Boost.Asio or WebSocket++)
    // boost::asio::io_context ioContext_;
    // websocketpp::client<websocketpp::config::asio_tls_client> wsClient_; // Or plain asio_client
    // websocketpp::connection_hdl wsConnectionHdl_;
    // std::thread wsThread_;
    // bool wsConnected_ = false;
};




// HueController.cpp
#include "HueController.h"
#include <iostream> // For logging
#include <thread>   // For WebSocket thread (if using blocking API)
#include <chrono>   // For sleep (demonstration)

// You'd include actual networking and JSON parsing libraries here
// #include <nlohmann/json.hpp> // For JSON parsing (pip install nlohmann_json.hpp)
// #include <httplib.h> // For HTTP client (if using)

HueController& HueController::getInstance() {
    static HueController instance;
    return instance;
}

HueController::HueController() {
    // Constructor initializes internal state
    std::cout << "HueController C++ initialized." << std::endl;
}

HueController::~HueController() {
    // Clean up resources, close connections
    // if (wsThread_.joinable()) {
    //     ioContext_.stop();
    //     wsThread_.join();
    // }
    std::cout << "HueController C++ destroyed." << std::endl;
}

void HueController::initialize(const std::string& backendHttpUrl, const std::string& backendWsUrl) {
    backendHttpUrl_ = backendHttpUrl;
    backendWsUrl_ = backendWsUrl;
    // Start WebSocket connection in a background thread
    setupWebSocket();
}

void HueController::setCallbacks(
    LightListCallback lightListCb,
    LightStateUpdateCallback lightStateCb,
    BackcoverColorUpdateCallback backcoverColorCb,
    ErrorCallback errorCb
) {
    lightListCallback_ = lightListCb;
    lightStateUpdateCallback_ = lightStateCb;
    backcoverColorUpdateCallback_ = backcoverColorCb;
    errorCallback_ = errorCb;
}

void HueController::fetchLights() {
    std::cout << "C++: Fetching lights via HTTP from " << backendHttpUrl_ << "/api/lights" << std::endl;
    // In a real app, this would be an async HTTP GET request.
    // On success: parse JSON, update currentLights_, then call lightListCallback_.
    // On error: call errorCallback_.

    // Simulate async network request
    std::thread([this]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Simulate network delay

        std::lock_guard<std::mutex> lock(lightsMutex_);
        currentLights_ = {
            {"1", "Living Room", LightState(true, 0.8, 0.1, 0.9), true},
            {"2", "Kitchen", LightState(false, 0.0, 0.0, 0.0), true}
        };

        if (lightListCallback_) {
            lightListCallback_(currentLights_);
        } else {
            std::cerr << "C++: LightListCallback not set!" << std::endl;
        }
    }).detach();
}

void HueController::setLightState(const std::string& lightId, const LightState& newState) {
    std::cout << "C++: Setting state for light " << lightId << ": On=" << newState.on
              << ", Bri=" << newState.brightness << ", Hue=" << newState.hue
              << ", Sat=" << newState.saturation << std::endl;

    // This would send a WebSocket message or HTTP POST request to the backend.
    // Example WebSocket payload (would need JSON serialization):
    /*
    {
        "type": "setLightState",
        "lightId": "1",
        "state": {
            "on": true,
            "brightness": 0.8,
            "hue": 0.5,
            "saturation": 0.7
        }
    }
    */
    // For demo, just trigger callback as if backend confirmed.
    std::thread([this, lightId, newState]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(200)); // Simulate backend response

        // Update internal state
        std::lock_guard<std::mutex> lock(lightsMutex_);
        for (auto& light : currentLights_) {
            if (light.id == lightId) {
                light.state = newState;
                break;
            }
        }

        if (lightStateUpdateCallback_) {
            lightStateUpdateCallback_(lightId, newState);
        }
    }).detach();
}

void HueController::updateBackcoverLED(double r, double g, double b) {
    std::cout << "C++: Updating backcover LED to R:" << r << ", G:" << g << ", B:" << b << std::endl;
    // This would send a WebSocket message to the backend.
    /*
    {
        "type": "updateBackcoverLED",
        "color": {"r": r, "g": g, "b": b}
    }
    */
    // For demo, just trigger callback.
    if (backcoverColorUpdateCallback_) {
        backcoverColorUpdateCallback_(r, g, b);
    }
}

void HueController::sendTapToSurfaceTrigger() {
    std::cout << "C++: Sending 'tapToSurfaceTriggered' to backend." << std::endl;
    // Send WebSocket message: {"type": "tapToSurfaceTriggered"}
    // This would ideally trigger some action on the backend (e.g., scene change).
}

void HueController::setupWebSocket() {
    std::cout << "C++: Setting up WebSocket connection to " << backendWsUrl_ << std::endl;
    // This is where you'd use a C++ WebSocket client library (e.g., websocketpp)
    // - Establish connection
    // - Set message handler (to call processWebSocketMessage)
    // - Set error handler
    // - Run in a separate thread (if blocking)

    // For demonstration, simulate messages coming from backend
    std::thread([this]() {
        while (true) { // Keep connection "alive"
            std::this_thread::sleep_for(std::chrono::seconds(5)); // Simulate periodic updates
            // Example: A light state changes on the backend (e.g., by another user)
            // or the backcover LED confirms its state.
            std::string simulatedMessage = R"({"type": "lightStateUpdated", "lightId": "1", "newState": {"on": true, "brightness": 0.9, "hue": 0.2, "saturation": 0.8}})";
            // For a real scenario, the backend would actually send these messages.
            processWebSocketMessage(simulatedMessage);
        }
    }).detach();
}

void HueController::processWebSocketMessage(const std::string& message) {
    std::cout << "C++: Received WS message: " << message << std::endl;
    // Parse the JSON message here (using nlohmann/json or similar)
    // Example:
    /*
    nlohmann::json jsonMessage = nlohmann::json::parse(message);
    std::string type = jsonMessage.at("type").get<std::string>();

    if (type == "lightStateUpdated") {
        std::string lightId = jsonMessage.at("lightId").get<std::string>();
        nlohmann::json newStateJson = jsonMessage.at("newState");
        LightState newState;
        if (newStateJson.count("on")) newState.on = newStateJson.at("on").get<bool>();
        if (newStateJson.count("brightness")) newState.brightness = newStateJson.at("brightness").get<double>();
        if (newStateJson.count("hue")) newState.hue = newStateJson.at("hue").get<double>();
        if (newStateJson.count("saturation")) newState.saturation = newStateJson.at("saturation").get<double>();

        // Update internal state
        std::lock_guard<std::mutex> lock(lightsMutex_);
        for (auto& light : currentLights_) {
            if (light.id == lightId) {
                light.state = newState;
                break;
            }
        }
        if (lightStateUpdateCallback_) {
            lightStateUpdateCallback_(lightId, newState);
        }
    } else if (type == "backcoverLEDUpdated") {
        nlohmann::json colorJson = jsonMessage.at("color");
        double r = colorJson.at("r").get<double>();
        double g = colorJson.at("g").get<double>();
        double b = colorJson.at("b").get<double>();
        if (backcoverColorUpdateCallback_) {
            backcoverColorUpdateCallback_(r, g, b);
        }
    } else if (type == "error") {
        std::string errorMessage = jsonMessage.at("message").get<std::string>();
        if (errorCallback_) {
            errorCallback_(errorMessage);
        }
    }
    */
}

void HueController::HSLtoRGB(double h, double s, double l, double& r, double& g, double& b) {
    // This is a simplified placeholder. A full HSL/HSV to RGB conversion
    // is more involved. This one assumes HSL, but Hue API typically provides HSV.
    // For proper Hue color handling, you'd use their color space (XY, CT, HSV).
    if (s == 0) {
        r = g = b = l; // achromatic
    } else {
        auto hue2rgb = [](double p, double q, double t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1.0/6) return p + (q - p) * 6 * t;
            if (t < 1.0/2) return q;
            if (t < 2.0/3) return p + (q - p) * (2.0/3 - t) * 6;
            return p;
        };

        double q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        double p = 2 * l - q;
        r = hue2rgb(p, q, h + 1.0/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1.0/3);
    }
}



// HueControllerBridge.h
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h> // For UIColor or Color conversion

@class LightInfoObjectiveC; // Forward declare for convenience

// Define protocols for callbacks
@protocol HueControllerDelegate <NSObject>
@required
- (void)didReceiveLightList:(NSArray<LightInfoObjectiveC*>* _Nonnull)lights;
- (void)didUpdateLightState:(NSString* _Nonnull)lightId newState:(NSDictionary* _Nonnull)newState;
- (void)didUpdateBackcoverColorWithR:(CGFloat)r G:(CGFloat)g B:(CGFloat)b;
- (void)didReceiveError:(NSString* _Nonnull)errorMessage;
@end

@interface HueControllerBridge : NSObject

@property (nonatomic, weak, nullable) id<HueControllerDelegate> delegate;

+ (instancetype _Nonnull)sharedInstance; // Singleton access

- (void)initializeWithBackendHttpUrl:(NSString* _Nonnull)httpUrl backendWsUrl:(NSString* _Nonnull)wsUrl;
- (void)fetchLights;
- (void)setLightWithId:(NSString* _Nonnull)lightId on:(BOOL)on brightness:(CGFloat)brightness hue:(CGFloat)hue saturation:(CGFloat)saturation;
- (void)updateBackcoverLEDWithR:(CGFloat)r G:(CGFloat)g B:(CGFloat)b;
- (void)sendTapToSurfaceTrigger;

@end

// Helper class to represent light info in Objective-C/Swift
@interface LightInfoObjectiveC : NSObject
@property (nonatomic, copy) NSString* _Nonnull lightId;
@property (nonatomic, copy) NSString* _Nonnull name;
@property (nonatomic, assign) BOOL on;
@property (nonatomic, assign) CGFloat brightness;
@property (nonatomic, assign) CGFloat hue;
@property (nonatomic, assign) CGFloat saturation;
@property (nonatomic, assign) BOOL reachable;
@end




// HueControllerBridge.mm
#import "HueControllerBridge.h"
#include "HueController.h" // Include your C++ header

@implementation LightInfoObjectiveC
// Synthesize properties if needed (ARC handles this typically)
@end

@implementation HueControllerBridge

+ (instancetype)sharedInstance {
    static HueControllerBridge *sharedBridge = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedBridge = [[self alloc] init];
    });
    return sharedBridge;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        // Set up C++ callbacks
        HueController::getInstance().setCallbacks(
            [weakSelf = self](const std::vector<LightInfo>& lights) {
                if (weakSelf.delegate && [weakSelf.delegate respondsToSelector:@selector(didReceiveLightList:)]) {
                    NSMutableArray<LightInfoObjectiveC*>* objcLights = [NSMutableArray array];
                    for (const auto& light : lights) {
                        LightInfoObjectiveC* objcLight = [[LightInfoObjectiveC alloc] init];
                        objcLight.lightId = [NSString stringWithUTF8String:light.id.c_str()];
                        objcLight.name = [NSString stringWithUTF8String:light.name.c_str()];
                        objcLight.on = light.state.on;
                        objcLight.brightness = light.state.brightness;
                        objcLight.hue = light.state.hue;
                        objcLight.saturation = light.state.saturation;
                        objcLight.reachable = light.reachable;
                        [objcLights addObject:objcLight];
                    }
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [weakSelf.delegate didReceiveLightList:objcLights];
                    });
                }
            },
            [weakSelf = self](const std::string& lightId, const LightState& newState) {
                if (weakSelf.delegate && [weakSelf.delegate respondsToSelector:@selector(didUpdateLightState:newState:)]) {
                    // Convert C++ state to NSDictionary for Objective-C/Swift
                    NSDictionary* objcState = @{
                        @"on": @(newState.on),
                        @"brightness": @(newState.brightness),
                        @"hue": @(newState.hue),
                        @"saturation": @(newState.saturation)
                    };
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [weakSelf.delegate didUpdateLightState:[NSString stringWithUTF8String:lightId.c_str()] newState:objcState];
                    });
                }
            },
            [weakSelf = self](double r, double g, double b) {
                if (weakSelf.delegate && [weakSelf.delegate respondsToSelector:@selector(didUpdateBackcoverColorWithR:G:B:)]) {
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [weakSelf.delegate didUpdateBackcoverColorWithR:r G:g B:b];
                    });
                }
            },
            [weakSelf = self](const std::string& errorMessage) {
                if (weakSelf.delegate && [weakSelf.delegate respondsToSelector:@selector(didReceiveError:)]) {
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [weakSelf.delegate didReceiveError:[NSString stringWithUTF8String:errorMessage.c_str()]];
                    });
                }
            }
        );
    }
    return self;
}

- (void)initializeWithBackendHttpUrl:(NSString *)httpUrl backendWsUrl:(NSString *)wsUrl {
    HueController::getInstance().initialize(
        [httpUrl UTF8String],
        [wsUrl UTF8String]
    );
}

- (void)fetchLights {
    HueController::getInstance().fetchLights();
}

- (void)setLightWithId:(NSString *)lightId on:(BOOL)on brightness:(CGFloat)brightness hue:(CGFloat)hue saturation:(CGFloat)saturation {
    LightState newState(on, brightness, hue, saturation);
    HueController::getInstance().setLightState([lightId UTF8String], newState);
}

- (void)updateBackcoverLEDWithR:(CGFloat)r G:(CGFloat)g B:(CGFloat)b {
    HueController::getInstance().updateBackcoverLED(r, g, b);
}

- (void)sendTapToSurfaceTrigger {
    HueController::getInstance().sendTapToSurfaceTrigger();
}

@end



// ViewController.swift or a SwiftUI View (example for UIKit, similar for SwiftUI)
import UIKit
import SwiftUI // If using SwiftUI views inside UIKit controller
// Import the bridging header
// If using a Bridging Header, just #import "HueControllerBridge.h" in your project's Bridging-Header.h
// If direct import:
// #import <YourCppFramework/HueControllerBridge.h> // If you built a framework

class HueControlViewController: UIViewController, HueControllerDelegate {

    // UI elements
    let statusLabel = UILabel()
    let lightNameLabel = UILabel()
    let brightnessSlider = UISlider()
    let hueSlider = UISlider()
    let saturationSlider = UISlider()
    let powerButton = UIButton(type: .system)

    var currentSelectedLight: LightInfoObjectiveC? {
        didSet {
            updateUIForSelectedLight()
        }
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        setupGestures()

        // Initialize the C++ controller bridge
        HueControllerBridge.sharedInstance().delegate = self
        HueControllerBridge.sharedInstance().initialize(
            withBackendHttpUrl: "http://YOUR_BACKEND_IP:5000",
            backendWsUrl: "ws://YOUR_BACKEND_IP:5000"
        )
        HueControllerBridge.sharedInstance().fetchLights()
    }

    func setupUI() {
        // Basic setup for demonstration
        statusLabel.text = "Loading..."
        statusLabel.textAlignment = .center
        statusLabel.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(statusLabel)

        // Add other UI components (sliders, buttons) and constraints
        // ... (This is standard UIKit/SwiftUI layout)

        brightnessSlider.addTarget(self, action: #selector(brightnessChanged), for: .valueChanged)
        hueSlider.addTarget(self, action: #selector(hueChanged), for: .valueChanged)
        saturationSlider.addTarget(self, action: #selector(saturationChanged), for: .valueChanged)
        powerButton.addTarget(self, action: #selector(togglePower), for: .touchUpInside)

        // Add a "backcover" simulator view
        let backcoverSimulator = UIView()
        backcoverSimulator.backgroundColor = .black
        backcoverSimulator.tag = 100 // To find it later for color updates
        backcoverSimulator.translatesAutoresizingMaskIntoConstraints = false
        view.insertSubview(backcoverSimulator, at: 0) // Behind other content
        NSLayoutConstraint.activate([
            backcoverSimulator.topAnchor.constraint(equalTo: view.topAnchor),
            backcoverSimulator.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            backcoverSimulator.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            backcoverSimulator.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }

    func setupGestures() {
        // Implement "tap to surface" gesture
        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleTapToSurface))
        view.addGestureRecognizer(tapGesture)
    }

    @objc func handleTapToSurface() {
        print("UI: Tap to surface detected!")
        // Trigger animation for surfacing controls
        // ... (use UIView.animate or SwiftUI animations)

        // Notify C++ logic
        HueControllerBridge.sharedInstance().sendTapToSurfaceTrigger()

        // Example: toggle visibility of an overlay view
        // if let overlay = view.viewWithTag(99) { overlay.isHidden.toggle() }
    }

    func updateUIForSelectedLight() {
        if let light = currentSelectedLight {
            lightNameLabel.text = light.name
            brightnessSlider.value = Float(light.brightness)
            hueSlider.value = Float(light.hue)
            saturationSlider.value = Float(light.saturation)
            powerButton.setTitle(light.on ? "Turn Off" : "Turn On", for: .normal)
            statusLabel.text = "Controlling: \(light.name)"
        } else {
            lightNameLabel.text = "No Light Selected"
            // Reset sliders/buttons
        }
    }

    @objc func brightnessChanged() {
        if let light = currentSelectedLight {
            HueControllerBridge.sharedInstance().setLight(
                with: light.lightId,
                on: light.on,
                brightness: CGFloat(brightnessSlider.value),
                hue: light.hue,
                saturation: light.saturation
            )
        }
    }

    @objc func hueChanged() {
        if let light = currentSelectedLight {
            HueControllerBridge.sharedInstance().setLight(
                with: light.lightId,
                on: light.on,
                brightness: light.brightness,
                hue: CGFloat(hueSlider.value),
                saturation: light.saturation
            )
        }
    }

    @objc func saturationChanged() {
        if let light = currentSelectedLight {
            HueControllerBridge.sharedInstance().setLight(
                with: light.lightId,
                on: light.on,
                brightness: light.brightness,
                hue: light.hue,
                saturation: CGFloat(saturationSlider.value)
            )
        }
    }

    @objc func togglePower() {
        if let light = currentSelectedLight {
            HueControllerBridge.sharedInstance().setLight(
                with: light.lightId,
                on: !light.on, // Toggle state
                brightness: light.brightness,
                hue: light.hue,
                saturation: light.saturation
            )
        }
    }

    // MARK: - HueControllerDelegate methods (Called by C++ via bridge)
    func didReceiveLightList(_ lights: [LightInfoObjectiveC]) {
        print("UI: Received light list from C++: \(lights.map { $0.name })")
        if let firstLight = lights.first {
            currentSelectedLight = firstLight
        }
        // Update a UITableView/UICollectionView or SwiftUI List here
    }

    func didUpdateLightState(_ lightId: String, newState: [AnyHashable : Any]) {
        print("UI: Light \(lightId) state updated from C++: \(newState)")
        if lightId == currentSelectedLight?.lightId {
            // Update currentSelectedLight properties from newState dictionary
            if let on = newState["on"] as? Bool { currentSelectedLight?.on = on }
            if let brightness = newState["brightness"] as? CGFloat { currentSelectedLight?.brightness = brightness }
            if let hue = newState["hue"] as? CGFloat { currentSelectedLight?.hue = hue }
            if let saturation = newState["saturation"] as? CGFloat { currentSelectedLight?.saturation = saturation }
            updateUIForSelectedLight() // Refresh UI
        }
    }

    func didUpdateBackcoverColor(withR r: CGFloat, G g: CGFloat, B b: CGFloat) {
        print("UI: Backcover color updated from C++: R:\(r) G:\(g) B:\(b)")
        // Update the "backcover" simulator view's background color
        if let backcoverSimulator = view.viewWithTag(100) {
            UIView.animate(withDuration: 0.2) {
                backcoverSimulator.backgroundColor = UIColor(red: r, green: g, blue: b, alpha: 1.0)
            }
        }
    }

    func didReceiveError(_ errorMessage: String) {
        print("UI: Error from C++: \(errorMessage)")
        // Show alert to user
        let alert = UIAlertController(title: "Error", message: errorMessage, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
        present(alert, animated: true, completion: nil)
    }
}




import tensorflow as tf
from tensorflow import keras
import numpy as np
import os

# --- Configuration ---
SEQUENCE_LENGTH = 50  # Number of sensor readings in one gesture window
NUM_FEATURES = 6      # acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z
NUM_CLASSES = 3       # e.g., 0: 'No Gesture', 1: 'Tap to Surface', 2: 'Double Tap'
MODEL_DIR = 'gesture_models'
TFLITE_MODEL_PATH = os.path.join(MODEL_DIR, 'gesture_classifier.tflite')

os.makedirs(MODEL_DIR, exist_ok=True)

# --- 1. Simulate Data Generation (Replace with your actual collected data) ---
# In a real scenario, you would load your labeled sensor data from files (e.g., CSV, numpy arrays)
def generate_synthetic_data(num_samples_per_class):
    X = [] # Features (sensor sequences)
    y = [] # Labels

    # Class 0: No Gesture (random noise)
    for _ in range(num_samples_per_class):
        data = np.random.rand(SEQUENCE_LENGTH, NUM_FEATURES) * 0.1 # Small random noise
        X.append(data)
        y.append(0)

    # Class 1: Tap to Surface (a quick peak in accelerometer, then settle)
    for _ in range(num_samples_per_class):
        data = np.random.rand(SEQUENCE_LENGTH, NUM_FEATURES) * 0.05 # Baseline noise
        tap_peak_idx = np.random.randint(10, SEQUENCE_LENGTH - 10)
        data[tap_peak_idx-2:tap_peak_idx+3, 0] += np.random.uniform(0.5, 2.0) # Accel X peak
        data[tap_peak_idx-2:tap_peak_idx+3, 1] += np.random.uniform(0.5, 2.0) # Accel Y peak
        data[tap_peak_idx-2:tap_peak_idx+3, 2] += np.random.uniform(0.5, 2.0) # Accel Z peak
        X.append(data)
        y.append(1)

    # Class 2: Double Tap (two quick peaks)
    for _ in range(num_samples_per_class):
        data = np.random.rand(SEQUENCE_LENGTH, NUM_FEATURES) * 0.05
        tap1_peak_idx = np.random.randint(5, SEQUENCE_LENGTH // 2 - 5)
        tap2_peak_idx = np.random.randint(SEQUENCE_LENGTH // 2 + 5, SEQUENCE_LENGTH - 5)

        data[tap1_peak_idx-2:tap1_peak_idx+3, 0] += np.random.uniform(0.5, 2.0)
        data[tap1_peak_idx-2:tap1_peak_idx+3, 1] += np.random.uniform(0.5, 2.0)
        data[tap1_peak_idx-2:tap1_peak_idx+3, 2] += np.random.uniform(0.5, 2.0)

        data[tap2_peak_idx-2:tap2_peak_idx+3, 0] += np.random.uniform(0.5, 2.0)
        data[tap2_peak_idx-2:tap2_peak_idx+3, 1] += np.random.uniform(0.5, 2.0)
        data[tap2_peak_idx-2:tap2_peak_idx+3, 2] += np.random.uniform(0.5, 2.0)
        X.append(data)
        y.append(2)

    X = np.array(X, dtype=np.float32)
    y = keras.utils.to_categorical(np.array(y), num_classes=NUM_CLASSES)
    return X, y

print("Generating synthetic data...")
X_train, y_train = generate_synthetic_data(num_samples_per_class=1000)
X_test, y_test = generate_synthetic_data(num_samples_per_class=200)

print(f"X_train shape: {X_train.shape}, y_train shape: {y_train.shape}")
print(f"X_test shape: {X_test.shape}, y_test shape: {y_test.shape}")

# --- 2. Build the Model (A simple 1D Convolutional Neural Network) ---
print("Building the Keras model...")
model = keras.Sequential([
    keras.layers.Input(shape=(SEQUENCE_LENGTH, NUM_FEATURES)),
    keras.layers.Conv1D(filters=32, kernel_size=3, activation='relu'),
    keras.layers.MaxPooling1D(pool_size=2),
    keras.layers.Flatten(),
    keras.layers.Dense(64, activation='relu'),
    keras.layers.Dropout(0.3),
    keras.layers.Dense(NUM_CLASSES, activation='softmax') # Output layer for classification
])

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.summary()

# --- 3. Train the Model ---
print("Training the model...")
history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.2)

# --- 4. Evaluate the Model ---
print("Evaluating the model...")
loss, accuracy = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# --- 5. Convert to TensorFlow Lite Model ---
print("Converting model to TensorFlow Lite...")
converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.optimizations = [tf.lite.Optimize.DEFAULT] # Optimize for size and performance
tflite_model = converter.convert()

with open(TFLITE_MODEL_PATH, 'wb') as f:
    f.write(tflite_model)

print(f"TensorFlow Lite model saved to: {TFLITE_MODEL_PATH}")

# --- Optional: Test TFLite model inference (on host) ---
print("Testing TFLite model inference...")
interpreter = tf.lite.Interpreter(model_path=TFLITE_MODEL_PATH)
interpreter.allocate_tensors()

input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

# Get a sample from the test set
sample_input = X_test[0:1]
true_label = np.argmax(y_test[0])

interpreter.set_tensor(input_details[0]['index'], sample_input)
interpreter.invoke()
output_data = interpreter.get_tensor(output_details[0]['index'])

predicted_class = np.argmax(output_data[0])
print(f"Sample Input Shape: {sample_input.shape}")
print(f"TFLite Prediction Raw: {output_data[0]}")
print(f"Predicted Class: {predicted_class} (True Class: {true_label})")



// GestureClassifier.swift
import Foundation
import CoreMotion // For Accelerometer and Gyroscope
import TensorFlowLite // For TensorFlow Lite inference

enum GestureType: Int, CaseIterable {
    case noGesture = 0
    case tapToSurface = 1
    case doubleTap = 2 // Example
    // Add more as per your model's output classes

    var description: String {
        switch self {
        case .noGesture: return "No Gesture"
        case .tapToSurface: return "Tap to Surface"
        case .doubleTap: return "Double Tap"
        }
    }
}

protocol GestureClassifierDelegate: AnyObject {
    func gestureClassifier(_ classifier: GestureClassifier, didDetectGesture gesture: GestureType, confidence: Float)
    func gestureClassifier(_ classifier: GestureClassifier, didEncounterError error: Error)
}

class GestureClassifier: NSObject {
    weak var delegate: GestureClassifierDelegate?

    private let motionManager = CMMotionManager()
    private let queue = OperationQueue()
    private var sensorDataBuffer: [(accelX: Double, accelY: Double, accelZ: Double, gyroX: Double, gyroY: Double, gyroZ: Double)] = []
    private let sequenceLength = 50 // Must match Python model's SEQUENCE_LENGTH
    private let numFeatures = 6     // Must match Python model's NUM_FEATURES
    private let inferenceInterval: TimeInterval = 0.5 // How often to run inference
    private var lastInferenceTime: Date = Date.distantPast

    private var interpreter: Interpreter?

    init(modelPath: String) {
        super.init()
        loadModel(modelPath: modelPath)
        setupMotionUpdates()
    }

    private func loadModel(modelPath: String) {
        do {
            interpreter = try Interpreter(modelPath: modelPath)
            try interpreter?.allocateTensors()
            print("TensorFlow Lite model loaded and tensors allocated.")
        } catch {
            print("Failed to load or allocate tensors for TFLite model: \(error)")
            delegate?.gestureClassifier(self, didEncounterError: error)
        }
    }

    private func setupMotionUpdates() {
        guard motionManager.isAccelerometerAvailable, motionManager.isGyroAvailable else {
            print("Accelerometer or Gyroscope not available.")
            delegate?.gestureClassifier(self, didEncounterError:
                NSError(domain: "GestureClassifierError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Motion sensors not available."]))
            return
        }

        motionManager.accelerometerUpdateInterval = 0.02 // 50 Hz (1/50 = 0.02)
        motionManager.gyroUpdateInterval = 0.02

        motionManager.startAccelerometerUpdates(to: queue) { [weak self] (accelerometerData, error) in
            guard let self = self, let accelData = accelerometerData else { return }
            self.processMotionData(accelData: accelData, gyroData: nil)
        }

        motionManager.startGyroUpdates(to: queue) { [weak self] (gyroData, error) in
            guard let self = self, let gyroData = gyroData else { return }
            self.processMotionData(accelData: nil, gyroData: gyroData)
        }
    }

    private var latestAccelData: CMAccelerometerData?
    private var latestGyroData: CMGyroData?

    private func processMotionData(accelData: CMAccelerometerData?, gyroData: CMGyroData?) {
        if let accel = accelData { latestAccelData = accel }
        if let gyro = gyroData { latestGyroData = gyro }

        guard let accel = latestAccelData, let gyro = latestGyroData else { return }

        // Store the latest combined reading
        sensorDataBuffer.append((accelX: accel.acceleration.x, accelY: accel.acceleration.y, accelZ: accel.acceleration.z,
                                 gyroX: gyro.rotationRate.x, gyroY: gyro.rotationRate.y, gyroZ: gyro.rotationRate.z))

        // Keep buffer size limited
        if sensorDataBuffer.count > sequenceLength * 2 { // Keep a bit more than needed for a window
            sensorDataBuffer.removeFirst(sensorDataBuffer.count - sequenceLength * 2)
        }

        // Run inference periodically if enough data
        if sensorDataBuffer.count >= sequenceLength && Date().timeIntervalSince(lastInferenceTime) > inferenceInterval {
            lastInferenceTime = Date()
            performInference()
        }
    }

    private func performInference() {
        guard let interpreter = interpreter else { return }

        // Create input tensor from the last `sequenceLength` readings
        let inputData = sensorDataBuffer.suffix(sequenceLength).flatMap { [$0.accelX, $0.accelY, $0.accelZ, $0.gyroX, $0.gyroY, $0.gyroZ] }

        do {
            let inputTensor = try interpreter.input(at: 0)
            let inputShape = inputTensor.shape.dimensions
            if inputShape.count != 3 || inputShape[0] != 1 || inputShape[1] != sequenceLength || inputShape[2] != numFeatures {
                print("Input tensor shape mismatch. Expected [1, \(sequenceLength), \(numFeatures)], Got \(inputShape)")
                return
            }

            // Copy data to the input tensor
            let inputBuffer = UnsafeMutableBufferPointer<Float32>.allocate(capacity: inputData.count)
            for (index, value) in inputData.enumerated() {
                inputBuffer[index] = Float32(value)
            }
            let inputDataAsTensorData = Data(buffer: inputBuffer)
            try interpreter.copy(inputDataAsTensorData, toInput: 0)
            inputBuffer.deallocate()


            // Run inference
            try interpreter.invoke()

            // Get output tensor
            let outputTensor = try interpreter.output(at: 0)
            let outputSize = outputTensor.shape.dimensions.last ?? 0 // Number of classes
            let outputBuffer = UnsafeMutableBufferPointer<Float33>.allocate(capacity: outputSize)
            let outputData = Data(bytesNoCopy: outputBuffer.baseAddress!, count: outputSize * MemoryLayout<Float32>.size, deallocator: .none)
            try outputTensor.copy(to: outputBuffer.baseAddress!, count: outputSize)
            outputBuffer.deallocate()

            // Process output
            let probabilities = (0..<outputSize).map { outputBuffer[$0] }
            if let maxConfidence = probabilities.max(), let detectedGestureIndex = probabilities.firstIndex(of: maxConfidence) {
                if let gestureType = GestureType(rawValue: detectedGestureIndex) {
                    // Only report if confidence is above a threshold and it's not "No Gesture"
                    let confidenceThreshold: Float = 0.7 // Tune this
                    if maxConfidence > confidenceThreshold && gestureType != .noGesture {
                        DispatchQueue.main.async {
                            self.delegate?.gestureClassifier(self, didDetectGesture: gestureType, confidence: maxConfidence)
                        }
                    }
                }
            }
        } catch {
            print("TensorFlow Lite inference failed: \(error)")
            delegate?.gestureClassifier(self, didEncounterError: error)
        }
    }

    func stopMotionUpdates() {
        motionManager.stopAccelerometerUpdates()
        motionManager.stopGyroUpdates()
    }
}



// ViewController.swift (UIKit example, similar for SwiftUI)
import UIKit
import Combine // For SwiftUI to manage state updates

class MainAppViewController: UIViewController, GestureClassifierDelegate {

    // UI Elements (labels, views, etc.)
    let gestureStatusLabel = UILabel()
    let backcoverSimulator = UIView() // To visualize backcover LED color
    // ... other UI for light controls

    private var gestureClassifier: GestureClassifier?
    private var currentBackcoverColor: UIColor = .black {
        didSet {
            // Animate color change
            UIView.animate(withDuration: 0.2) {
                self.backcoverSimulator.backgroundColor = self.currentBackcoverColor
            }
        }
    }

    // Combine for light data (if not using C++ bridge directly)
    @Published var currentSelectedLight: LightInfoObjectiveC? // Or a custom Swift struct
    @Published var availableLights: [LightInfoObjectiveC] = []

    private var cancellables = Set<AnyCancellable>()

    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()

        // Copy your .tflite model from the app bundle to a usable path
        if let modelPath = Bundle.main.path(forResource: "gesture_classifier", ofType: "tflite") {
            gestureClassifier = GestureClassifier(modelPath: modelPath)
            gestureClassifier?.delegate = self
        } else {
            print("Error: TFLite model not found in app bundle.")
            gestureStatusLabel.text = "Model Load Error"
        }

        // Initialize your backend communication (HTTP/WebSocket) here
        // This would connect to your backend server to control Hue and the real backcover LED
        // Example: backendApi.fetchLights()
        // Example: backendApi.setDelegate(self)
        
        // Simulate fetching lights
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            let simulatedLights: [LightInfoObjectiveC] = [
                LightInfoObjectiveC(lightId: "1", name: "Living Room", on: true, brightness: 0.7, hue: 0.1, saturation: 0.9, reachable: true),
                LightInfoObjectiveC(lightId: "2", name: "Kitchen", on: false, brightness: 0, hue: 0, saturation: 0, reachable: true)
            ]
            self.availableLights = simulatedLights
            self.currentSelectedLight = simulatedLights.first
        }
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        gestureClassifier?.stopMotionUpdates()
    }

    func setupUI() {
        view.backgroundColor = .darkGray

        // Backcover Simulator
        backcoverSimulator.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(backcoverSimulator)
        NSLayoutConstraint.activate([
            backcoverSimulator.topAnchor.constraint(equalTo: view.topAnchor),
            backcoverSimulator.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            backcoverSimulator.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            backcoverSimulator.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])

        // Gesture Status Label (on top of simulator)
        gestureStatusLabel.text = "Waiting for gesture..."
        gestureStatusLabel.textColor = .white
        gestureStatusLabel.font = .systemFont(ofSize: 24, weight: .bold)
        gestureStatusLabel.textAlignment = .center
        gestureStatusLabel.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(gestureStatusLabel)
        NSLayoutConstraint.activate([
            gestureStatusLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            gestureStatusLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor)
        ])

        // Add a transparent tap area for "Tap to Surface"
        let tapToSurfaceArea = UIButton()
        tapToSurfaceArea.backgroundColor = .clear
        tapToSurfaceArea.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(tapToSurfaceArea)
        NSLayoutConstraint.activate([
            tapToSurfaceArea.topAnchor.constraint(equalTo: view.topAnchor),
            tapToSurfaceArea.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tapToSurfaceArea.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            tapToSurfaceArea.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
        tapToSurfaceArea.addTarget(self, action: #selector(handleManualTap), for: .touchUpInside)

        // Add a simple overlay for light controls (initially hidden)
        let controlOverlay = UIView()
        controlOverlay.backgroundColor = UIColor(white: 0, alpha: 0.8)
        controlOverlay.layer.cornerRadius = 20
        controlOverlay.translatesAutoresizingMaskIntoConstraints = false
        controlOverlay.isHidden = true // Initially hidden
        controlOverlay.tag = 99 // Identifier
        view.addSubview(controlOverlay)
        NSLayoutConstraint.activate([
            controlOverlay.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            controlOverlay.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            controlOverlay.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.8),
            controlOverlay.heightAnchor.constraint(equalTo: view.heightAnchor, multiplier: 0.5)
        ])

        let closeButton = UIButton(type: .system)
        closeButton.setTitle("Close Controls", for: .normal)
        closeButton.setTitleColor(.white, for: .normal)
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        controlOverlay.addSubview(closeButton)
        NSLayoutConstraint.activate([
            closeButton.bottomAnchor.constraint(equalTo: controlOverlay.bottomAnchor, constant: -20),
            closeButton.centerXAnchor.constraint(equalTo: controlOverlay.centerXAnchor)
        ])
        closeButton.addTarget(self, action: #selector(hideControlsOverlay), for: .touchUpInside)

        // Example: Light power button inside overlay
        let lightPowerButton = UIButton(type: .system)
        lightPowerButton.setTitle("Toggle Power", for: .normal)
        lightPowerButton.setTitleColor(.white, for: .normal)
        lightPowerButton.translatesAutoresizingMaskIntoConstraints = false
        controlOverlay.addSubview(lightPowerButton)
        NSLayoutConstraint.activate([
            lightPowerButton.topAnchor.constraint(equalTo: controlOverlay.topAnchor, constant: 40),
            lightPowerButton.centerXAnchor.constraint(equalTo: controlOverlay.centerXAnchor)
        ])
        lightPowerButton.addTarget(self, action: #selector(toggleLightPower), for: .touchUpInside)

        // Set up reactive updates from published properties
        $currentSelectedLight
            .sink { [weak self] light in
                guard let self = self else { return }
                if let light = light {
                    lightPowerButton.setTitle(light.on ? "Turn Off" : "Turn On", for: .normal)
                    // Potentially update other sliders/labels
                }
            }
            .store(in: &cancellables)
    }

    @objc func handleManualTap() {
        // Manually trigger the "Tap to Surface" action, e.g., for testing
        gestureClassifier(gestureClassifier!, didDetectGesture: .tapToSurface, confidence: 1.0)
    }

    @objc func showControlsOverlay() {
        if let overlay = view.viewWithTag(99) {
            overlay.isHidden = false
            overlay.alpha = 0 // Start hidden for animation
            UIView.animate(withDuration: 0.3) {
                overlay.alpha = 1.0
            }
            // Send "tap to surface" event to backend
            // self.backendApi.sendTapToSurfaceTrigger()
        }
    }

    @objc func hideControlsOverlay() {
        if let overlay = view.viewWithTag(99) {
            UIView.animate(withDuration: 0.3, animations: {
                overlay.alpha = 0
            }) { _ in
                overlay.isHidden = true
            }
        }
    }

    @objc func toggleLightPower() {
        guard let light = currentSelectedLight else { return }
        let newOnState = !light.on
        // Call your backend API
        // backendApi.setLight(lightId: light.lightId, on: newOnState, brightness: light.brightness, hue: light.hue, saturation: light.saturation)
        
        // Simulate update
        if let index = availableLights.firstIndex(where: { $0.lightId == light.lightId }) {
            availableLights[index].on = newOnState
            currentSelectedLight = availableLights[index]
            // Also update backcover LED color based on new light state
            let lightColor = UIColor(hue: light.hue, saturation: light.saturation, brightness: light.brightness, alpha: 1.0)
            currentBackcoverColor = newOnState ? lightColor : .black
            // Call backend for backcover
            // backendApi.updateBackcoverLED(r: currentBackcoverColor.redValue, g: currentBackcoverColor.greenValue, b: currentBackcoverColor.blueValue)
        }
    }

    // MARK: - GestureClassifierDelegate
    func gestureClassifier(_ classifier: GestureClassifier, didDetectGesture gesture: GestureType, confidence: Float) {
        DispatchQueue.main.async {
            self.gestureStatusLabel.text = "\(gesture.description) (\(String(format: "%.2f", confidence * 100))%)"
            if gesture == .tapToSurface {
                self.showControlsOverlay()
                // Example: Based on confidence, decide if backcover should give haptic feedback
                // if confidence > 0.9 { triggerHapticFeedback() }
            } else if gesture == .doubleTap {
                // Example: Toggle light based on double tap
                self.toggleLightPower()
            }
        }
    }

    func gestureClassifier(_ classifier: GestureClassifier, didEncounterError error: Error) {
        DispatchQueue.main.async {
            self.gestureStatusLabel.text = "Error: \(error.localizedDescription)"
        }
    }
}

// Extension to get RGB components from UIColor (for backcover visualization)
extension UIColor {
    var redValue: CGFloat { return CIColor(color: self).red }
    var greenValue: CGFloat { return CIColor(color: self).green }
    var blueValue: CGFloat { return CIColor(color: self).blue }
    var alphaValue: CGFloat { return CIColor(color: self).alpha }

    convenience init(hue: CGFloat, saturation: CGFloat, brightness: CGFloat, alpha: CGFloat) {
        self.init(hue: hue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
}

// Mock LightInfoObjectiveC for demonstration (if not using C++ bridge directly)
class LightInfoObjectiveC: NSObject {
    var lightId: String
    var name: String
    var on: Bool
    var brightness: CGFloat
    var hue: CGFloat
    var saturation: CGFloat
    var reachable: Bool

    init(lightId: String, name: String, on: Bool, brightness: CGFloat, hue: CGFloat, saturation: CGFloat, reachable: Bool) {
        self.lightId = lightId
        self.name = name
        self.on = on
        self.brightness = brightness
        self.hue = hue
        self.saturation = saturation
        self.reachable = reachable
    }
}




# Podfile
platform :ios, '16.0' # Or your deployment target

target 'SmartHueControl' do
  use_frameworks!
  # Pods for SmartHueControl
  pod 'TensorFlowLiteSwift'
  # If you need GPU or Core ML delegates, add:
  # pod 'TensorFlowLiteSwift/Metal'
  # pod 'TensorFlowLiteSwift/CoreML'
end

# Add your Widget Extension target here later
# target 'SmartHueControlWidgetsExtension' do
#   use_frameworks!
#   pod 'TensorFlowLiteSwift' # If widget also needs TFLite
# end



// GestureClassifier.swift
import Foundation
import CoreMotion
import TensorFlowLite // Ensure this is imported

// Enum for gesture types (matches your TFLite model output)
enum GestureType: Int, CaseIterable {
    case noGesture = 0
    case tapToSurface = 1
    case doubleTap = 2
    // Add more based on your model
    var description: String {
        switch self {
        case .noGesture: return "No Gesture"
        case .tapToSurface: return "Tap to Surface"
        case .doubleTap: return "Double Tap"
        }
    }
}

protocol GestureClassifierDelegate: AnyObject {
    func gestureClassifier(_ classifier: GestureClassifier, didDetectGesture gesture: GestureType, confidence: Float)
    func gestureClassifier(_ classifier: GestureClassifier, didEncounterError error: Error)
}

class GestureClassifier: NSObject {
    weak var delegate: GestureClassifierDelegate?

    private let motionManager = CMMotionManager()
    private let queue = OperationQueue()
    private var sensorDataBuffer: [(accelX: Double, accelY: Double, accelZ: Double, gyroX: Double, gyroY: Double, gyroZ: Double)] = []
    private let sequenceLength = 50 // Matches Python training
    private let numFeatures = 6     // Matches Python training
    private let sampleRate: TimeInterval = 0.02 // 50 Hz updates
    private let inferenceInterval: TimeInterval = 0.5 // Run inference every 0.5 seconds
    private var lastInferenceTime: Date = Date.distantPast

    private var interpreter: Interpreter?

    init(modelFileName: String = "gesture_classifier", modelFileType: String = "tflite") {
        super.init()
        loadModel(fileName: modelFileName, fileType: modelFileType)
        setupMotionUpdates()
    }

    private func loadModel(fileName: String, fileType: String) {
        guard let modelPath = Bundle.main.path(forResource: fileName, ofType: fileType) else {
            let error = NSError(domain: "GestureClassifierError", code: 2, userInfo: [NSLocalizedDescriptionKey: "TFLite model not found in app bundle: \(fileName).\(fileType)"])
            print(error.localizedDescription)
            delegate?.gestureClassifier(self, didEncounterError: error)
            return
        }

        do {
            interpreter = try Interpreter(modelPath: modelPath)
            try interpreter?.allocateTensors()
            print("TensorFlow Lite model loaded and tensors allocated.")
        } catch {
            print("Failed to load or allocate tensors for TFLite model: \(error)")
            delegate?.gestureClassifier(self, didEncounterError: error)
        }
    }

    private func setupMotionUpdates() {
        // Request motion sensor permission from Info.plist (Privacy - Motion Usage Description)
        guard motionManager.isAccelerometerAvailable && motionManager.isGyroAvailable else {
            print("Accelerometer or Gyroscope not available on this device.")
            delegate?.gestureClassifier(self, didEncounterError:
                NSError(domain: "GestureClassifierError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Motion sensors not available."]))
            return
        }

        motionManager.accelerometerUpdateInterval = sampleRate
        motionManager.gyroUpdateInterval = sampleRate

        motionManager.startAccelerometerUpdates(to: queue) { [weak self] (accelerometerData, error) in
            guard let self = self, let accel = accelerometerData else { return }
            self.processSensorData(accel: accel.acceleration, gyro: nil)
        }

        motionManager.startGyroUpdates(to: queue) { [weak self] (gyroData, error) in
            guard let self = self, let gyro = gyroData else { return }
            self.processSensorData(accel: nil, gyro: gyro.rotationRate)
        }
    }

    private var latestAccel: CMAcceleration?
    private var latestGyro: CMRotationRate?

    private func processSensorData(accel: CMAcceleration?, gyro: CMRotationRate?) {
        if let accel = accel { latestAccel = accel }
        if let gyro = gyro { latestGyro = gyro }

        guard let currentAccel = latestAccel, let currentGyro = latestGyro else { return }

        // Store the latest combined reading
        sensorDataBuffer.append((accelX: currentAccel.x, accelY: currentAccel.y, accelZ: currentAccel.z,
                                 gyroX: currentGyro.x, gyroY: currentGyro.y, gyroZ: currentGyro.z))

        // Keep buffer size limited (e.g., twice the sequence length)
        if sensorDataBuffer.count > sequenceLength * 2 {
            sensorDataBuffer.removeFirst(sensorDataBuffer.count - sequenceLength * 2)
        }

        // Perform inference periodically
        if sensorDataBuffer.count >= sequenceLength && Date().timeIntervalSince(lastInferenceTime) > inferenceInterval {
            lastInferenceTime = Date()
            performInference()
        }
    }

    private func performInference() {
        guard let interpreter = interpreter else { return }

        // Prepare input data for the model (flat array of floats)
        let inputFloats = sensorDataBuffer.suffix(sequenceLength).flatMap {
            [Float($0.accelX), Float($0.accelY), Float($0.accelZ),
             Float($0.gyroX), Float($0.gyroY), Float($0.gyroZ)]
        }

        do {
            let inputTensor = try interpreter.input(at: 0)
            let inputShape = inputTensor.shape.dimensions
            // Validate input shape matches model's expected shape: [1, SEQUENCE_LENGTH, NUM_FEATURES]
            guard inputShape.count == 3 && inputShape[0] == 1 && inputShape[1] == sequenceLength && inputShape[2] == numFeatures else {
                throw NSError(domain: "GestureClassifierError", code: 3, userInfo: [NSLocalizedDescriptionKey: "Input tensor shape mismatch."])
            }

            let inputData = Data(copyingBufferOf: inputFloats)
            try interpreter.copy(inputData, toInput: 0)
            try interpreter.invoke()

            let outputTensor = try interpreter.output(at: 0)
            let outputClasses = outputTensor.shape.dimensions.last ?? 0
            let probabilities = outputTensor.data.toArray(type: Float.self)

            if let maxConfidence = probabilities.max(), let detectedGestureIndex = probabilities.firstIndex(of: maxConfidence) {
                if let gestureType = GestureType(rawValue: detectedGestureIndex) {
                    let confidenceThreshold: Float = 0.7 // Tune this threshold
                    if maxConfidence > confidenceThreshold && gestureType != .noGesture {
                        DispatchQueue.main.async {
                            self.delegate?.gestureClassifier(self, didDetectGesture: gestureType, confidence: maxConfidence)
                        }
                    }
                }
            }
        } catch {
            print("TensorFlow Lite inference failed: \(error)")
            delegate?.gestureClassifier(self, didEncounterError: error)
        }
    }

    func stopMotionUpdates() {
        motionManager.stopAccelerometerUpdates()
        motionManager.stopGyroUpdates()
    }
}

// Helper extension for Data conversion from array (can be placed in a Utilities file)
extension Data {
    init<T>(copyingBufferOf array: [T]) {
        self = array.withUnsafeBufferPointer(Data.init)
    }
}
extension Data {
    func toArray<T>(type: T.Type) -> [T] {
        return self.withUnsafeBytes { ptr in
            Array(ptr.bindMemory(to: T.self))
        }
    }
}



// SmartHomeAPIClient.swift
import Foundation
import Combine

struct Light: Identifiable, Codable {
    let id: String
    var name: String
    var isOn: Bool
    var brightness: Float // 0.0 - 1.0
    var hue: Float        // 0.0 - 1.0
    var saturation: Float // 0.0 - 1.0
    var reachable: Bool

    // Map to Hue API's hue (0-65535) and sat (0-254) and bri (0-254)
    var hueAPIValue: Int { Int(hue * 65535) }
    var saturationAPIValue: Int { Int(saturation * 254) }
    var brightnessAPIValue: Int { Int(brightness * 254) }
}

struct BackendLightState: Codable {
    let on: Bool
    let brightness: Float?
    let hue: Float?
    let saturation: Float?
}

struct BackendBackcoverColor: Codable {
    let r: Float
    let g: Float
    let b: Float
}

// This struct is what your backend expects for a tap trigger
struct TapToSurfaceTrigger: Codable {
    let event: String = "tapToSurfaceTriggered"
}

// Replace with your actual backend URL
let backendBaseURL = URL(string: "https://YOUR_BACKEND_IP_OR_DOMAIN:5000/api")!
// For WebSocket, you might use a third-party library like Starscream or native URLSessionWebSocketTask
let backendWebSocketURL = URL(string: "ws://YOUR_BACKEND_IP_OR_DOMAIN:5000/ws")!


class SmartHomeAPIClient: ObservableObject {
    static let shared = SmartHomeAPIClient() // Singleton

    @Published var lights: [Light] = []
    @Published var currentBackcoverColor: (r: Float, g: Float, b: Float) = (0, 0, 0)
    @Published var errorMessage: String?

    private var websocketTask: URLSessionWebSocketTask?
    private var cancellables = Set<AnyCancellable>()

    private init() {
        setupWebSocket()
    }

    // MARK: - HTTP API Calls

    func fetchLights() async {
        guard let url = URL(string: "lights", relativeTo: backendBaseURL) else { return }
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            let fetchedLights = try JSONDecoder().decode([Light].self, from: data)
            DispatchQueue.main.async {
                self.lights = fetchedLights
                print("Fetched lights: \(self.lights.map { $0.name })")
            }
        } catch {
            print("Error fetching lights: \(error)")
            DispatchQueue.main.async { self.errorMessage = error.localizedDescription }
        }
    }

    func setLightState(lightId: String, newState: BackendLightState) async {
        guard let url = URL(string: "lights/\(lightId)", relativeTo: backendBaseURL) else { return }
        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        do {
            let jsonData = try JSONEncoder().encode(newState)
            request.httpBody = jsonData

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            // Optionally parse response to confirm state
            print("Successfully updated light \(lightId)")

            // Update local state if successful (or rely on WebSocket for real-time updates)
            if let index = lights.firstIndex(where: { $0.id == lightId }) {
                DispatchQueue.main.async {
                    self.lights[index].isOn = newState.on
                    if let bri = newState.brightness { self.lights[index].brightness = bri }
                    if let hue = newState.hue { self.lights[index].hue = hue }
                    if let sat = newState.saturation { self.lights[index].saturation = sat }
                }
            }

        } catch {
            print("Error setting light state for \(lightId): \(error)")
            DispatchQueue.main.async { self.errorMessage = error.localizedDescription }
        }
    }

    func updateBackcoverLED(r: Float, g: Float, b: Float) async {
        guard let url = URL(string: "backcover_led", relativeTo: backendBaseURL) else { return }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        do {
            let colorData = BackendBackcoverColor(r: r, g: g, b: b)
            let jsonData = try JSONEncoder().encode(colorData)
            request.httpBody = jsonData

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            print("Successfully updated backcover LED to R:\(r) G:\(g) B:\(b)")
            DispatchQueue.main.async {
                self.currentBackcoverColor = (r, g, b)
            }
        } catch {
            print("Error updating backcover LED: \(error)")
            DispatchQueue.main.async { self.errorMessage = error.localizedDescription }
        }
    }

    func sendTapToSurfaceTrigger() async {
        guard let url = URL(string: "tap_trigger", relativeTo: backendBaseURL) else { return }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        do {
            let jsonData = try JSONEncoder().encode(TapToSurfaceTrigger())
            request.httpBody = jsonData

            let (_, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            print("Sent tap to surface trigger to backend.")
        } catch {
            print("Error sending tap trigger: \(error)")
            DispatchQueue.main.async { self.errorMessage = error.localizedDescription }
        }
    }

    // MARK: - WebSocket API (for real-time updates)

    private func setupWebSocket() {
        websocketTask = URLSession.shared.webSocketTask(with: backendWebSocketURL)
        websocketTask?.resume()
        listenForWebSocketMessages()
        print("WebSocket connected to: \(backendWebSocketURL)")
    }

    private func listenForWebSocketMessages() {
        websocketTask?.receive { [weak self] result in
            switch result {
            case .failure(let error):
                print("WebSocket receive error: \(error)")
                DispatchQueue.main.async { self?.errorMessage = "WebSocket error: \(error.localizedDescription)" }
                // Reconnect after a delay
                DispatchQueue.global().asyncAfter(deadline: .now() + 5) {
                    self?.setupWebSocket()
                }
            case .success(let message):
                switch message {
                case .string(let text):
                    self?.processWebSocketMessage(text)
                case .data(let data):
                    print("Received binary data over WebSocket: \(data)")
                @unknown default:
                    print("Unknown WebSocket message type")
                }
                // Continue listening for next message
                self?.listenForWebSocketMessages()
            }
        }
    }

    private func processWebSocketMessage(_ message: String) {
        print("Received WS message: \(message)")
        guard let data = message.data(using: .utf8) else { return }
        do {
            let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
            guard let type = json?["type"] as? String else { return }

            DispatchQueue.main.async {
                if type == "lightStateUpdated",
                   let lightId = json?["lightId"] as? String,
                   let newStateDict = json?["newState"] as? [String: Any] {
                    // Update specific light in `lights` array
                    if let index = self.lights.firstIndex(where: { $0.id == lightId }) {
                        self.lights[index].isOn = newStateDict["on"] as? Bool ?? self.lights[index].isOn
                        self.lights[index].brightness = newStateDict["brightness"] as? Float ?? self.lights[index].brightness
                        self.lights[index].hue = newStateDict["hue"] as? Float ?? self.lights[index].hue
                        self.lights[index].saturation = newStateDict["saturation"] as? Float ?? self.lights[index].saturation
                    }
                    print("Updated light \(lightId) via WS: \(self.lights.first(where: { $0.id == lightId })?.isOn ?? false)")
                } else if type == "backcoverLEDUpdated",
                          let colorDict = json?["color"] as? [String: Float] {
                    self.currentBackcoverColor = (colorDict["r"] ?? 0, colorDict["g"] ?? 0, colorDict["b"] ?? 0)
                    print("Updated backcover LED via WS: \(self.currentBackcoverColor)")
                }
                // Add more message types as your backend supports
            }
        } catch {
            print("Error parsing WebSocket message: \(error)")
        }
    }

    func closeWebSocket() {
        websocketTask?.cancel(with: .goingAway, reason: nil)
        websocketTask = nil
    }
}



// SmartHueControlApp.swift
import SwiftUI

@main
struct SmartHueControlApp: App {
    // Inject the shared API client into the environment
    @StateObject private var apiClient = SmartHomeAPIClient.shared

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(apiClient) // Make apiClient accessible to all views
        }
    }
}



// ContentView.swift
import SwiftUI
import CoreMotion

struct ContentView: View {
    @EnvironmentObject var apiClient: SmartHomeAPIClient // Access shared API client
    @State private var gestureStatus: String = "Initializing..."
    @State private var showControlsOverlay: Bool = false
    @State private var selectedLight: Light? = nil

    // Backcover LED simulation
    @State private var backcoverColor: Color = .black

    private var gestureClassifier: GestureClassifier?

    init() {
        // Initialize GestureClassifier here. Ensure the TFLite model is in the bundle.
        _gestureClassifier = State(initialValue: GestureClassifier())
    }

    var body: some View {
        ZStack {
            // Backcover LED Simulation
            Rectangle()
                .fill(backcoverColor)
                .edgesIgnoringSafeArea(.all)
                .animation(.easeOut(duration: 0.2), value: backcoverColor)

            VStack {
                Text(gestureStatus)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                    .padding()
                    .background(Color.black.opacity(0.7))
                    .cornerRadius(10)
                    .shadow(radius: 5)

                Spacer()

                // Overlay for light controls
                if showControlsOverlay {
                    VStack {
                        Text("Light Controls")
                            .font(.largeTitle)
                            .foregroundColor(.white)
                            .padding(.bottom, 20)

                        Picker("Select Light", selection: $selectedLight) {
                            Text("None").tag(nil as Light?)
                            ForEach(apiClient.lights) { light in
                                Text(light.name).tag(light as Light?)
                            }
                        }
                        .pickerStyle(.wheel)
                        .frame(height: 150)
                        .clipped() // Prevent picker from overflowing
                        .background(Color.white.opacity(0.1))
                        .cornerRadius(10)

                        if let selectedLight = selectedLight {
                            LightControlView(light: selectedLight) { updatedLight in
                                // Update the light in apiClient.lights array
                                if let index = apiClient.lights.firstIndex(where: { $0.id == updatedLight.id }) {
                                    apiClient.lights[index] = updatedLight
                                }
                                Task {
                                    // Call backend to update light
                                    await apiClient.setLightState(
                                        lightId: updatedLight.id,
                                        newState: BackendLightState(
                                            on: updatedLight.isOn,
                                            brightness: updatedLight.brightness,
                                            hue: updatedLight.hue,
                                            saturation: updatedLight.saturation
                                        )
                                    )
                                }
                            }
                        } else {
                            Text("Please select a light to control.")
                                .foregroundColor(.gray)
                                .padding()
                        }

                        Button("Close Controls") {
                            hideControlsOverlay()
                        }
                        .buttonStyle(.borderedProminent)
                        .tint(.red)
                        .padding(.top, 20)
                    }
                    .padding()
                    .background(.ultraThinMaterial)
                    .cornerRadius(25)
                    .shadow(radius: 20)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .transition(.move(edge: .bottom))
                }
            }
            .padding()
        }
        .onAppear {
            gestureClassifier?.delegate = self
            // Initial fetch of lights
            Task {
                await apiClient.fetchLights()
            }
        }
        .onChange(of: apiClient.currentBackcoverColor) { oldColor, newColor in
            backcoverColor = Color(red: Double(newColor.r), green: Double(newColor.g), blue: Double(newColor.b))
        }
        .onChange(of: apiClient.lights) { oldLights, newLights in
            // If the selected light was removed or its ID changed, deselect it
            if let currentSelected = selectedLight, !newLights.contains(where: { $0.id == currentSelected.id }) {
                selectedLight = nil
            }
            // If no light is selected, try to select the first one if available
            if selectedLight == nil, let firstLight = newLights.first {
                selectedLight = firstLight
            }
        }
        .alert("Error", isPresented: Binding<Bool>(
            get: { apiClient.errorMessage != nil },
            set: { if !$0 { apiClient.errorMessage = nil } }
        ), actions: {
            Button("OK") { apiClient.errorMessage = nil }
        }, message: {
            Text(apiClient.errorMessage ?? "An unknown error occurred.")
        })
    }

    private func showControlsOverlay() {
        withAnimation(.spring()) {
            showControlsOverlay = true
        }
        Task {
            await apiClient.sendTapToSurfaceTrigger() // Notify backend of gesture
        }
    }

    private func hideControlsOverlay() {
        withAnimation(.easeOut) {
            showControlsOverlay = false
        }
    }
}

// MARK: - GestureClassifierDelegate
extension ContentView: GestureClassifierDelegate {
    func gestureClassifier(_ classifier: GestureClassifier, didDetectGesture gesture: GestureType, confidence: Float) {
        DispatchQueue.main.async {
            self.gestureStatus = "\(gesture.description) (\(String(format: "%.2f", confidence * 100))%)"

            switch gesture {
            case .tapToSurface:
                // Simulate "surfacing" of UI
                self.showControlsOverlay()
                // Update backcover color to indicate recognition
                Task {
                    await apiClient.updateBackcoverLED(r: 0, g: 0.8, b: 0.8) // Teal-ish for feedback
                    try? await Task.sleep(nanoseconds: 1_000_000_000) // Hold color for 1 second
                    await apiClient.updateBackcoverLED(r: 0, g: 0, b: 0) // Reset to black
                }

            case .doubleTap:
                // Example: Toggle power of the currently selected light
                if let light = selectedLight {
                    Task {
                        await apiClient.setLightState(
                            lightId: light.id,
                            newState: BackendLightState(on: !light.isOn, brightness: nil, hue: nil, saturation: nil)
                        )
                    }
                }
                // Provide visual/haptic feedback on backcover
                Task {
                    await apiClient.updateBackcoverLED(r: 1, g: 0.5, b: 0) // Orange for double tap
                    try? await Task.sleep(nanoseconds: 1_000_000_000)
                    await apiClient.updateBackcoverLED(r: 0, g: 0, b: 0)
                }

            case .noGesture:
                // No specific action, but status updates
                break
            }
        }
    }

    func gestureClassifier(_ classifier: GestureClassifier, didEncounterError error: Error) {
        DispatchQueue.main.async {
            self.gestureStatus = "Gesture Error: \(error.localizedDescription)"
        }
    }
}

// Separate View for individual light controls for cleaner code
struct LightControlView: View {
    @Binding var light: Light
    var onUpdate: (Light) -> Void

    var body: some View {
        VStack {
            Toggle(isOn: $light.isOn) {
                Text("Power: \(light.name)")
            }
            .onChange(of: light.isOn) { _, _ in onUpdate(light) }
            .toggleStyle(.switch)
            .tint(.green)

            Slider(value: $light.brightness, in: 0...1) {
                Text("Brightness")
            } minimumValueLabel: {
                Image(systemName: "sun.min.fill")
            } maximumValueLabel: {
                Image(systemName: "sun.max.fill")
            }
            .onChange(of: light.brightness) { _, _ in onUpdate(light) }
            .tint(.yellow)

            Slider(value: $light.hue, in: 0...1) {
                Text("Hue")
            } minimumValueLabel: {
                Text("0")
            } maximumValueLabel: {
                Text("1")
            }
            .onChange(of: light.hue) { _, _ in onUpdate(light) }
            .tint(Color(hue: Double(light.hue), saturation: 1.0, brightness: 1.0))

            Slider(value: $light.saturation, in: 0...1) {
                Text("Saturation")
            } minimumValueLabel: {
                Text("0")
            } maximumValueLabel: {
                Text("1")
            }
            .onChange(of: light.saturation) { _, _ in onUpdate(light) }
            .tint(Color(hue: Double(light.hue), saturation: Double(light.saturation), brightness: 1.0))
        }
        .padding()
        .foregroundColor(.white)
    }
}




<key>NSMotionUsageDescription</key>
<string>Your gestures are used to control smart lights and backcover LED.</string>
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/> </dict>



// SmartHueControlWidgets.swift (The main Widget bundle file)
import WidgetKit
import SwiftUI
import AppIntents // For interactive widgets (iOS 17+)

// Define an AppIntent for toggling a light (iOS 17+ interactive widget)
struct ToggleLightIntent: AppIntent {
    static var title: LocalizedStringResource = "Toggle Light"
    static var description = IntentDescription("Toggles the power of a Philips Hue light.")

    @Parameter(title: "Light ID")
    var lightID: String

    @Parameter(title: "Current State")
    var currentState: Bool

    init() {} // Required for AppIntents
    init(lightID: String, currentState: Bool) {
        self.lightID = lightID
        self.currentState = currentState
    }

    func perform() async throws -> some IntentResult {
        // This is where the widget interacts with your backend.
        // Widgets cannot directly access Core Motion or TFLite.
        // They must communicate with your backend or read shared data.

        // Make an API call to toggle the light
        print("Widget Intent: Toggling light \(lightID) to \(self.currentState ? "OFF" : "ON")")
        let apiClient = SmartHomeAPIClient.shared // Use shared instance if it's set up for App Group
        await apiClient.setLightState(
            lightId: lightID,
            newState: BackendLightState(on: !currentState, brightness: nil, hue: nil, saturation: nil)
        )

        // Request a timeline reload for the widget to reflect the change
        WidgetCenter.shared.reloadTimelines(ofKind: "SmartHueControlWidget")

        return .result()
    }
}

struct SmartHueControlWidget: Widget {
    let kind: String = "SmartHueControlWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: Provider()) { entry in
            SmartHueControlWidgetEntryView(entry: entry)
                .containerBackground(.fill.tertiary, for: .widget)
        }
        .configurationDisplayName("Hue Lights & Gestures")
        .description("Control your Philips Hue lights and see gesture status.")
        .supportedFamilies([.systemSmall, .systemMedium]) // Define supported widget sizes
    }
}

struct Provider: TimelineProvider {
    // Shared user defaults for basic data sharing (optional, direct backend API is better)
    let userDefaults = UserDefaults(suiteName: "group.com.yourcompany.SmartHueControl")

    func placeholder(in context: Context) -> SimpleEntry {
        SimpleEntry(date: Date(), lightName: "Loading Light", lightOn: false, lightBrightness: 0.5, backcoverColor: .black)
    }

    func getSnapshot(in context: Context, completion: @escaping (SimpleEntry) -> Void) {
        // Fetch real data for snapshot or use placeholder
        Task {
            await SmartHomeAPIClient.shared.fetchLights()
            let firstLight = SmartHomeAPIClient.shared.lights.first
            let entry = SimpleEntry(
                date: Date(),
                lightName: firstLight?.name ?? "No Lights",
                lightOn: firstLight?.isOn ?? false,
                lightBrightness: firstLight?.brightness ?? 0.0,
                backcoverColor: Color(red: Double(SmartHomeAPIClient.shared.currentBackcoverColor.r), green: Double(SmartHomeAPIClient.shared.currentBackcoverColor.g), blue: Double(SmartHomeAPIClient.shared.currentBackcoverColor.b))
            )
            completion(entry)
        }
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> Void) {
        // Fetch updated data and define future refresh times
        Task {
            await SmartHomeAPIClient.shared.fetchLights()
            let firstLight = SmartHomeAPIClient.shared.lights.first
            let backcoverColor = Color(red: Double(SmartHomeAPIClient.shared.currentBackcoverColor.r), green: Double(SmartHomeAPIClient.shared.currentBackcoverColor.g), blue: Double(SmartHomeAPIClient.shared.currentBackcoverColor.b))

            let entry = SimpleEntry(
                date: Date(),
                lightName: firstLight?.name ?? "No Lights",
                lightOn: firstLight?.isOn ?? false,
                lightBrightness: firstLight?.brightness ?? 0.0,
                backcoverColor: backcoverColor,
                lightID: firstLight?.id // Pass light ID for interactive widget
            )

            let nextUpdate = Calendar.current.date(byAdding: .minute, value: 5, to: Date())! // Update every 5 mins
            let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
            completion(timeline)
        }
    }
}

struct SimpleEntry: TimelineEntry {
    let date: Date
    let lightName: String
    let lightOn: Bool
    let lightBrightness: Float
    let backcoverColor: Color
    let lightID: String? // For interactive widget
}

struct SmartHueControlWidgetEntryView : View {
    var entry: Provider.Entry
    @Environment(\.widgetFamily) var family // To handle different widget sizes

    var body: some View {
        VStack(alignment: .leading) {
            Text("Hue Control")
                .font(.headline)
                .foregroundColor(.secondary)

            Spacer()

            HStack {
                Circle()
                    .fill(entry.lightOn ? Color(hue: 0.15, saturation: 0.8, brightness: Double(entry.lightBrightness)) : .gray)
                    .frame(width: 30, height: 30)
                Text(entry.lightName)
                    .font(.title2)
                    .fontWeight(.bold)
                    .minimumScaleFactor(0.8)
                    .lineLimit(1)
            }

            if family == .systemMedium {
                if let lightID = entry.lightID {
                    // Interactive Toggle (iOS 17+)
                    if #available(iOS 17.0, *) {
                        Toggle(isOn: entry.lightOn) {
                            Text("Power")
                        }
                        .toggleStyle(.button)
                        .tint(entry.lightOn ? .green : .red)
                        .buttonStyle(.plain) // Ensure button takes full tap area
                        .controlSize(.large) // Make button more tappable
                        .contentTransition(.numericText()) // Smooth transition for text
                        .onAppear {
                            // Link App Intent to the Toggle's action
                            ToggleLightIntent.update(lightID: lightID, currentState: entry.lightOn)
                        }
                    } else {
                        // Fallback for iOS 16- (non-interactive, just shows state)
                        Text(entry.lightOn ? "On" : "Off")
                            .font(.subheadline)
                            .foregroundColor(entry.lightOn ? .green : .red)
                    }
                }
            }

            Spacer()

            Text("Backcover State")
                .font(.caption2)
                .foregroundColor(.secondary)
            Rectangle()
                .fill(entry.backcoverColor)
                .frame(height: 10)
                .cornerRadius(2)
        }
        .padding()
    }
}

@available(iOS 17.0, *) // Required for AppIntents to compile on older OS
extension ToggleLightIntent {
    // Helper to update the parameter for the App Intent from the UI
    static func update(lightID: String, currentState: Bool) {
        var intent = ToggleLightIntent()
        intent.lightID = lightID
        intent.currentState = currentState
        // Not actually called directly here, but defines the intent that the Toggle will use.
    }
}

// In your `SmartHueControlWidgets.swift` or a separate file for the preview
struct SmartHueControlWidgets_Previews: PreviewProvider {
    static var previews: some View {
        SmartHueControlWidgetEntryView(entry: SimpleEntry(date: Date(), lightName: "Bedroom Lamp", lightOn: true, lightBrightness: 0.8, backcoverColor: .teal, lightID: "1"))
            .previewContext(WidgetKit.WidgetPreviewContext(family: .systemSmall))

        SmartHueControlWidgetEntryView(entry: SimpleEntry(date: Date(), lightName: "Living Room Spot", lightOn: false, lightBrightness: 0.2, backcoverColor: .purple, lightID: "2"))
            .previewContext(WidgetKit.WidgetPreviewContext(family: .systemMedium))
    }
}
