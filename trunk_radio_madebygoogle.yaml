<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRS Global Scanner & Pitch Analyst</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ef4444; /* Red */
            --secondary-color: #374151; /* Dark Gray */
            --background-color: #111827; /* Dark Blue/Black */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: #f3f4f6;
        }
        .scanner-screen {
            background-color: #0c0d12;
            border: 2px solid var(--secondary-color);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
            min-height: 250px;
        }
        .ptt-button {
            background-color: var(--primary-color);
            transition: all 0.1s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .ptt-button:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .ptt-button:active {
            background-color: #b91c1c;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1);
            transform: translateY(1px);
        }
        .loading-dot {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center min-h-screen">

    <div class="w-full max-w-md bg-gray-800 rounded-xl p-4 shadow-2xl">
        <h1 class="text-3xl font-extrabold text-white mb-2 text-center">TRS Scanner</h1>
        <p class="text-sm text-gray-400 mb-4 text-center">Simulated Two-Way Radio & AI Pitch Analyst</p>

        <!-- Global Scanner Section -->
        <div class="mb-6 p-3 rounded-lg scanner-screen">
            <div id="scanner-status" class="flex justify-between text-xs font-mono text-green-400 mb-2">
                <span>CHANNEL: <span id="current-talkgroup-id">101</span></span>
                <span>STATUS: <span id="current-status">SCANNING</span></span>
            </div>
            <div id="scanner-feed" class="text-sm text-gray-200 h-40 overflow-y-auto">
                <p class="text-xs text-gray-500">--- Live Traffic Feed ---</p>
                <!-- Feed content will be injected here -->
            </div>
        </div>

        <!-- Talkgroup Selector -->
        <div class="mb-6">
            <label for="talkgroup-select" class="block text-sm font-semibold mb-1 text-gray-300">Select Talkgroup</label>
            <select id="talkgroup-select" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white focus:ring-red-500 focus:border-red-500 transition">
                <!-- Options populated by JavaScript -->
            </select>
        </div>

        <!-- PTT & Transmission Simulation -->
        <div class="mb-6 bg-gray-900 p-4 rounded-xl">
            <h2 class="text-xl font-bold mb-3 text-white">Push-to-Talk (PTT)</h2>
            <textarea id="transmission-input" class="w-full p-3 rounded-lg bg-gray-700 border-2 border-transparent text-white placeholder-gray-400 focus:border-red-500 focus:ring-red-500 resize-none" rows="3" placeholder="Enter your simulated radio transmission script for Pitch Analysis..."></textarea>
            <button id="ptt-button" class="ptt-button w-full mt-3 py-3 rounded-xl text-white font-extrabold uppercase tracking-widest text-lg shadow-xl flex items-center justify-center" disabled>
                <svg id="ptt-icon" class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3v-1m18 0a3 3 0 00-3-3m0 0a3 3 0 00-3-3m-3 3a3 3 0 003 3m-3 0a3 3 0 00-3-3m-6 3h6"></path></svg>
                <span id="ptt-text">ACTIVATE PITCH ANALYSIS</span>
            </button>
        </div>

        <!-- Pitch Performance Analysis Section -->
        <div class="bg-gray-700 p-4 rounded-xl shadow-inner border border-gray-600">
            <h2 class="text-xl font-bold mb-3 text-red-400 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                Pitch Performance Report
            </h2>
            <div id="analysis-report" class="text-sm text-gray-300">
                <p>Submit a transmission script above to get an instant AI analysis on your radio voice performance metrics (clarity, tone, confidence).</p>
            </div>
            <div id="loading-indicator" class="hidden mt-3 text-red-400 font-semibold flex items-center">
                <span class="loading-dot w-2 h-2 bg-red-400 rounded-full mr-2"></span>
                <span class="loading-dot w-2 h-2 bg-red-400 rounded-full mr-2" style="animation-delay: 0.2s;"></span>
                <span class="loading-dot w-2 h-2 bg-red-400 rounded-full mr-2" style="animation-delay: 0.4s;"></span>
                Analyzing pitch and tone...
            </div>
        </div>
    </div>

    <!-- JavaScript & API Logic -->
    <script type="module">
        // Global Constants
        const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
        const API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;
        const API_KEY = ""; // Canvas will provide this

        // UI Elements
        const talkgroupSelect = document.getElementById('talkgroup-select');
        const scannerFeed = document.getElementById('scanner-feed');
        const currentTalkgroupId = document.getElementById('current-talkgroup-id');
        const currentStatus = document.getElementById('current-status');
        const transmissionInput = document.getElementById('transmission-input');
        const pttButton = document.getElementById('ptt-button');
        const pttText = document.getElementById('ptt-text');
        const analysisReport = document.getElementById('analysis-report');
        const loadingIndicator = document.getElementById('loading-indicator');

        let currentTalkgroup = 'FIRE_DEPT';
        let feedInterval;
        let lastTimestamp = 0;

        // --- Mock API Data (Simulating a backend TRS Database) ---
        const MOCK_TALKGROUPS = [
            { id: 'FIRE_DEPT', name: 'City Fire Dispatch', frequency: 851.0125, priority: 1 },
            { id: 'POLICE_EAST', name: 'Police - East Sector', frequency: 852.1500, priority: 2 },
            { id: 'PUBLIC_WORKS', name: 'Public Works Maint.', frequency: 853.5000, priority: 3 },
            { id: 'LOGISTICS', name: 'Regional Logistics Hub', frequency: 854.9875, priority: 4 },
        ];

        const MOCK_TRANSMISSIONS = [
            { talkgroupId: 'FIRE_DEPT', time: 0, text: "Engine 4, confirm all clear on Sector Alpha. Over." },
            { talkgroupId: 'FIRE_DEPT', time: 5, text: "Confirmed all clear, returning to station. Over." },
            { talkgroupId: 'POLICE_EAST', time: 10, text: "Unit 301, we have a 10-55, need backup at Elm and 5th. Urgent. Over." },
            { talkgroupId: 'POLICE_EAST', time: 15, text: "301, 302 en route, ETA 5 minutes. Stay safe. Over." },
            { talkgroupId: 'PUBLIC_WORKS', time: 20, text: "Road Crew 7, a major water main break reported near the North bridge. Proceed with caution. Over." },
            { talkgroupId: 'LOGISTICS', time: 25, text: "Forklift 2, your load is ready for inbound transport. Confirm receipt. Over." },
            { talkgroupId: 'LOGISTICS', time: 30, text: "Copy that, Forklift 2 inbound. Over." },
        ];
        
        /**
         * Simulates fetching available talkgroups.
         * @returns {Promise<Array>} A promise that resolves with the mock talkgroups array.
         */
        const fetchTalkgroups = () => {
            return new Promise(resolve => {
                setTimeout(() => resolve(MOCK_TALKGROUPS), 500);
            });
        };

        /**
         * Simulates streaming a new transmission for the current talkgroup.
         */
        const streamTransmission = () => {
            const now = Math.floor(Date.now() / 1000);
            const newTransmissions = MOCK_TRANSMISSIONS.filter(t => t.talkgroupId === currentTalkgroup && t.time > lastTimestamp);

            if (newTransmissions.length > 0) {
                newTransmissions.forEach(tx => {
                    const timeString = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    const talkgroupName = MOCK_TALKGROUPS.find(g => g.id === currentTalkgroup).name;
                    
                    const newEntry = document.createElement('p');
                    newEntry.innerHTML = `<span class="text-red-400">[${timeString}]</span> <span class="text-green-300">${talkgroupName}</span>: ${tx.text}`;
                    
                    scannerFeed.appendChild(newEntry);
                    scannerFeed.scrollTop = scannerFeed.scrollHeight; // Auto-scroll
                });
                lastTimestamp = newTransmissions[newTransmissions.length - 1].time;
            }

            // Loop mock data
            if (lastTimestamp >= MOCK_TRANSMISSIONS[MOCK_TRANSMISSIONS.length - 1].time) {
                lastTimestamp = 0;
            }
        };

        // --- Core Application Logic ---

        /**
         * Initializes the scanner by populating talkgroups and starting the feed.
         */
        const initScanner = async () => {
            // 1. Load Talkgroups
            const groups = await fetchTalkgroups();
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = `${group.name} (${group.frequency} MHz)`;
                talkgroupSelect.appendChild(option);
            });
            talkgroupSelect.value = currentTalkgroup;
            
            // 2. Start Live Feed
            startFeed();
        };

        const startFeed = () => {
            clearInterval(feedInterval);
            const selectedGroup = MOCK_TALKGROUPS.find(g => g.id === currentTalkgroup);
            
            scannerFeed.innerHTML = `<p class="text-xs text-gray-500">--- Scanning Talkgroup: ${selectedGroup.name} ---</p>`;
            currentTalkgroupId.textContent = selectedGroup.id;
            currentStatus.textContent = 'MONITORING';
            
            // Simulate a new transmission every 3 seconds
            feedInterval = setInterval(streamTransmission, 3000);
        };

        // --- Pitch Performance API (Gemini Call) ---

        /**
         * Retries the API call using exponential backoff.
         */
        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) { // Not a rate limit error
                        return response;
                    }
                    console.warn(`Rate limit hit. Retrying in ${2 ** i} seconds...`);
                } catch (error) {
                    console.error("Fetch error, retrying:", error);
                }
                await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000));
            }
            throw new Error('API call failed after multiple retries.');
        }


        /**
         * Calls the Gemini API to analyze the simulated transmission script.
         * This acts as the 'Pitch Performance API' backend logic.
         * @param {string} userScript - The text representing the radio transmission.
         */
        const analyzePitchPerformance = async (userScript) => {
            analysisReport.innerHTML = '';
            loadingIndicator.classList.remove('hidden');

            const systemPrompt = `You are an AI-powered voice performance analyst for professional two-way radio communication. 
                Your task is to analyze the user's transmission script (text) and provide a professional, quantifiable score (1-5, where 5 is excellent) for the following communication metrics:
                1. Clarity: How unambiguous and direct the message is.
                2. Confidence: How authoritative and assured the implied tone is.
                3. Appropriate Pitch/Tone: How suitable the emotional delivery is for a high-stakes radio environment (e.g., serious, urgent, calm).
                
                Provide a brief, professional recommendation on how to improve the 'pitch performance' in a real-world scenario. Your response MUST be in the requested JSON format.`;
            
            const userQuery = `Analyze the following radio transmission script for professional pitch performance: "${userScript}"`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "clarity_score": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for clarity." },
                            "confidence_score": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for confidence." },
                            "pitch_tone_rating": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for appropriateness of pitch/tone." },
                            "analysis_summary": { "type": "STRING", "description": "A brief, professional summary of the findings." },
                            "improvement_tip": { "type": "STRING", "description": "A single, actionable tip for improving vocal delivery." }
                        },
                        "required": ["clarity_score", "confidence_score", "pitch_tone_rating", "analysis_summary", "improvement_tip"]
                    }
                }
            };
            
            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetchWithRetry(`${API_BASE_URL}?key=${API_KEY}`, options);
                const result = await response.json();
                
                let analysisData;
                
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    analysisData = JSON.parse(jsonText);
                    displayAnalysis(analysisData);
                } else {
                    analysisReport.textContent = "Error: Could not retrieve a valid analysis from the AI. Please try a different script.";
                }

            } catch (error) {
                console.error("Gemini API Error:", error);
                analysisReport.textContent = `API Request Failed: ${error.message}`;
            } finally {
                loadingIndicator.classList.add('hidden');
                pttButton.disabled = false;
                pttText.textContent = 'ACTIVATE PITCH ANALYSIS';
            }
        };

        /**
         * Displays the structured AI analysis in the report section.
         * @param {Object} data - The parsed analysis data from the Gemini API.
         */
        const displayAnalysis = (data) => {
            const totalScore = (data.clarity_score + data.confidence_score + data.pitch_tone_rating) / 3;

            analysisReport.innerHTML = `
                <div class="space-y-3">
                    <p class="text-base font-semibold text-white">Overall Performance: <span class="text-red-400 text-xl">${totalScore.toFixed(1)}/5.0</span></p>
                    
                    <div class="flex flex-wrap gap-4 text-xs font-mono">
                        <span class="p-1 px-2 rounded bg-gray-600">CLARITY: ${data.clarity_score.toFixed(1)}/5.0</span>
                        <span class="p-1 px-2 rounded bg-gray-600">CONFIDENCE: ${data.confidence_score.toFixed(1)}/5.0</span>
                        <span class="p-1 px-2 rounded bg-gray-600">TONE: ${data.pitch_tone_rating.toFixed(1)}/5.0</span>
                    </div>

                    <div class="border-t border-gray-600 pt-3">
                        <p class="font-bold text-red-300">Summary:</p>
                        <p>${data.analysis_summary}</p>
                    </div>

                    <div class="pt-1">
                        <p class="font-bold text-red-300">Improvement Tip:</p>
                        <p class="italic">"${data.improvement_tip}"</p>
                    </div>
                </div>
            `;
        };


        // --- Event Handlers ---

        pttButton.addEventListener('click', () => {
            const script = transmissionInput.value.trim();
            if (!script) {
                analysisReport.innerHTML = '<p class="text-yellow-400">Please enter a simulated radio message to analyze its pitch performance.</p>';
                return;
            }

            pttButton.disabled = true;
            pttText.textContent = 'TRANSMITTING...';
            
            // Wait a moment to simulate transmission time, then call AI for analysis
            setTimeout(() => {
                analyzePitchPerformance(script);
            }, 500);
        });

        talkgroupSelect.addEventListener('change', (e) => {
            currentTalkgroup = e.target.value;
            lastTimestamp = 0; // Reset mock time when changing channels
            startFeed();
        });

        // Enable button when text is present
        transmissionInput.addEventListener('input', () => {
            pttButton.disabled = transmissionInput.value.trim().length === 0;
        });
        
        // Initial setup on load
        window.onload = initScanner;

    </script>
</body>
</html>




import React, { useState, useEffect, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, collection, query, limit, onSnapshot, serverTimestamp, addDoc, getDocs, orderBy } from 'firebase/firestore';
import { RefreshCcw, Mic, Send, Zap, MessageSquare, AlertTriangle, Loader, BarChart3 } from 'lucide-react';

// --- Global Environment Variables (Provided by Canvas) ---
// These variables are automatically injected and ensure connectivity to Firebase.
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
const API_KEY = ""; // Canvas will provide the API key for the Gemini API call
const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
const API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

// --- Firebase Initialization and Instances ---
let db = null;
let auth = null;

if (Object.keys(firebaseConfig).length > 0) {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
}

// --- Utility Functions ---

/**
 * Retries the API call using exponential backoff to handle rate limits.
 */
async function fetchWithRetry(url, options, maxRetries = 5) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(url, options);
            if (response.status !== 429) { 
                return response;
            }
            console.warn(`Rate limit hit. Retrying in ${2 ** i} seconds...`);
        } catch (error) {
            console.error("Fetch error, retrying:", error);
        }
        await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000));
    }
    throw new Error('API call failed after multiple retries.');
}

/**
 * Simulates logging a radio transmission to the Firestore log collection (Public data).
 */
const logTransmission = async (dbInstance, userId, talkgroupId, message) => {
    if (!dbInstance) return;

    try {
        const logsCollectionRef = collection(dbInstance, 'artifacts', appId, 'public', 'data', 'scanner_logs');
        await addDoc(logsCollectionRef, {
            talkgroupId: talkgroupId,
            message: message,
            userId: userId.substring(0, 8), // Truncate ID for display cleanliness
            timestamp: serverTimestamp(),
        });
    } catch (e) {
        console.error("Error logging transmission:", e);
    }
};

/**
 * AI-powered analysis of the script using the Gemini API.
 */
const analyzePitchPerformance = async (script) => {
    const systemPrompt = `You are an AI-powered voice performance analyst for professional two-way radio communication. 
        Your task is to analyze the user's transmission script (text) and provide a professional, quantifiable score (1-5, where 5 is excellent) for the following communication metrics:
        1. Clarity: How unambiguous and direct the message is.
        2. Confidence: How authoritative and assured the implied tone is.
        3. Appropriate Pitch/Tone: How suitable the emotional delivery is for a high-stakes radio environment (e.g., serious, urgent, calm).
        
        Provide a brief, professional recommendation on how to improve the 'pitch performance' in a real-world scenario. Your response MUST be in the requested JSON format.`;
    
    const userQuery = `Analyze the following radio transmission script for professional pitch performance: "${script}"`;

    const payload = {
        contents: [{ parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    "clarity_score": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for clarity." },
                    "confidence_score": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for confidence." },
                    "pitch_tone_rating": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for appropriateness of pitch/tone." },
                    "analysis_summary": { "type": "STRING", "description": "A brief, professional summary of the findings." },
                    "improvement_tip": { "type": "STRING", "description": "A single, actionable tip for improving vocal delivery." }
                },
                "required": ["clarity_score", "confidence_score", "pitch_tone_rating", "analysis_summary", "improvement_tip"]
            }
        }
    };
    
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    };

    const response = await fetchWithRetry(`${API_BASE_URL}?key=${API_KEY}`, options);
    const result = await response.json();
    
    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
        const jsonText = result.candidates[0].content.parts[0].text;
        return JSON.parse(jsonText);
    } else {
        throw new Error("Failed to retrieve structured analysis from AI.");
    }
};

// --- React Components ---

/**
 * Displays the real-time, global scanner feed from Firestore.
 */
const ScannerDisplay = ({ logs, currentTalkgroup }) => {
    const feedRef = useRef(null);

    // Auto-scroll to the bottom when logs update
    useEffect(() => {
        if (feedRef.current) {
            // Check if user is near the bottom before scrolling automatically
            const { scrollTop, scrollHeight, clientHeight } = feedRef.current;
            if (scrollHeight - (scrollTop + clientHeight) < 50) {
                 feedRef.current.scrollTop = feedRef.current.scrollHeight;
            }
        }
    }, [logs]);

    const statusText = logs.length > 0 ? "TRAFFIC ACTIVE" : "SCANNING IDLE";
    const statusColor = logs.length > 0 ? "text-green-400" : "text-yellow-400";
    
    return (
        <div className="mb-6 p-4 rounded-xl bg-gray-900 border-2 border-red-600 shadow-xl w-full">
            <div className="flex justify-between text-xs font-mono text-white mb-2 pb-2 border-b border-gray-700">
                <span className="flex items-center font-bold">
                    <Zap className="w-4 h-4 mr-1 text-red-500" />
                    LISTENING: <span className="text-red-300 font-extrabold ml-1">{currentTalkgroup.name}</span>
                </span>
                <span className={`font-bold ${statusColor}`}>{statusText}</span>
            </div>
            <div ref={feedRef} className="text-sm text-gray-200 h-52 overflow-y-auto scrollbar-thin scrollbar-thumb-red-500 scrollbar-track-gray-800">
                {logs.length === 0 ? (
                    <p className="text-xs text-gray-500 text-center pt-14">Waiting for live transmissions on the network...</p>
                ) : (
                    logs.map((log, index) => (
                        <p key={log.id || index} className={`mb-1 transition-opacity duration-300 ${log.talkgroupId === currentTalkgroup.id ? 'opacity-100 font-semibold' : 'opacity-50'}`}>
                            <span className="text-red-400 font-mono">[{log.time}]</span>
                            <span className="text-green-300 ml-2 font-bold">{log.userId}:</span>
                            <span className="ml-1">{log.message}</span>
                        </p>
                    ))
                )}
            </div>
        </div>
    );
};

/**
 * Displays the AI-generated pitch analysis report.
 */
const PitchReport = ({ data, isLoading, error }) => {
    if (isLoading) {
        return (
            <div className="flex flex-col items-center justify-center h-48 text-red-400 font-semibold bg-gray-900 rounded-xl">
                <Loader className="w-8 h-8 animate-spin mb-3" />
                <p>Analyzing script performance with Gemini...</p>
            </div>
        );
    }

    if (error) {
        return (
            <div className="text-center text-red-300 p-4 border border-red-500 rounded-xl bg-gray-900">
                <AlertTriangle className="w-6 h-6 mx-auto mb-3" />
                <p className="font-bold text-lg">Analysis Error</p>
                <p className="text-sm mt-1">{error}</p>
            </div>
        );
    }

    if (!data) {
        return (
            <div className="text-sm text-gray-300 text-center py-6 bg-gray-900 rounded-xl border border-gray-700">
                <p className="font-bold text-lg mb-1">AI Pitch Performance Report</p>
                <p className="text-xs text-gray-400">Enter a professional radio script, press PTT, and the AI will provide a structured analysis of your communication delivery.</p>
            </div>
        );
    }

    const totalScore = (data.clarity_score + data.confidence_score + data.pitch_tone_rating) / 3;

    return (
        <div className="space-y-4 p-4 bg-gray-900 rounded-xl border border-gray-700 shadow-lg">
            <div className="flex justify-between items-end border-b border-red-600 pb-2">
                <p className="text-lg font-bold text-white">OVERALL RATING</p>
                <p className="text-5xl font-extrabold text-red-400">{totalScore.toFixed(1)}<span className="text-2xl font-light text-gray-500">/5.0</span></p>
            </div>
            
            <div className="grid grid-cols-3 gap-3 text-center">
                <Metric score={data.clarity_score} label="Clarity" />
                <Metric score={data.confidence_score} label="Confidence" />
                <Metric score={data.pitch_tone_rating} label="Pitch/Tone" />
            </div>

            <div className="border-t border-gray-700 pt-3 space-y-2">
                <p className="font-bold text-red-300 text-base">ANALYSIS SUMMARY:</p>
                <p className="text-sm text-gray-300 leading-snug">{data.analysis_summary}</p>

                <p className="font-bold text-red-300 text-base pt-2">IMPROVEMENT TIP:</p>
                <p className="italic text-sm text-gray-300 border-l-2 border-green-500 pl-3">"{data.improvement_tip}"</p>
            </div>
        </div>
    );
};

const Metric = ({ score, label }) => (
    <div className="p-2 rounded-lg bg-gray-800 border border-gray-700">
        <span className="block text-red-400 text-2xl font-extrabold">{score.toFixed(1)}</span>
        <span className="block text-gray-400 uppercase text-[10px] font-mono mt-1">{label}</span>
    </div>
);


/**
 * Main application component.
 */
const App = () => {
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [userId, setUserId] = useState(null);
    const [talkgroups, setTalkgroups] = useState([]);
    const [scannerLogs, setScannerLogs] = useState([]);
    const [selectedTalkgroupId, setSelectedTalkgroupId] = useState('FIRE_DEPT');
    const [scriptInput, setScriptInput] = useState('');
    
    const [analysisData, setAnalysisData] = useState(null);
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [analysisError, setAnalysisError] = useState(null);
    const [isTransmitting, setIsTransmitting] = useState(false);

    // --- Authentication and Initialization ---
    useEffect(() => {
        if (!auth || !db) {
            console.error("Firebase is not initialized. Check if __firebase_config is correctly provided.");
            setIsAuthReady(true);
            return;
        }

        const setupAuth = async (user) => {
            if (user) {
                setUserId(user.uid);
                await initializeTalkgroups(db);
            } else {
                try {
                    // Fallback to anonymous sign-in if no token is available
                    const anonUser = await signInAnonymously(auth);
                    setUserId(anonUser.user.uid);
                    await initializeTalkgroups(db);
                } catch (e) {
                    console.error("Anonymous sign in failed:", e);
                }
            }
            setIsAuthReady(true);
        };

        const trySignIn = async () => {
            if (initialAuthToken) {
                try {
                    await signInWithCustomToken(auth, initialAuthToken);
                } catch (e) {
                    console.error("Custom token sign in failed:", e);
                }
            }
        };

        trySignIn();
        const unsubscribe = onAuthStateChanged(auth, setupAuth);

        return () => unsubscribe();
    }, []);

    // Default Talkgroup Setup
    const initializeTalkgroups = async (dbInstance) => {
        const tgCollectionRef = collection(dbInstance, 'artifacts', appId, 'public', 'data', 'talkgroups');
        const defaultGroups = [
            { id: 'FIRE_DEPT', name: 'Fire/Rescue Dispatch', priority: 1 },
            { id: 'POLICE_E', name: 'Police East Patrol', priority: 2 },
            { id: 'PUBLIC_WORKS', name: 'Public Works Maint', priority: 3 },
            { id: 'TRANSPORT', name: 'Transit Authority', priority: 4 },
        ];

        try {
            // Only initialize if the collection is truly empty
            const snapshot = await getDocs(tgCollectionRef);
            if (snapshot.empty) {
                for (const group of defaultGroups) {
                    await setDoc(doc(tgCollectionRef, group.id), {
                        name: group.name,
                        priority: group.priority
                    });
                }
            }
        } catch (e) {
            console.error("Error initializing talkgroups:", e);
        }
    };

    // --- Firestore Listeners ---
    useEffect(() => {
        if (!isAuthReady || !db || !userId) return;
        
        // 1. Listen for Talkgroups (Public Channels)
        const tgCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'talkgroups');
        const unsubscribeTg = onSnapshot(tgCollectionRef, (snapshot) => {
            const groups = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setTalkgroups(groups);
            if (groups.length > 0 && !groups.find(g => g.id === selectedTalkgroupId)) {
                setSelectedTalkgroupId(groups[0].id);
            }
        }, (error) => {
            console.error("Error fetching talkgroups:", error);
        });

        // 2. Listen for Scanner Logs (Live Traffic Feed)
        const logsCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'scanner_logs');
        // Fetch last 15 logs, ordered by timestamp
        const q = query(logsCollectionRef, orderBy('timestamp', 'desc'), limit(15)); 
        
        const unsubscribeLogs = onSnapshot(q, (snapshot) => {
            const logs = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                // Format timestamp for display
                time: doc.data().timestamp?.toDate().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) || '...'
            })).reverse(); // Reverse to display oldest at top, newest at bottom
            setScannerLogs(logs);
        }, (error) => {
            console.error("Error fetching scanner logs:", error);
        });

        return () => {
            unsubscribeTg();
            unsubscribeLogs();
        };
    }, [isAuthReady, userId, selectedTalkgroupId]);
    
    // --- Handlers ---
    const handleTalkgroupChange = (e) => {
        setSelectedTalkgroupId(e.target.value);
    };

    const handlePTTPress = async () => {
        if (!scriptInput.trim() || !userId || !db) {
            setAnalysisError("Please enter a script and ensure the app is authenticated.");
            return;
        }

        setIsTransmitting(true);
        setIsAnalyzing(true);
        setAnalysisError(null);
        setAnalysisData(null);
        
        // 1. Simulate Transmission (Log to Firestore)
        await logTransmission(db, userId, selectedTalkgroupId, scriptInput.trim());
        
        // Brief delay to simulate the transmission time
        await new Promise(resolve => setTimeout(resolve, 500));
        setIsTransmitting(false);

        // 2. Perform AI Pitch Analysis
        try {
            const analysis = await analyzePitchPerformance(scriptInput.trim());
            setAnalysisData(analysis);
        } catch (error) {
            console.error("Pitch Analysis Error:", error);
            setAnalysisError(error.message || "An unknown error occurred during AI analysis. Check console for details.");
        } finally {
            setIsAnalyzing(false);
        }
    };
    
    const currentTalkgroup = talkgroups.find(g => g.id === selectedTalkgroupId) || { id: 'N/A', name: 'Loading...' };

    if (!isAuthReady) {
        return <div className="min-h-screen bg-gray-900 text-white flex justify-center items-center font-mono">
            <Loader className="w-6 h-6 animate-spin mr-2 text-red-500" />
            Establishing secure system connection...
        </div>;
    }

    return (
        <div className="w-full max-w-md mx-auto p-4 flex flex-col items-center bg-gray-800 rounded-xl shadow-2xl min-h-screen font-sans">
            <h1 className="text-3xl font-extrabold text-white mb-2 text-center flex items-center">
                <Mic className="w-6 h-6 mr-2 text-red-500" />
                <span className="bg-clip-text text-transparent bg-gradient-to-r from-red-400 to-white">
                    TRS COMMAND 
                </span>
            </h1>
            <p className="text-xs text-gray-400 mb-4 text-center font-mono p-1 rounded bg-gray-700">
                Operator ID: <span className="text-red-400">{userId ? userId : 'N/A'}</span>
            </p>

            {/* Global Scanner Section */}
            <ScannerDisplay logs={scannerLogs} currentTalkgroup={currentTalkgroup} />

            {/* Talkgroup Selector */}
            <div className="mb-6 w-full p-3 bg-gray-700 rounded-xl border border-gray-600">
                <label htmlFor="talkgroup-select" className="block text-sm font-semibold mb-2 text-gray-300 flex items-center">
                    <RefreshCcw className="w-4 h-4 mr-1 text-red-400" /> Active Talkgroup
                </label>
                <select 
                    id="talkgroup-select" 
                    value={selectedTalkgroupId}
                    onChange={handleTalkgroupChange}
                    className="w-full p-2 rounded-lg bg-gray-800 border border-gray-600 text-white focus:ring-red-500 focus:border-red-500 transition"
                    disabled={isTransmitting || isAnalyzing}
                >
                    {talkgroups.length === 0 ? (
                        <option>Loading Channels...</option>
                    ) : (
                        talkgroups.map(g => (
                            <option key={g.id} value={g.id}>
                                {g.name} (Priority {g.priority})
                            </option>
                        ))
                    )}
                </select>
            </div>

            {/* PTT & Pitch Analyzer Input */}
            <div className="mb-6 w-full bg-gray-700 p-4 rounded-xl shadow-inner border border-red-600/50">
                <h2 className="text-lg font-bold mb-3 text-white flex items-center">
                    <MessageSquare className="w-5 h-5 mr-2 text-red-400" /> Transmission Script
                </h2>
                <textarea 
                    id="transmission-input" 
                    value={scriptInput}
                    onChange={(e) => setScriptInput(e.target.value)}
                    className="w-full p-3 rounded-lg bg-gray-800 border-2 border-transparent text-white placeholder-gray-400 focus:border-red-500 focus:ring-red-500 resize-none transition duration-150" 
                    rows="4" 
                    placeholder={`Enter the script you would transmit on the ${currentTalkgroup.name} channel...`}
                    disabled={isTransmitting || isAnalyzing}
                ></textarea>
                <button 
                    onClick={handlePTTPress}
                    className={`w-full mt-3 py-3 rounded-xl text-white font-extrabold uppercase tracking-widest text-lg shadow-xl flex items-center justify-center transform transition duration-200 ease-in-out hover:scale-[1.01]
                        ${isAnalyzing || isTransmitting ? 'bg-gray-500 cursor-not-allowed' : 'bg-red-600 hover:bg-red-700 active:bg-red-800 shadow-red-900/50'}`}
                    disabled={isAnalyzing || isTransmitting || !scriptInput.trim()}
                >
                    {isTransmitting ? (
                        <>
                            <Send className="w-5 h-5 mr-2 animate-pulse" />
                            TRANSMITTING LIVE...
                        </>
                    ) : isAnalyzing ? (
                        <>
                            <Loader className="w-5 h-5 mr-2 animate-spin" />
                            ANALYZING PITCH
                        </>
                    ) : (
                        <>
                            <Mic className="w-6 h-6 mr-2" />
                            PTT: TRANSMIT & ANALYZE
                        </>
                    )}
                </button>
            </div>

            {/* Pitch Performance Analysis Section */}
            <div className="w-full">
                <h2 className="text-xl font-bold mb-3 text-red-400 flex items-center">
                    <BarChart3 className="w-5 h-5 mr-2" />
                    AI Pitch Performance Metrics
                </h2>
                <PitchReport data={analysisData} isLoading={isAnalyzing} error={analysisError} />
            </div>
        </div>
    );
};

export default App;




import React, { useState, useEffect, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, collection, query, limit, onSnapshot, serverTimestamp, addDoc, getDocs, orderBy } from 'firebase/firestore';
import { RefreshCcw, Mic, Send, Zap, MessageSquare, AlertTriangle, Loader, BarChart3 } from 'lucide-react';

// --- Global Environment Variables (Provided by Canvas) ---
// These variables are automatically injected and ensure connectivity to Firebase.
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
const API_KEY = ""; // Canvas will provide the API key for the Gemini API call
const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
const API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

// --- Firebase Initialization and Instances ---
let db = null;
let auth = null;

if (Object.keys(firebaseConfig).length > 0) {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
}

// --- Utility Functions ---

/**
 * Retries the API call using exponential backoff to handle rate limits.
 */
async function fetchWithRetry(url, options, maxRetries = 5) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(url, options);
            if (response.status !== 429) { 
                return response;
            }
            console.warn(`Rate limit hit. Retrying in ${2 ** i} seconds...`);
        } catch (error) {
            console.error("Fetch error, retrying:", error);
        }
        await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000));
    }
    throw new Error('API call failed after multiple retries.');
}

/**
 * Simulates logging a radio transmission to the Firestore log collection (Public data).
 */
const logTransmission = async (dbInstance, userId, talkgroupId, message) => {
    if (!dbInstance) return;

    try {
        const logsCollectionRef = collection(dbInstance, 'artifacts', appId, 'public', 'data', 'scanner_logs');
        await addDoc(logsCollectionRef, {
            talkgroupId: talkgroupId,
            message: message,
            userId: userId.substring(0, 8), // Truncate ID for display cleanliness
            timestamp: serverTimestamp(),
        });
    } catch (e) {
        console.error("Error logging transmission:", e);
    }
};

/**
 * AI-powered analysis of the script using the Gemini API.
 */
const analyzePitchPerformance = async (script) => {
    const systemPrompt = `You are an AI-powered voice performance analyst for professional two-way radio communication. 
        Your task is to analyze the user's transmission script (text) and provide a professional, quantifiable score (1-5, where 5 is excellent) for the following communication metrics:
        1. Clarity: How unambiguous and direct the message is.
        2. Confidence: How authoritative and assured the implied tone is.
        3. Appropriate Pitch/Tone: How suitable the emotional delivery is for a high-stakes radio environment (e.g., serious, urgent, calm).
        
        Provide a brief, professional recommendation on how to improve the 'pitch performance' in a real-world scenario. Your response MUST be in the requested JSON format.`;
    
    const userQuery = `Analyze the following radio transmission script for professional pitch performance: "${script}"`;

    const payload = {
        contents: [{ parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    "clarity_score": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for clarity." },
                    "confidence_score": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for confidence." },
                    "pitch_tone_rating": { "type": "NUMBER", "description": "Score from 1.0 to 5.0 for appropriateness of pitch/tone." },
                    "analysis_summary": { "type": "STRING", "description": "A brief, professional summary of the findings." },
                    "improvement_tip": { "type": "STRING", "description": "A single, actionable tip for improving vocal delivery." }
                },
                "required": ["clarity_score", "confidence_score", "pitch_tone_rating", "analysis_summary", "improvement_tip"]
            }
        }
    };
    
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    };

    const response = await fetchWithRetry(`${API_BASE_URL}?key=${API_KEY}`, options);
    const result = await response.json();
    
    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
        const jsonText = result.candidates[0].content.parts[0].text;
        return JSON.parse(jsonText);
    } else {
        throw new Error("Failed to retrieve structured analysis from AI.");
    }
};

// --- React Components ---

/**
 * Displays the real-time, global scanner feed from Firestore.
 */
const ScannerDisplay = ({ logs, currentTalkgroup }) => {
    const feedRef = useRef(null);

    // Auto-scroll to the bottom when logs update
    useEffect(() => {
        if (feedRef.current) {
            // Check if user is near the bottom before scrolling automatically
            const { scrollTop, scrollHeight, clientHeight } = feedRef.current;
            if (scrollHeight - (scrollTop + clientHeight) < 50) {
                 feedRef.current.scrollTop = feedRef.current.scrollHeight;
            }
        }
    }, [logs]);

    const statusText = logs.length > 0 ? "TRAFFIC ACTIVE" : "SCANNING IDLE";
    const statusColor = logs.length > 0 ? "text-green-400" : "text-yellow-400";
    
    return (
        <div className="mb-6 p-4 rounded-xl bg-gray-900 border-2 border-red-600 shadow-xl w-full">
            <div className="flex justify-between text-xs font-mono text-white mb-2 pb-2 border-b border-gray-700">
                <span className="flex items-center font-bold">
                    <Zap className="w-4 h-4 mr-1 text-red-500" />
                    LISTENING: <span className="text-red-300 font-extrabold ml-1">{currentTalkgroup.name}</span>
                </span>
                <span className={`font-bold ${statusColor}`}>{statusText}</span>
            </div>
            <div ref={feedRef} className="text-sm text-gray-200 h-52 overflow-y-auto scrollbar-thin scrollbar-thumb-red-500 scrollbar-track-gray-800">
                {logs.length === 0 ? (
                    <p className="text-xs text-gray-500 text-center pt-14">Waiting for live transmissions on the network...</p>
                ) : (
                    logs.map((log, index) => (
                        <p key={log.id || index} className={`mb-1 transition-opacity duration-300 ${log.talkgroupId === currentTalkgroup.id ? 'opacity-100 font-semibold' : 'opacity-50'}`}>
                            <span className="text-red-400 font-mono">[{log.time}]</span>
                            <span className="text-green-300 ml-2 font-bold">{log.userId}:</span>
                            <span className="ml-1">{log.message}</span>
                        </p>
                    ))
                )}
            </div>
        </div>
    );
};

/**
 * Displays the AI-generated pitch analysis report.
 */
const PitchReport = ({ data, isLoading, error }) => {
    if (isLoading) {
        return (
            <div className="flex flex-col items-center justify-center h-48 text-red-400 font-semibold bg-gray-900 rounded-xl">
                <Loader className="w-8 h-8 animate-spin mb-3" />
                <p>Analyzing script performance with Gemini...</p>
            </div>
        );
    }

    if (error) {
        return (
            <div className="text-center text-red-300 p-4 border border-red-500 rounded-xl bg-gray-900">
                <AlertTriangle className="w-6 h-6 mx-auto mb-3" />
                <p className="font-bold text-lg">Analysis Error</p>
                <p className="text-sm mt-1">{error}</p>
            </div>
        );
    }

    if (!data) {
        return (
            <div className="text-sm text-gray-300 text-center py-6 bg-gray-900 rounded-xl border border-gray-700">
                <p className="font-bold text-lg mb-1">AI Pitch Performance Report</p>
                <p className="text-xs text-gray-400">Enter a professional radio script, press PTT, and the AI will provide a structured analysis of your communication delivery.</p>
            </div>
        );
    }

    const totalScore = (data.clarity_score + data.confidence_score + data.pitch_tone_rating) / 3;

    return (
        <div className="space-y-4 p-4 bg-gray-900 rounded-xl border border-gray-700 shadow-lg">
            <div className="flex justify-between items-end border-b border-red-600 pb-2">
                <p className="text-lg font-bold text-white">OVERALL RATING</p>
                <p className="text-5xl font-extrabold text-red-400">{totalScore.toFixed(1)}<span className="text-2xl font-light text-gray-500">/5.0</span></p>
            </div>
            
            <div className="grid grid-cols-3 gap-3 text-center">
                <Metric score={data.clarity_score} label="Clarity" />
                <Metric score={data.confidence_score} label="Confidence" />
                <Metric score={data.pitch_tone_rating} label="Pitch/Tone" />
            </div>

            <div className="border-t border-gray-700 pt-3 space-y-2">
                <p className="font-bold text-red-300 text-base">ANALYSIS SUMMARY:</p>
                <p className="text-sm text-gray-300 leading-snug">{data.analysis_summary}</p>

                <p className="font-bold text-red-300 text-base pt-2">IMPROVEMENT TIP:</p>
                <p className="italic text-sm text-gray-300 border-l-2 border-green-500 pl-3">"{data.improvement_tip}"</p>
            </div>
        </div>
    );
};

const Metric = ({ score, label }) => (
    <div className="p-2 rounded-lg bg-gray-800 border border-gray-700">
        <span className="block text-red-400 text-2xl font-extrabold">{score.toFixed(1)}</span>
        <span className="block text-gray-400 uppercase text-[10px] font-mono mt-1">{label}</span>
    </div>
);


/**
 * Main application component.
 */
const App = () => {
    const [isAuthReady, setIsAuthReady] = useState(false);
    const [userId, setUserId] = useState(null);
    const [talkgroups, setTalkgroups] = useState([]);
    const [scannerLogs, setScannerLogs] = useState([]);
    const [selectedTalkgroupId, setSelectedTalkgroupId] = useState('FIRE_DEPT');
    const [scriptInput, setScriptInput] = useState('');
    
    const [analysisData, setAnalysisData] = useState(null);
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [analysisError, setAnalysisError] = useState(null);
    const [isTransmitting, setIsTransmitting] = useState(false);

    // --- Authentication and Initialization ---
    useEffect(() => {
        if (!auth || !db) {
            console.error("Firebase is not initialized. Check if __firebase_config is correctly provided.");
            setIsAuthReady(true);
            return;
        }

        const setupAuth = async (user) => {
            if (user) {
                setUserId(user.uid);
                await initializeTalkgroups(db);
            } else {
                try {
                    // Fallback to anonymous sign-in if no token is available
                    const anonUser = await signInAnonymously(auth);
                    setUserId(anonUser.user.uid);
                    await initializeTalkgroups(db);
                } catch (e) {
                    console.error("Anonymous sign in failed:", e);
                }
            }
            setIsAuthReady(true);
        };

        const trySignIn = async () => {
            if (initialAuthToken) {
                try {
                    await signInWithCustomToken(auth, initialAuthToken);
                } catch (e) {
                    console.error("Custom token sign in failed:", e);
                }
            }
        };

        trySignIn();
        const unsubscribe = onAuthStateChanged(auth, setupAuth);

        return () => unsubscribe();
    }, []);

    // Default Talkgroup Setup
    const initializeTalkgroups = async (dbInstance) => {
        const tgCollectionRef = collection(dbInstance, 'artifacts', appId, 'public', 'data', 'talkgroups');
        const defaultGroups = [
            { id: 'FIRE_DEPT', name: 'Fire/Rescue Dispatch', priority: 1 },
            { id: 'POLICE_E', name: 'Police East Patrol', priority: 2 },
            { id: 'PUBLIC_WORKS', name: 'Public Works Maint', priority: 3 },
            { id: 'TRANSPORT', name: 'Transit Authority', priority: 4 },
        ];

        try {
            // Only initialize if the collection is truly empty
            const snapshot = await getDocs(tgCollectionRef);
            if (snapshot.empty) {
                for (const group of defaultGroups) {
                    await setDoc(doc(tgCollectionRef, group.id), {
                        name: group.name,
                        priority: group.priority
                    });
                }
            }
        } catch (e) {
            console.error("Error initializing talkgroups:", e);
        }
    };

    // --- Firestore Listeners ---
    useEffect(() => {
        if (!isAuthReady || !db || !userId) return;
        
        // 1. Listen for Talkgroups (Public Channels)
        const tgCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'talkgroups');
        const unsubscribeTg = onSnapshot(tgCollectionRef, (snapshot) => {
            const groups = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setTalkgroups(groups);
            if (groups.length > 0 && !groups.find(g => g.id === selectedTalkgroupId)) {
                setSelectedTalkgroupId(groups[0].id);
            }
        }, (error) => {
            console.error("Error fetching talkgroups:", error);
        });

        // 2. Listen for Scanner Logs (Live Traffic Feed)
        const logsCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'scanner_logs');
        // Fetch last 15 logs, ordered by timestamp
        const q = query(logsCollectionRef, orderBy('timestamp', 'desc'), limit(15)); 
        
        const unsubscribeLogs = onSnapshot(q, (snapshot) => {
            const logs = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                // Format timestamp for display
                time: doc.data().timestamp?.toDate().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) || '...'
            })).reverse(); // Reverse to display oldest at top, newest at bottom
            setScannerLogs(logs);
        }, (error) => {
            console.error("Error fetching scanner logs:", error);
        });

        return () => {
            unsubscribeTg();
            unsubscribeLogs();
        };
    }, [isAuthReady, userId, selectedTalkgroupId]);
    
    // --- Handlers ---
    const handleTalkgroupChange = (e) => {
        setSelectedTalkgroupId(e.target.value);
    };

    const handlePTTPress = async () => {
        if (!scriptInput.trim() || !userId || !db) {
            setAnalysisError("Please enter a script and ensure the app is authenticated.");
            return;
        }

        setIsTransmitting(true);
        setIsAnalyzing(true);
        setAnalysisError(null);
        setAnalysisData(null);
        
        // 1. Simulate Transmission (Log to Firestore)
        await logTransmission(db, userId, selectedTalkgroupId, scriptInput.trim());
        
        // Brief delay to simulate the transmission time
        await new Promise(resolve => setTimeout(resolve, 500));
        setIsTransmitting(false);

        // 2. Perform AI Pitch Analysis
        try {
            const analysis = await analyzePitchPerformance(scriptInput.trim());
            setAnalysisData(analysis);
        } catch (error) {
            console.error("Pitch Analysis Error:", error);
            setAnalysisError(error.message || "An unknown error occurred during AI analysis. Check console for details.");
        } finally {
            setIsAnalyzing(false);
        }
    };
    
    const currentTalkgroup = talkgroups.find(g => g.id === selectedTalkgroupId) || { id: 'N/A', name: 'Loading...' };

    if (!isAuthReady) {
        return <div className="min-h-screen bg-gray-900 text-white flex justify-center items-center font-mono">
            <Loader className="w-6 h-6 animate-spin mr-2 text-red-500" />
            Establishing secure system connection...
        </div>;
    }

    return (
        <div className="w-full max-w-md mx-auto p-4 flex flex-col items-center bg-gray-800 rounded-xl shadow-2xl min-h-screen font-sans">
            <h1 className="text-3xl font-extrabold text-white mb-2 text-center flex items-center">
                <Mic className="w-6 h-6 mr-2 text-red-500" />
                <span className="bg-clip-text text-transparent bg-gradient-to-r from-red-400 to-white">
                    TRS COMMAND 
                </span>
            </h1>
            <p className="text-xs text-gray-400 mb-4 text-center font-mono p-1 rounded bg-gray-700">
                Operator ID: <span className="text-red-400">{userId ? userId : 'N/A'}</span>
            </p>

            {/* Global Scanner Section */}
            <ScannerDisplay logs={scannerLogs} currentTalkgroup={currentTalkgroup} />

            {/* Talkgroup Selector */}
            <div className="mb-6 w-full p-3 bg-gray-700 rounded-xl border border-gray-600">
                <label htmlFor="talkgroup-select" className="block text-sm font-semibold mb-2 text-gray-300 flex items-center">
                    <RefreshCcw className="w-4 h-4 mr-1 text-red-400" /> Active Talkgroup
                </label>
                <select 
                    id="talkgroup-select" 
                    value={selectedTalkgroupId}
                    onChange={handleTalkgroupChange}
                    className="w-full p-2 rounded-lg bg-gray-800 border border-gray-600 text-white focus:ring-red-500 focus:border-red-500 transition"
                    disabled={isTransmitting || isAnalyzing}
                >
                    {talkgroups.length === 0 ? (
                        <option>Loading Channels...</option>
                    ) : (
                        talkgroups.map(g => (
                            <option key={g.id} value={g.id}>
                                {g.name} (Priority {g.priority})
                            </option>
                        ))
                    )}
                </select>
            </div>

            {/* PTT & Pitch Analyzer Input */}
            <div className="mb-6 w-full bg-gray-700 p-4 rounded-xl shadow-inner border border-red-600/50">
                <h2 className="text-lg font-bold mb-3 text-white flex items-center">
                    <MessageSquare className="w-5 h-5 mr-2 text-red-400" /> Transmission Script
                </h2>
                <textarea 
                    id="transmission-input" 
                    value={scriptInput}
                    onChange={(e) => setScriptInput(e.target.value)}
                    className="w-full p-3 rounded-lg bg-gray-800 border-2 border-transparent text-white placeholder-gray-400 focus:border-red-500 focus:ring-red-500 resize-none transition duration-150" 
                    rows="4" 
                    placeholder={`Enter the script you would transmit on the ${currentTalkgroup.name} channel...`}
                    disabled={isTransmitting || isAnalyzing}
                ></textarea>
                <button 
                    onClick={handlePTTPress}
                    className={`w-full mt-3 py-3 rounded-xl text-white font-extrabold uppercase tracking-widest text-lg shadow-xl flex items-center justify-center transform transition duration-200 ease-in-out hover:scale-[1.01]
                        ${isAnalyzing || isTransmitting ? 'bg-gray-500 cursor-not-allowed' : 'bg-red-600 hover:bg-red-700 active:bg-red-800 shadow-red-900/50'}`}
                    disabled={isAnalyzing || isTransmitting || !scriptInput.trim()}
                >
                    {isTransmitting ? (
                        <>
                            <Send className="w-5 h-5 mr-2 animate-pulse" />
                            TRANSMITTING LIVE...
                        </>
                    ) : isAnalyzing ? (
                        <>
                            <Loader className="w-5 h-5 mr-2 animate-spin" />
                            ANALYZING PITCH
                        </>
                    ) : (
                        <>
                            <Mic className="w-6 h-6 mr-2" />
                            PTT: TRANSMIT & ANALYZE
                        </>
                    )}
                </button>
            </div>

            {/* Pitch Performance Analysis Section */}
            <div className="w-full">
                <h2 className="text-xl font-bold mb-3 text-red-400 flex items-center">
                    <BarChart3 className="w-5 h-5 mr-2" />
                    AI Pitch Performance Metrics
                </h2>
                <PitchReport data={analysisData} isLoading={isAnalyzing} error={analysisError} />
            </div>
        </div>
    );
};

export default App;

