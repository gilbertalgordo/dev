import numpy as np
import time

class FerrariF80Hypercar:
    """
    Instance representing the 2026 Ferrari F80.
    Architecture: 120° V6 Twin-Turbo + 3 MGU Units (e-4WD).
    """
    def __init__(self, pilot_mode="Qualifying"):
        # --- Engineering Specs (Kaizen Optimized) ---
        self.mass_kg = 1525 
        self.ice_hp = 900          # 3.0L V6 
        self.mgu_total_hp = 284    # Combined electric assist
        self.total_hp = self.ice_hp + self.mgu_total_hp
        
        # --- Active Aerodynamics ---
        self.downforce_max_kg = 1050  # At 250 km/h
        self.drag_coeff = 0.24
        
        # --- Systems State ---
        self.mode = pilot_mode     # eManettino setting
        self.hud_active = True
        self.ers_level = 100.0     # Battery %

    def calculate_dynamics(self, velocity_kmh):
        """Scientific reasoning for aerodynamic load and ERS deployment."""
        velocity_mps = velocity_kmh / 3.6
        rho = 1.225  # Air density kg/m^3
        
        # Formula: L = 0.5 * rho * v^2 * Cl * A
        current_downforce = (velocity_kmh / 250)**2 * self.downforce_max_kg
        
        # ERS Logic: Higher discharge in Qualifying mode
        discharge_rate = 2.5 if self.mode == "Qualifying" else 1.2
        self.ers_level -= discharge_rate
        
        return {
            "velocity": velocity_kmh,
            "downforce_kg": round(current_downforce, 2),
            "ers_rem": max(0, round(self.ers_level, 1)),
            "active_aero": "High-Downforce" if velocity_kmh > 120 else "Low-Drag"
        }

    def render_hud(self, telemetry):
        """Displays real-time HUD instances for the pilot."""
        print(f"\n--- FERRARI HUD [MODE: {self.mode}] ---")
        print(f"SPEED: {telemetry['velocity']} km/h")
        print(f"DOWNFORCE: {telemetry['downforce_kg']} kg")
        print(f"BATTERY: {telemetry['ers_rem']}%")
        print(f"AERO STATE: {telemetry['active_aero']}")
        print("-" * 30)

# --- Execution ---
f80_instance = FerrariF80Hypercar(pilot_mode="Qualifying")
for sec in range(1, 4):
    # Simulating acceleration: 0-250 km/h in an F80-style sprint
    current_speed = sec * 83.3  
    data = f80_instance.calculate_dynamics(current_speed)
    f80_instance.render_hud(data)



import math
import time
from dataclasses import dataclass

@dataclass
class TelemetryFrame:
    timestamp: float
    velocity: float
    total_torque_nm: float
    front_left_torque: float
    front_right_torque: float
    ers_soc: float  # State of Charge
    downforce_n: float

class FerrariF80ECU:
    """
    Advanced Electronic Control Unit for the F80 Hypercar.
    Features: 1,184 hp Total Output, 800V Hybrid Bus, and Active Aero.
    """
    def __init__(self):
        # Powertrain constants (2026 Specs)
        self.ICE_MAX_HP = 900
        self.MGU_K_HP = 80
        self.MGU_FRONT_HP = 142 * 2  # Dual motors
        self.BATT_CAPACITY_KWH = 2.28
        self.DRY_WEIGHT = 1525  # kg
        
        # State Variables
        self.current_soc = 100.0  # %
        self.active_wing_angle = 0  # degrees
        
    def calculate_torque_vectoring(self, steering_angle, throttle_input):
        """
        Archangelic Precision: Mimics the e-4WD lateral torque distribution.
        Logic: Shift more torque to the outer wheel during high-G cornering.
        """
        base_torque = throttle_input * 850  # 850 Nm ICE peak
        # Torque vectoring adjustment
        bias = (steering_angle / 45.0) * 0.15 
        left_motor = (0.5 - bias) * (self.MGU_FRONT_HP * 7.4) # HP to Nm approx
        right_motor = (0.5 + bias) * (self.MGU_FRONT_HP * 7.4)
        
        return left_motor, right_motor, base_torque

    def get_aerodynamics(self, velocity_kmh):
        """
        Scientific Reasoning: S-Duct and Active Wing interaction.
        F80 generates 1,050 kg of downforce at 250 km/h.
        """
        v_mps = velocity_kmh / 3.6
        # Downforce formula: F = 0.5 * rho * v^2 * Cl * A
        # Simplified for F80 curve (10,300 Newtons at 70 m/s)
        downforce_n = 2.1 * (v_mps ** 2)
        
        # Active Aero Logic: DRS (Drag Reduction System)
        self.active_wing_angle = 0 if velocity_kmh < 200 else -10
        return downforce_n

    def run_simulation_step(self, t, speed, steer):
        fl, fr, ice = self.calculate_torque_vectoring(steer, 1.0)
        df = self.get_aerodynamics(speed)
        
        # HUD Data Stream
        return TelemetryFrame(
            timestamp=t,
            velocity=speed,
            total_torque_nm=fl + fr + ice,
            front_left_torque=fl,
            front_right_torque=fr,
            ers_soc=self.current_soc,
            downforce_n=df
        )

# --- HUD Rendering Engine ---
def render_developer_hud(frame: TelemetryFrame):
    print(f"[{frame.timestamp:.2f}s] F80_CORE_TELEMETRY")
    print(f" ├─ VELOCITY: {frame.velocity} km/h")
    print(f" ├─ DOWNFORCE: {frame.downforce_n:.1f} N")
    print(f" └─ TORQUE_BIAS [L: {frame.front_left_torque:.0f}Nm | R: {frame.front_right_torque:.0f}Nm]")
    print("-" * 45)

# Execution Instance
f80_ecu = FerrariF80ECU()
for i in range(3):
    test_speed = 100 + (i * 75)
    test_steer = 15.0 # Degree turn
    telemetry = f80_ecu.run_simulation_step(time.time(), test_speed, test_steer)
    render_developer_hud(telemetry)
