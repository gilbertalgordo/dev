def calculate_automotive_ke(mass_kg, velocity_kmh):
    """
    Calculates the kinetic energy of a vehicle.
    :param mass_kg: Mass of the vehicle in kilograms
    :param velocity_kmh: Speed in kilometers per hour
    :return: Kinetic energy in Joules
    """
    # Convert km/h to m/s (1 km/h = 1/3.6 m/s)
    velocity_ms = velocity_kmh / 3.6
    
    # Apply the formula: 0.5 * m * v^2
    kinetic_energy = 0.5 * mass_kg * (velocity_ms ** 2)
    
    return kinetic_energy

# Example Instance: A 1,500kg car traveling at 100km/h
car_mass = 1500
car_speed = 100

energy = calculate_automotive_ke(car_mass, car_speed)

print(f"Vehicle Mass: {car_mass} kg")
print(f"Vehicle Speed: {car_speed} km/h")
print(f"Kinetic Energy: {energy:,.2f} Joules")



#include <iostream>
#include <cmath>

struct VehicleHUD {
    float mass;         // kg
    float currentSpeed; // m/s
    float kineticEnergy;

    void updateKE() {
        // High-accuracy scientific calculation
        kinetic_energy = 0.5f * mass * std::pow(currentSpeed, 2);
    }
};

int main() {
    VehicleHUD myCar = {1800.0f, 27.78f, 0.0f}; // ~100 km/h
    myCar.updateKE();
    
    std::cout << "HUD Update -> KE: " << myCar.kineticEnergy << " J" << std::endl;
    return 0;
}



import math

class RotatingComponent:
    def __init__(self, name, mass, radius, shape_factor=0.5):
        """
        shape_factor: 0.5 for solid cylinder (wheels), 1.0 for thin hoop.
        """
        self.name = name
        self.mass = mass
        self.radius = radius
        # Moment of Inertia: I = k * m * r^2
        self.inertia = shape_factor * mass * (radius**2)

    def get_rotational_energy(self, linear_velocity):
        # Angular velocity omega = v / r
        omega = linear_velocity / self.radius
        return 0.5 * self.inertia * (omega**2)

class VehicleInstance:
    def __init__(self, chassis_mass, wheel_count, wheel_mass, wheel_radius):
        self.chassis_mass = chassis_mass
        self.wheels = [RotatingComponent("Wheel", wheel_mass, wheel_radius) for _ in range(wheel_count)]

    def calculate_total_energy(self, velocity_kmh):
        v_ms = velocity_kmh / 3.6
        
        # 1. Translational Energy (Chassis + Wheels moving forward)
        total_mass = self.chassis_mass + sum(w.mass for w in self.wheels)
        e_trans = 0.5 * total_mass * (v_ms**2)
        
        # 2. Rotational Energy (Wheels spinning)
        e_rot = sum(w.get_rotational_energy(v_ms) for w in self.wheels)
        
        return {
            "Total Energy (J)": e_trans + e_rot,
            "Translational (%)": (e_trans / (e_trans + e_rot)) * 100,
            "Rotational (%)": (e_rot / (e_trans + e_rot)) * 100
        }

# Example: Performance EV (2000kg, four 15kg wheels)
tesla_model_s = VehicleInstance(chassis_mass=1940, wheel_count=4, wheel_mass=15, wheel_radius=0.35)
metrics = tesla_model_s.calculate_total_energy(120)

for key, value in metrics.items():
    print(f"{key}: {value:.2f}")



#include <iostream>
#include <vector>

struct TelemetryData {
    double velocity;       // m/s
    double totalEnergy;    // Joules
    double rollingInertia; // Sum of I
};

class HUDPhysicsEngine {
public:
    // Pre-calculate constant inertia to save clock cycles during HUD refresh
    double calculateSystemInertia(double wheelMass, double radius, int count) {
        double wheelI = 0.5 * wheelMass * (radius * radius);
        return wheelI * count;
    }

    TelemetryData process(double currentV, double totalMass, double systemInertia) {
        TelemetryData data;
        data.velocity = currentV;
        
        // Advanced KE = 0.5 * (m + I/r^2) * v^2
        // This is a simplified effective mass calculation for real-time HUDs
        double translation = 0.5 * totalMass * (currentV * currentV);
        double rotation = 0.5 * systemInertia * (currentV / 0.35 * currentV / 0.35);
        
        data.totalEnergy = translation + rotation;
        return data;
    }
};
