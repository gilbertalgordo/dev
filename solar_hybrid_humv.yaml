import math
import random

# --- SYSTEM CONSTANTS AND PARAMETERS ---
# Assumed values for the high-level system components.
SOLAR_EFFICIENCY = 0.18  # 18% efficiency for advanced integrated solar cells
BATTERY_CAPACITY_KWH = 20.0  # Total capacity of the Power Block Transfer (PBT) battery pack
MAX_MOTOR_POWER_KW = 150.0  # Peak power demand of the electric motor
SYSTEM_VOLTAGE = 400.0  # High voltage bus (in Volts)

# Areas in square meters (m^2) for the 'secret' solar surfaces
AREA_WINDOW_WINDSHIELD = 3.5
AREA_HOOD_ROOF = 5.0
TOTAL_SOLAR_AREA = AREA_WINDOW_WINDSHIELD + AREA_HOOD_ROOF

# MPPT/Battery simulation parameters
CHARGE_EFFICIENCY = 0.95  # Battery charging efficiency
DISCHARGE_EFFICIENCY = 0.98 # Battery discharging efficiency
IRRADIANCE_MAX = 1000 # Max solar irradiance (W/m^2)

class SolarSurface:
    """Represents an integrated photovoltaic surface (window, hood, etc.)."""
    def __init__(self, name: str, area: float, efficiency: float):
        self.name = name
        self.area = area
        self.efficiency = efficiency

    def calculate_raw_power(self, irradiance_w_m2: float) -> float:
        """
        Calculates raw theoretical power output in Watts (W) based on irradiance.
        
        Power (W) = Irradiance (W/m^2) * Area (m^2) * Efficiency
        """
        raw_power_w = irradiance_w_m2 * self.area * self.efficiency
        return raw_power_w

class MPPT_Controller:
    """
    Simulates the Maximum Power Point Tracking (MPPT) logic.
    In a real system, this would use Perturb and Observe or Incremental Conductance.
    Here, it simulates the conversion efficiency and voltage regulation.
    """
    def __init__(self, voltage: float):
        self.output_voltage = voltage
        self.conversion_loss = 0.05  # 5% energy loss during DC-DC conversion (MPPT)
        self.last_power = 0.0
        self.last_current = 0.0

    def get_max_power_output(self, raw_solar_power_w: float) -> float:
        """
        Calculates the usable power output after MPPT conversion losses.
        (Output is in kW for system management consistency)
        """
        mppt_power_w = raw_solar_power_w * (1.0 - self.conversion_loss)
        return mppt_power_w / 1000.0  # Convert to kW

class PBT_System:
    """
    Power Block Transfer System: Manages energy flow and battery State of Charge (SOC).
    This acts as the central power distribution unit.
    """
    def __init__(self, capacity_kwh: float, charge_eff: float, discharge_eff: float):
        self.capacity_kwh = capacity_kwh
        self.charge_efficiency = charge_eff
        self.discharge_efficiency = discharge_eff
        # SOC is stored as a percentage (0.0 to 100.0)
        self.soc_percent = 80.0 

    def update_soc(self, net_energy_kwh: float):
        """
        Updates the State of Charge based on net energy flow (charge/discharge).
        Takes net energy in kWh.
        """
        # Convert net energy (kWh) to SOC percentage change
        
        if net_energy_kwh > 0:
            # Charging: Apply charging loss
            chargeable_energy_kwh = net_energy_kwh * self.charge_efficiency
        else:
            # Discharging: Apply discharging loss (requires more battery energy to output same power)
            chargeable_energy_kwh = net_energy_kwh / self.discharge_efficiency

        soc_change = (chargeable_energy_kwh / self.capacity_kwh) * 100.0
        self.soc_percent += soc_change

        # Clamping SOC between 0% and 100%
        self.soc_percent = max(0.0, min(100.0, self.soc_percent))
        
        if self.soc_percent == 0.0 and net_energy_kwh < 0:
            print(f"--- Battery DEPLETED at {self.soc_percent:.2f}% ---")
        elif self.soc_percent == 100.0 and net_energy_kwh > 0:
            print(f"--- Battery FULL at {self.soc_percent:.2f}% ---")
            
        return self.soc_percent

    def get_soc_kwh(self) -> float:
        """Returns the current energy stored in kWh."""
        return (self.soc_percent / 100.0) * self.capacity_kwh

class HybridHumvee:
    """The main simulation class for the hybrid Humvee power system."""
    def __init__(self):
        # Initialize solar surfaces (secretly integrated PV)
        self.solar_surfaces = [
            SolarSurface("Windows/Windshield", AREA_WINDOW_WINDSHIELD, SOLAR_EFFICIENCY),
            SolarSurface("Hood/Roof", AREA_HOOD_ROOF, SOLAR_EFFICIENCY)
        ]
        self.mppt = MPPT_Controller(SYSTEM_VOLTAGE)
        self.pbt = PBT_System(BATTERY_CAPACITY_KWH, CHARGE_EFFICIENCY, DISCHARGE_EFFICIENCY)
        self.max_motor_power_kw = MAX_MOTOR_POWER_KW

    def simulate_hour(self, hour: int, irradiance_w_m2: float, motor_demand_kw: float) -> dict:
        """
        Simulates one hour of operation.
        :param hour: The hour of the day (for logging).
        :param irradiance_w_m2: The solar irradiance for this hour (W/m^2).
        :param motor_demand_kw: The power demanded by the electric drive motor (kW).
        :return: Dictionary of performance metrics for the hour.
        """
        
        # 1. Total Solar Power Harvesting (W)
        total_raw_solar_w = sum(s.calculate_raw_power(irradiance_w_m2) for s in self.solar_surfaces)
        
        # 2. MPPT Output (Usable Power, kW)
        solar_supply_kw = self.mppt.get_max_power_output(total_raw_solar_w)

        # 3. Power Block Transfer (PBT) Logic
        
        # Calculate the power deficit or surplus (kW)
        net_power_flow_kw = solar_supply_kw - motor_demand_kw
        
        # Determine the action (Charge, Discharge, or Buffer)
        if net_power_flow_kw > 0:
            # Surplus: Charge the battery (net_energy_kwh is positive)
            energy_exchange_kwh = net_power_flow_kw * 1  # 1 hour duration
            pbt_action = "CHARGE"
        elif net_power_flow_kw < 0:
            # Deficit: Discharge battery to cover the shortfall (net_energy_kwh is negative)
            # Check if battery can cover the deficit
            required_kwh = abs(net_power_flow_kw) * 1
            available_kwh = self.pbt.get_soc_kwh()
            
            if required_kwh > available_kwh:
                # Critical: Not enough battery power, system must enter limp mode or activate fossil fuel backup
                pbt_action = "CRITICAL_DEFICIT"
                energy_exchange_kwh = -available_kwh # Drain remaining energy
                power_deficit_kw = required_kwh - available_kwh
                # In a real hybrid, the diesel engine would start here to provide the power_deficit_kw
            else:
                pbt_action = "DISCHARGE"
                energy_exchange_kwh = net_power_flow_kw * 1 # net_power_flow_kw is already negative
        else:
            # Buffer state: Demand perfectly matches supply
            pbt_action = "BUFFER"
            energy_exchange_kwh = 0.0
            
        # 4. Update Battery SOC
        initial_soc = self.pbt.soc_percent
        final_soc = self.pbt.update_soc(energy_exchange_kwh)
        
        return {
            "hour": hour,
            "irradiance_w_m2": irradiance_w_m2,
            "motor_demand_kw": motor_demand_kw,
            "solar_supply_kw": solar_supply_kw,
            "net_flow_kw": net_power_flow_kw,
            "pbt_action": pbt_action,
            "soc_initial": initial_soc,
            "soc_final": final_soc
        }

# --- SIMULATION SCENARIO ---

def run_simulation(humvee: HybridHumvee, hours: list):
    """Runs a 24-hour simulation."""
    print("--- Hybrid Humvee MPPT/PBT Simulation Start ---")
    print(f"Total Solar Area: {humvee.solar_surfaces[0].area + humvee.solar_surfaces[1].area} m²")
    print(f"Battery Capacity: {humvee.pbt.capacity_kwh} kWh | Initial SOC: {humvee.pbt.soc_percent:.2f}%\n")
    
    results = []
    
    for hour, (irradiance, demand) in enumerate(hours):
        # Simulate an hour of operation
        result = humvee.simulate_hour(hour, irradiance, demand)
        results.append(result)
        
        # Display hourly results
        print(f"Hour {result['hour']:02d} | Irradiance: {irradiance:4d} W/m² | Motor Demand: {demand:5.1f} kW | "
              f"Solar Supply: {result['solar_supply_kw']:5.1f} kW | Net Flow: {result['net_flow_kw']:5.1f} kW | "
              f"PBT Action: {result['pbt_action']:10s} | SOC: {result['soc_initial']:.2f}% -> {result['soc_final']:.2f}%")

    print("\n--- Simulation Complete ---")
    
# Example 24-hour mission profile (Irradiance W/m², Motor Demand kW)
# Note: Demand is scaled for a realistic patrol/operation cycle.

MISSION_PROFILE = [
    (0, 5.0),    # 00:00 (Night, Idling)
    (0, 10.0),   # 01:00 (Night, Moving slowly)
    (0, 5.0),    # 02:00
    (0, 5.0),    # 03:00
    (0, 5.0),    # 04:00
    (50, 15.0),   # 05:00 (Dawn, Pre-operation check)
    (200, 20.0),  # 06:00 (Sun rising, Light patrol)
    (500, 30.0),  # 07:00
    (800, 50.0),  # 08:00 (Peak operation, High demand)
    (950, 40.0),  # 09:00 (High solar charge potential)
    (1000, 10.0), # 10:00 (Mid-day, Halted, High charge) - MPPT is critical here
    (900, 15.0),  # 11:00
    (850, 35.0),  # 12:00
    (700, 45.0),  # 13:00 (High demand again)
    (500, 30.0),  # 14:00
    (300, 10.0),  # 15:00
    (100, 5.0),   # 16:00 (Sun setting)
    (0, 2.0),     # 17:00 (Dusk, Lights on, Low demand)
    (0, 10.0),    # 18:00 (Night Patrol)
    (0, 15.0),    # 19:00
    (0, 5.0),     # 20:00
    (0, 5.0),     # 21:00
    (0, 5.0),     # 22:00
    (0, 5.0),     # 23:00
]

# Run the simulation
humvee_system = HybridHumvee()
run_simulation(humvee_system, MISSION_PROFILE)

                 
