pip install pillow qrcode[pil]


from PIL import Image, ImageDraw, ImageFont, ImageOps
import qrcode

# Configuration
card_width, card_height = 600, 400
background_color = (245, 245, 247)
accent_color = (10, 78, 120)
watermark_text = "SAMPLE — FOR PROP USE ONLY"
name = "G I L B E R T  A L G O R D O"
role = "SPECIAL AGENT (PROP)"
organization = "DEMONSTRATION PURPOSES ONLY"
url = "https://g.dev/gilbert_algordo"
photo_placeholder_color = (200, 200, 200)

# Fonts: system fallback if a TTF not available
try:
    header_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 28)
    body_font = ImageFont.truetype("DejaVuSans.ttf", 18)
    watermark_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 40)
except Exception:
    header_font = ImageFont.load_default()
    body_font = ImageFont.load_default()
    watermark_font = ImageFont.load_default()

# Create base card
card = Image.new("RGB", (card_width, card_height), background_color)
draw = ImageDraw.Draw(card)

# Left area: photo placeholder
photo_box = (30, 30, 230, 230)
draw.rectangle(photo_box, fill=photo_placeholder_color, outline=(160,160,160))
draw.line([photo_box[0], photo_box[1], photo_box[2], photo_box[3]], fill=(180,180,180))
draw.line([photo_box[2], photo_box[1], photo_box[0], photo_box[3]], fill=(180,180,180))
draw.text((photo_box[0]+10, photo_box[3]+6), "PHOTO\nPLACEHOLDER", fill=(100,100,100), font=body_font)

# Right area: text fields
x_text = 260
y = 40
draw.text((x_text, y), "IDENTIFICATION", fill=accent_color, font=header_font)
y += 40
draw.text((x_text, y), name, fill=(0,0,0), font=header_font)
y += 40
draw.text((x_text, y), role, fill=(0,0,0), font=body_font)
y += 28
draw.text((x_text, y), organization, fill=(0,0,0), font=body_font)
y += 40
draw.text((x_text, y), "URL:", fill=(80,80,80), font=body_font)
draw.text((x_text+40, y), url, fill=(0,0,128), font=body_font)

# Generate QR code for the URL, paste bottom-right
qr = qrcode.QRCode(box_size=3, border=1)
qr.add_data(url)
qr.make(fit=True)
qr_img = qr.make_image(fill_color="black", back_color="white").convert("RGB")
qr_size = 120
qr_img = qr_img.resize((qr_size, qr_size), Image.NEAREST)
card.paste(qr_img, (card_width - qr_size - 30, card_height - qr_size - 30))

# Add organization stripe at top
stripe_height = 28
draw.rectangle([(0,0),(card_width, stripe_height)], fill=accent_color)
draw.text((16, 4), "OFFICIAL (PROP) — DEMONSTRATION ONLY", fill=(255,255,255), font=body_font)

# Prominent red diagonal watermark
wm = Image.new("RGBA", card.size, (255,255,255,0))
wm_draw = ImageDraw.Draw(wm)
w_w, w_h = watermark_font.getsize(watermark_text)
# Draw repeated diagonal watermark for visibility
for i in range(-2, 6):
    x = -card_width + i * int(card_width/4)
    y = int(card_height * 0.35)
    wm_draw.text((x, y), watermark_text, fill=(200,0,0,80), font=watermark_font)
watermark = wm.rotate(-20, expand=0)
card = Image.alpha_composite(card.convert("RGBA"), watermark).convert("RGB")

# Save
output_filename = "prop_id_sample.png"
card.save(output_filename, dpi=(300,300))
print(f"Saved prop ID to {output_filename}")


# models.py
from datetime import datetime
from sqlalchemy import (Column, Integer, String, DateTime, Boolean, JSON, ForeignKey)
from sqlalchemy.orm import relationship, declarative_base

Base = declarative_base()

class Role(Base):
    __tablename__ = "roles"
    id = Column(Integer, primary_key=True)
    name = Column(String(64), unique=True, nullable=False)
    permissions = Column(JSON, default=list)  # list of permission strings

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String(128), unique=True, nullable=False)
    full_name = Column(String(256))
    email = Column(String(256), unique=True, nullable=False)
    role_id = Column(Integer, ForeignKey("roles.id"))
    role = relationship("Role")
    created_at = Column(DateTime, default=datetime.utcnow)

class BadgeRequest(Base):
    __tablename__ = "badge_requests"
    id = Column(Integer, primary_key=True)
    requester_id = Column(Integer, ForeignKey("users.id"))
    requester = relationship("User", foreign_keys=[requester_id])
    purpose = Column(String(512))
    status = Column(String(32), default="PENDING")  # PENDING / APPROVED / REJECTED
    admin_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    admin = relationship("User", foreign_keys=[admin_id])
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class Badge(Base):
    __tablename__ = "badges"
    id = Column(Integer, primary_key=True)
    badge_uid = Column(String(128), unique=True, nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"))
    user = relationship("User")
    issued_by = Column(Integer, ForeignKey("users.id"))
    issued_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=True)
    metadata = Column(JSON, default={})
    revoked = Column(Boolean, default=False)

class AuditLog(Base):
    __tablename__ = "audit_log"
    id = Column(Integer, primary_key=True)
    event = Column(String(256))
    payload = Column(JSON)
    actor_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# auth.py
import os
import jwt
from datetime import datetime, timedelta
from functools import wraps
from flask import request, jsonify, current_app

# ADMIN_JWT_SECRET is for admin authentication tokens (use KMS or env var)
ADMIN_JWT_SECRET = os.environ.get("ADMIN_JWT_SECRET", "dev-secret-change-me")
ADMIN_JWT_ALGO = "HS256"

def generate_admin_token(admin_user_id, minutes=60):
    payload = {
        "sub": str(admin_user_id),
        "iat": datetime.utcnow(),
        "exp": datetime.utcnow() + timedelta(minutes=minutes),
        "role": "admin"
    }
    return jwt.encode(payload, ADMIN_JWT_SECRET, algorithm=ADMIN_JWT_ALGO)

def require_admin(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "):
            return jsonify({"error": "missing token"}), 401
        token = auth.split(" ", 1)[1]
        try:
            data = jwt.decode(token, ADMIN_JWT_SECRET, algorithms=[ADMIN_JWT_ALGO])
        except Exception as e:
            return jsonify({"error": "invalid token", "detail": str(e)}), 401
        if data.get("role") != "admin":
            return jsonify({"error": "insufficient role"}), 403
        # attach admin identity to request
        request.admin_id = int(data["sub"])
        return f(*args, **kwargs)
    return wrapper


    # badge_generator.py
import uuid
import io
from datetime import datetime, timedelta
from PIL import Image, ImageDraw, ImageFont
import qrcode
import jwt
import base64
import os

# Use RS256 with private key from KMS/HSM in production.
PRIVATE_KEY_PEM = os.environ.get("BADGE_PRIVATE_KEY_PEM")  # load from secure store
PUBLIC_KEY_PEM = os.environ.get("BADGE_PUBLIC_KEY_PEM")

JWT_ALGO = "RS256" if PRIVATE_KEY_PEM else "HS256"
JWT_SECRET = os.environ.get("BADGE_HS_SECRET", "dev-badge-secret")

def create_badge_jwt(badge_id, user_info, expires_minutes=8*60):
    now = datetime.utcnow()
    payload = {
        "badge_id": badge_id,
        "user": {
            "id": user_info["id"],
            "name": user_info["full_name"],
            "role": user_info["role"]
        },
        "iat": now.timestamp(),
        "exp": (now + timedelta(minutes=expires_minutes)).timestamp(),
        "iss": "internal-badge-service"
    }
    if JWT_ALGO == "RS256" and PRIVATE_KEY_PEM:
        token = jwt.encode(payload, PRIVATE_KEY_PEM, algorithm="RS256")
    else:
        token = jwt.encode(payload, JWT_SECRET, algorithm="HS256")
    return token

def generate_badge_image(user_info, badge_uid, token, org_name="Example Org"):
    # creates a 600x400 PNG with QR code and textual data
    w, h = 800, 500
    im = Image.new("RGB", (w,h), (255,255,255))
    d = ImageDraw.Draw(im)
    # fonts
    try:
        header_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 32)
        body_font = ImageFont.truetype("DejaVuSans.ttf", 18)
    except Exception:
        header_font = ImageFont.load_default()
        body_font = ImageFont.load_default()

    d.text((24,20), org_name, font=header_font, fill=(0,0,0))
    d.text((24,80), f"Name: {user_info['full_name']}", font=body_font, fill=(0,0,0))
    d.text((24,110), f"Role: {user_info['role']}", font=body_font, fill=(0,0,0))
    d.text((24,140), f"Badge UID: {badge_uid}", font=body_font, fill=(80,80,80))

    # QR contains verification URL with token
    verification_url = f"https://badge.example.org/verify?token={token}"
    qr = qrcode.QRCode(box_size=4, border=1)
    qr.add_data(verification_url)
    qr.make(fit=True)
    qr_img = qr.make_image(fill_color="black", back_color="white").convert("RGB")
    qr_img = qr_img.resize((240,240), Image.NEAREST)
    im.paste(qr_img, (w - qr_img.width - 40, 80))

    # watermark if needed for prop: clearly mark non-official
    # d.text((w//2 - 100, h-50), "SAMPLE — NOT A REAL CREDENTIAL", font=body_font, fill=(200,0,0))

    # return bytes
    buf = io.BytesIO()
    im.save(buf, format="PNG")
    buf.seek(0)
    return buf

# Example create flow:
# badge_uid = str(uuid.uuid4())
# token = create_badge_jwt(badge_uid, user_info)
# img_bytes = generate_badge_image(user_info, badge_uid, token)


# app.py
from flask import Flask, request, jsonify, send_file
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base, User, BadgeRequest, Badge, AuditLog, Role
from auth import require_admin, generate_admin_token
from badge_generator import create_badge_jwt, generate_badge_image
import uuid
import os

DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://user:pass@localhost/badgedb")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

app = Flask(__name__)

@app.route("/request_badge", methods=["POST"])
def request_badge():
    session = SessionLocal()
    data = request.json
    # minimal validation — in production validate auth
    requester_id = data.get("requester_id")
    purpose = data.get("purpose", "")
    req = BadgeRequest(requester_id=requester_id, purpose=purpose)
    session.add(req)
    session.commit()
    session.refresh(req)
    # audit
    session.add(AuditLog(event="badge_request_created", payload={"request_id": req.id, "requester_id": requester_id}))
    session.commit()
    return jsonify({"request_id": req.id, "status": req.status}), 201

@app.route("/admin/approve/<int:request_id>", methods=["POST"])
@require_admin
def approve_request(request_id):
    session = SessionLocal()
    admin_id = request.admin_id
    req = session.query(BadgeRequest).get(request_id)
    if not req:
        return jsonify({"error": "not found"}), 404
    if req.status != "PENDING":
        return jsonify({"error": "invalid state"}), 400
    # approve
    req.status = "APPROVED"
    req.admin_id = admin_id
    session.add(req)
    # issue badge
    badge_uid = str(uuid.uuid4())
    # fetch user info
    user = session.query(User).get(req.requester_id)
    badge = Badge(badge_uid=badge_uid, user_id=user.id, issued_by=admin_id)
    session.add(badge)
    session.add(AuditLog(event="badge_issued", payload={"badge_id": badge_uid, "user_id": user.id, "issued_by": admin_id}))
    session.commit()
    # create signed token and image
    user_info = {"id": user.id, "full_name": user.full_name or user.username, "role": user.role.name if user.role else "N/A"}
    token = create_badge_jwt(badge_uid, user_info)
    image_buf = generate_badge_image(user_info, badge_uid, token, org_name="DEMO ORG")
    session.close()
    return send_file(image_buf, mimetype="image/png", as_attachment=True, download_name=f"badge_{badge_uid}.png")

@app.route("/verify", methods=["GET"])
def verify():
    token = request.args.get("token")
    if not token:
        return jsonify({"valid": False, "reason": "missing token"}), 400
    # verify signature and expiry
    from jose import jwt as jose_jwt
    # In prod use RS256 with PUBLIC_KEY_PEM
    try:
        if os.environ.get("BADGE_PUBLIC_KEY_PEM"):
            payload = jose_jwt.decode(token, os.environ["BADGE_PUBLIC_KEY_PEM"], algorithms=["RS256"], options={"verify_aud": False})
        else:
            payload = jose_jwt.decode(token, os.environ.get("BADGE_HS_SECRET", "dev-badge-secret"), algorithms=["HS256"], options={"verify_aud": False})
    except Exception as e:
        return jsonify({"valid": False, "reason": str(e)}), 401
    # check DB for badge revoked/expiry
    session = SessionLocal()
    badge_uid = payload.get("badge_id")
    badge = session.query(Badge).filter_by(badge_uid=badge_uid).first()
    if not badge or badge.revoked:
        return jsonify({"valid": False, "reason": "badge invalid or revoked"}), 403
    # if everything ok
    session.add(AuditLog(event="badge_verified", payload={"badge_id": badge_uid, "payload": payload}))
    session.commit()
    session.close()
    return jsonify({"valid": True, "badge_id": badge_uid, "user": payload.get("user")})

    
