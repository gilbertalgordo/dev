import pandas as pd
from sklearn.ensemble import IsolationForest
import re
from datetime import date

# --- 1. AI-Powered Compliance Data Management (Anti-Red Tape Feature) ---
# Goal: Automatically parse and structure regulatory data to eliminate manual updates.

def parse_tax_regulation(regulation_text):
    """
    A simple NLP-like function to extract key values from regulation text.
    In a real system, this would be a full-fledged NLP model (e.g., BERT).
    """
    print(f"-> AI Reading new regulation text: '{regulation_text[:30]}...'")
    
    # Simple regex to extract tax rate and effective date
    tax_rate_match = re.search(r'rate is raised to (\d+\.\d+)%', regulation_text)
    effective_date_match = re.search(r'effective (\d{4}-\d{2}-\d{2})', regulation_text)
    
    # Structure the extracted data
    regulatory_update = {
        'EffectiveDate': effective_date_match.group(1) if effective_date_match else date.today().isoformat(),
        'TaxRate_Federal': float(tax_rate_match.group(1)) / 100 if tax_rate_match else 0.15,
        'Source': 'Federal Regulation 2026-A',
        'ComplianceStatus': 'AWAITING_APPLICATION'
    }
    
    return regulatory_update

# Mock Regulatory Input (The "Red Tape" to be automated)
new_law_text = "The national income tax rate is raised to 18.5% for all tiers, effective 2026-01-01. This replaces the old 15% rate."
compliance_data = parse_tax_regulation(new_law_text)
print("\n**Structured Compliance Data:**")
print(compliance_data)

# --- 2. Anomaly Detection Model (Anti-Red Tape Feature) ---
# Goal: Use ML to proactively find errors (anomalies) before the payroll run.

def train_anomaly_model(historical_data):
    """Trains an Isolation Forest model on historical payroll metrics."""
    # Features for anomaly detection: Hours Worked, Base Pay, Total Deductions
    features = ['HoursWorked', 'BasePay', 'TotalDeductions']
    X = historical_data[features]
    
    # Train the model (Isolation Forest is good for outlier detection)
    model = IsolationForest(contamination=0.05, random_state=42) # Expect 5% anomalies
    model.fit(X)
    return model

def detect_anomalies(model, new_payroll_data):
    """Uses the model to score new payroll data for anomalies."""
    features = ['HoursWorked', 'BasePay', 'TotalDeductions']
    X_new = new_payroll_data[features]
    
    # Predict anomalies: -1 for outlier, 1 for inlier
    new_payroll_data['Anomaly_Score'] = model.decision_function(X_new)
    new_payroll_data['Is_Anomaly'] = model.predict(X_new)
    
    anomalies = new_payroll_data[new_payroll_data['Is_Anomaly'] == -1]
    return anomalies

# Mock Data
historical_payroll = pd.DataFrame({
    'EmployeeID': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'HoursWorked': [160, 160, 165, 158, 160, 159, 160, 162, 160, 160],
    'BasePay': [4000, 5500, 4200, 3800, 6000, 4100, 4000, 5500, 4000, 4200],
    'TotalDeductions': [800, 1100, 840, 760, 1200, 820, 800, 1100, 800, 840]
})

# New Data (Employee 7 has a suspicious, low deduction)
new_payroll = pd.DataFrame({
    'EmployeeID': [11, 12, 13],
    'HoursWorked': [160, 160, 160],
    'BasePay': [5000, 5200, 5000],
    'TotalDeductions': [1000, 1040, **50**] # ANOMALY: Deduction is too low
})

# Train & Detect
anomaly_model = train_anomaly_model(historical_payroll)
anomalous_records = detect_anomalies(anomaly_model, new_payroll.copy())

print("\n**Anomaly Detection Results (Anti-Red Tape - Proactive Check):**")
if not anomalous_records.empty:
    print("ðŸš¨ **Anti-Red Tape Alert:** Potential Payroll Discrepancies Found!")
    # Anti-Red Tape benefit: Stop the error *before* it becomes a headache.
    print(anomalous_records[['EmployeeID', 'TotalDeductions', 'Anomaly_Score']])
else:
    print("âœ… No significant anomalies detected in the new payroll batch.")

# --- 3. Simple Payroll Calculation Engine ---
def calculate_net_pay(hours, base_pay, tax_rate, deductions):
    """Calculates a simplified net pay."""
    gross_pay = base_pay * (hours / 160) # Simplified scale factor
    tax_amount = gross_pay * tax_rate
    net_pay = gross_pay - tax_amount - deductions
    return net_pay

# Use the AI-derived tax rate
tax_rate = compliance_data['TaxRate_Federal']
employee_11_net_pay = calculate_net_pay(160, 5000, tax_rate, 1000)

print(f"\n**Final Payroll Calculation (Using AI-Derived Rate {tax_rate:.2%}):**")
print(f"Employee 11 Net Pay: ${employee_11_net_pay:.2f}")



import re
from datetime import datetime, date

class NLPLawInterpreter:
    """
    AI Agent for converting unstructured regulatory text (the 'Red Tape') 
    into structured, actionable payroll data parameters.
    """
    def __init__(self, current_laws=None):
        # Stores structured, machine-readable laws
        self.laws = current_laws if current_laws is not None else {}
        print("NLP Agent Initialized: Ready to interpret new regulations.")

    def parse_regulation(self, regulation_text, law_id):
        """
        [Scientific Reasoning] Use regex (placeholder for advanced LLM/Transformer) 
        to extract key numerical and date entities.
        """
        print(f"\n--- NLP Processing Law ID: {law_id} ---")
        
        # 1. Extract Federal Tax Rate Change (Instance 1)
        # Target: "Federal income tax rate is raised to 18.75% effective 2026-01-01."
        tax_rate_match = re.search(r'tax rate is raised to (\d+\.\d+)%', regulation_text)
        date_match = re.search(r'effective (\d{4}-\d{2}-\d{2})', regulation_text)
        
        # 2. Extract Overtime Threshold Change (Instance 2)
        # Target: "Overtime eligibility threshold is increased to $70,000 yearly salary."
        ot_threshold_match = re.search(r'Overtime eligibility threshold is increased to \$(\d{1,3}(?:,\d{3})*)', regulation_text)

        structured_data = {
            'last_updated': datetime.now().isoformat(),
            'status': 'Parsed & Awaiting Approval', # Clear Voice status
        }
        
        # Structure the extracted data
        if tax_rate_match and date_match:
            structured_data['FEDERAL_TAX_RATE'] = {
                'rate': float(tax_rate_match.group(1)) / 100,
                'effective': date_match.group(1),
                'description': 'Automated Federal Tax Update'
            }
        
        if ot_threshold_match:
            # Clean up the number string (remove comma)
            threshold = int(ot_threshold_match.group(1).replace(',', ''))
            structured_data['OT_THRESHOLD_SALARY'] = {
                'value': threshold,
                'description': 'Automated Overtime Threshold Update'
            }

        self.laws[law_id] = structured_data
        print(f"**Clear Voices Output:** Successfully structured {len(structured_data) - 2} key updates.")
        return structured_data

# --- Usage Instance ---
regulation_text_new = "By order of the Treasury, the Federal income tax rate is raised to 18.75% effective 2026-01-01. Furthermore, the Overtime eligibility threshold is increased to $70,000 yearly salary, pending state review."
agent = NLPLawInterpreter()
structured_law = agent.parse_regulation(regulation_text_new, 'LAW_2026_01')


import hashlib
import json
from time import time

class PayrollBlock:
    """Represents a single, immutable payroll record block."""
    def __init__(self, index, timestamp, transactions, prev_hash=''):
        self.index = index
        self.timestamp = timestamp
        self.transactions = transactions # Pay calculation, deduction, tax application
        self.prev_hash = prev_hash
        self.nonce = 0 # For proof-of-work/security
        self.hash = self.compute_hash()

    def compute_hash(self):
        """Generates the SHA-256 hash for the block content."""
        block_string = json.dumps(self.__dict__, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()

class PayrollLedger:
    """The Immutable Ledger for all payroll activity (Anti-Red Tape Audit Trail)."""
    def __init__(self):
        self.chain = []
        self.pending_transactions = []
        self.create_genesis_block()
        print("Blockchain Audit Ledger Initialized.")

    def create_genesis_block(self):
        """The first block in the chain."""
        self.chain.append(PayrollBlock(0, time(), "Genesis Block - Ledger Started", "0"))
    
    @property
    def last_block(self):
        return self.chain[-1]

    def record_transaction(self, employee_id, action, amount, context):
        """Records a transparent payroll action."""
        transaction = {
            'employee_id': employee_id,
            'action': action,
            'amount': amount,
            'context': context,
            'timestamp': time()
        }
        self.pending_transactions.append(transaction)
        print(f"-> Audit Trail: Recorded {action} for Employee {employee_id}")

    def mine_pending_transactions(self):
        """Adds all pending transactions to a new, validated block."""
        index = len(self.chain)
        timestamp = time()
        prev_hash = self.last_block.hash
        
        # Create the new block and compute its hash (Proof-of-Authority/Work in advanced systems)
        new_block = PayrollBlock(index, timestamp, self.pending_transactions, prev_hash)
        new_block.hash = new_block.compute_hash()
        
        self.chain.append(new_block)
        self.pending_transactions = []
        
        print(f"**Clear Voices Output:** New Block {index} added to Ledger. Transactions secured.")
        return new_block.hash
        
# --- Usage Instance ---
payroll_ledger = PayrollLedger()

# Record transactions
payroll_ledger.record_transaction(
    employee_id='E1001',
    action='GROSS_PAY_CALCULATION',
    amount=5200.00,
    context='Base salary for 160 hours.'
)
payroll_ledger.record_transaction(
    employee_id='E1001',
    action='TAX_APPLICATION',
    amount=975.00,
    context=f"Federal tax applied at 18.75% rate (Source: LAW_2026_01)"
)

# Run the 'Payroll Mine' (closing the books for the period)
new_block_hash = payroll_ledger.mine_pending_transactions()

# Show the immutable audit trail (HUD Data Instance)
print("\n**HUD Data Instance: Last Audit Block Details**")
print(f"Block Index: {payroll_ledger.last_block.index}")
print(f"Block Hash: {payroll_ledger.last_block.hash}")
print(f"Number of Transactions Secured: {len(payroll_ledger.last_block.transactions)}")
print(f"Transaction 1 (Action): {payroll_ledger.last_block.transactions[0]['action']}")
