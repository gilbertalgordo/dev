class AntiGravityMansion:
    """
    A conceptual model for a mansion equipped with a controllable
    anti-gravity propulsion and stabilization system.
    """

    # --- Static/Defining Properties ---
    def __init__(self, name="Skyholm Residence", base_mass_kg=2_500_000):
        self.name = name
        self.base_mass_kg = base_mass_kg  # Mass of the physical structure
        self.g_constant = 9.81           # Acceleration due to gravity (m/s^2)
        self.status = "LANDED"           # Possible states: LANDED, ASCENDING, FLOATING, DESCENDING

        # --- Anti-Gravity Drive Properties ---
        self.drive_active = False
        self.grav_field_strength_factor = 0.0  # 0.0 (Full Gravity) to 1.0 (Zero Gravity)
        self.power_level_percent = 0          # 0 to 100
        self.current_altitude_m = 0.0
        self.max_altitude_m = 1000.0

    # --- Conceptual Methods (Functions) ---

    def activate_drive(self):
        """Initializes the anti-gravity system."""
        if not self.drive_active:
            print(f"[{self.name}] Anti-Gravity Drive activated.")
            self.drive_active = True
        else:
            print("Drive is already active.")

    def set_field_strength(self, factor):
        """
        Sets the anti-gravity field strength.
        A factor of 1.0 completely nullifies gravity (neutral buoyancy).
        A factor > 1.0 provides thrust for ascent.
        """
        if not self.drive_active:
            print("ERROR: Drive is inactive. Please activate first.")
            return

        # Ensure the factor is within a reasonable operating range
        self.grav_field_strength_factor = max(0.0, min(2.0, factor))
        self.power_level_percent = int(self.grav_field_strength_factor * 100)

        print(f"Anti-Gravity Field set to {self.power_level_percent}% (Factor: {self.grav_field_strength_factor:.2f})")

    def calculate_net_force(self, thrust_factor):
        """
        Calculates the net vertical force (F_net) acting on the mansion.
        $$F_{net} = F_{anti} - F_{grav}$$
        Where $F_{grav} = m \\cdot g$ and $F_{anti} = m \\cdot g \\cdot \\text{thrust\_factor}$
        """
        # F_grav is the constant downward pull
        F_grav = self.base_mass_kg * self.g_constant

        # F_anti is the upward force generated by the drive
        F_anti = self.base_mass_kg * self.g_constant * thrust_factor

        F_net = F_anti - F_grav

        # Determine the status based on net force
        if abs(F_net) < 100: # Threshold for near zero
            self.status = "FLOATING"
        elif F_net > 0:
            self.status = "ASCENDING"
        else:
            self.status = "DESCENDING"

        return F_net

    def lift_off(self, target_factor=1.05):
        """Initiates lift-off sequence."""
        self.activate_drive()
        self.set_field_strength(target_factor) # Set factor slightly above 1.0 for ascent
        F_net = self.calculate_net_force(self.grav_field_strength_factor)

        print(f"\n--- LIFTOFF SEQUENCE ---")
        print(f"Calculated Gravity Force (down): {self.base_mass_kg * self.g_constant:.2f} Newtons")
        print(f"Calculated Anti-Gravity Thrust (up): {self.base_mass_kg * self.g_constant * self.grav_field_strength_factor:.2f} Newtons")
        print(f"Net Force: {F_net:.2f} Newtons. Status: **{self.status}**")
        print(f"Mansion is beginning to ascend.")

    def stabilize_float(self):
        """Sets the field strength to nullify gravity, achieving stable float."""
        self.set_field_strength(1.0)
        self.calculate_net_force(1.0)
        print(f"Net Force is near zero. Status: **{self.status}**")
        print("Mansion is stabilized for floating/hovering.")

    def get_hud_data(self):
        """Displays key operational data (per user request for HUD)."""
        print("\n--- ANTI-GRAVITY HUD ---")
        print(f"Mansion: {self.name}")
        print(f"Status: **{self.status}**")
        print(f"Altitude: {self.current_altitude_m:.1f} / {self.max_altitude_m} meters")
        print(f"Drive Active: {self.drive_active}")
        print(f"Power Level: {self.power_level_percent}%")
        print(f"Field Factor: {self.grav_field_strength_factor:.2f}")
        print("------------------------")


# --- Example Usage ---
# Create an instance of the mansion (as you prefer instances)
MySkyMansion = AntiGravityMansion(name="Aether Palace")
MySkyMansion.get_hud_data()

# Command 1: Initiate Lift Off
MySkyMansion.lift_off()

# Update the altitude conceptually after some time
MySkyMansion.current_altitude_m = 50.0

# Command 2: Check HUD after ascent
MySkyMansion.get_hud_data()

# Command 3: Stabilize at current altitude
MySkyMansion.stabilize_float()

# Command 4: Check final floating HUD
MySkyMansion.current_altitude_m = 50.5
MySkyMansion.get_hud_data()


import time

# --- 1. PID Controller Class ---
class PIDController:
    """
    A Proportional-Integral-Derivative controller for calculating the
    required adjustment (thrust factor) to reach a target setpoint (altitude).
    """
    def __init__(self, Kp, Ki, Kd):
        # PID Gains (Tuning parameters for stability and response)
        self.Kp = Kp  # Proportional Gain (Reacts to current error)
        self.Ki = Ki  # Integral Gain (Corrects for long-term steady-state error)
        self.Kd = Kd  # Derivative Gain (Dampens oscillation based on rate of change)

        self.previous_error = 0.0
        self.integral = 0.0
        self.last_time = time.time()

    def calculate_output(self, setpoint, measured_value):
        """Calculates the control variable output."""
        current_time = time.time()
        delta_time = current_time - self.last_time
        
        # 1. Calculate Error
        error = setpoint - measured_value

        # 2. Proportional Term (P)
        P_out = self.Kp * error

        # 3. Integral Term (I)
        self.integral += error * delta_time
        I_out = self.Ki * self.integral

        # 4. Derivative Term (D)
        derivative = (error - self.previous_error) / delta_time
        D_out = self.Kd * derivative

        # 5. Total Output
        output = P_out + I_out + D_out

        # Update for next iteration
        self.previous_error = error
        self.last_time = current_time

        # The output here is the required *adjustment* (delta) to the Anti-Gravity Factor.
        return output

# --- 2. Anti-Gravity Pad Instance Class ---
class AntiGravityPad:
    """Represents a single physical anti-gravity component."""
    def __init__(self, pad_id, location):
        self.pad_id = pad_id
        self.location = location  # e.g., 'NORTH_EAST', 'SOUTH_WEST'
        self.thrust_factor = 1.0  # Current thrust factor (1.0 = nullifies gravity)
        self.health_percent = 100.0

    def get_thrust(self):
        # Calculate anti-gravity force relative to a single pad's share of total mass
        # F_anti = Base_Force * Thrust_Factor
        return self.thrust_factor

# --- 3. AntiGravityMansion System Class ---
class AdvancedAntiGravityMansion:
    """The central control system for the sky mansion."""
    
    def __init__(self, name="Aether Palace"):
        self.name = name
        self.mass_kg = 3_000_000  # Total mass
        self.g = 9.81              # Gravity constant

        # Create 4 Anti-Gravity Pad instances for stability control
        self.pads = {
            'NE': AntiGravityPad('AG-NE', 'North-East Corner'),
            'NW': AntiGravityPad('AG-NW', 'North-West Corner'),
            'SE': AntiGravityPad('AG-SE', 'South-East Corner'),
            'SW': AntiGravityPad('AG-SW', 'South-West Corner')
        }

        # PID Controller for Altitude (Vertical) control
        # Tuned Kp (Proportional), Ki (Integral), Kd (Derivative)
        self.altitude_pid = PIDController(Kp=0.01, Ki=0.001, Kd=0.05)
        
        # State variables
        self.current_altitude_m = 0.0
        self.target_altitude_m = 0.0
        self.status = "LANDED"

    def update_system(self, dt=1.0):
        """
        Simulates one time step (dt) of the anti-gravity system.
        In a real system, this would run constantly.
        """
        if self.target_altitude_m == self.current_altitude_m:
            self.status = "HOVERING"
        elif self.target_altitude_m > self.current_altitude_m:
            self.status = "ASCENDING"
        elif self.target_altitude_m < self.current_altitude_m:
            self.status = "DESCENDING"
        
        # 1. PID Calculation: Get the required ADJUSTMENT from the controller
        thrust_adjustment = self.altitude_pid.calculate_output(
            setpoint=self.target_altitude_m,
            measured_value=self.current_altitude_m
        )

        # 2. Apply Adjustment to ALL pads (simplified for vertical control)
        # We target a base factor of 1.0 (anti-gravity = gravity) and adjust from there.
        base_target_factor = 1.0 + thrust_adjustment
        
        for pad in self.pads.values():
            pad.thrust_factor = max(0.0, min(2.0, base_target_factor)) # Clamp between 0 and 200%
            
        # 3. Simulate Movement (Simplified Dynamics)
        # Net Force = Sum of Anti-Gravity Forces - Gravity Force
        total_anti_force_factor = sum(pad.get_thrust() for pad in self.pads.values()) / len(self.pads)
        
        F_gravity = self.mass_kg * self.g
        F_anti = F_gravity * total_anti_force_factor
        
        F_net = F_anti - F_gravity
        
        # Acceleration (a) = F_net / mass. Velocity (v) is integral of acceleration.
        # Simple velocity change:
        acceleration = F_net / self.mass_kg
        velocity_change = acceleration * dt
        
        # New altitude:
        self.current_altitude_m += (velocity_change * dt)
        
        # Clamp altitude at ground level
        self.current_altitude_m = max(0.0, self.current_altitude_m)


    def set_target_altitude(self, altitude):
        """User command to change the target altitude."""
        print(f"\n[CONTROL] Setting target altitude to {altitude:.1f} meters.")
        self.target_altitude_m = altitude

    def get_hud_data(self):
        """Displays key operational data (per user request for HUD)."""
        # 
        print("\n--- ADVANCED AG MANSIION HUD ---")
        print(f"Mansion: **{self.name}**")
        print(f"Status: **{self.status}**")
        print(f"Altitude (Current/Target): {self.current_altitude_m:.2f} m / {self.target_altitude_m:.1f} m")
        
        # PID-specific data
        error = self.target_altitude_m - self.current_altitude_m
        print(f"PID Error: {error:.3f} m")
        
        # Pad status overview
        print("\nPad Status (Avg Thrust Factor):")
        avg_factor = sum(pad.thrust_factor for pad in self.pads.values()) / len(self.pads)
        print(f"  **{avg_factor:.4f}** (1.0 = Hover)")
        print(f"  Pads Online: {len(self.pads)}")
        print("--------------------------------")


# --- Example Simulation ---
AetherPalace = AdvancedAntiGravityMansion()
AetherPalace.get_hud_data()

# Command: Take off and ascend
AetherPalace.set_target_altitude(50.0)

# Run simulation steps
print("\n--- SIMULATION RUN ---")
for i in range(1, 15):
    AetherPalace.update_system(dt=0.5) # Time step of 0.5 seconds
    if i % 5 == 0:
        AetherPalace.get_hud_data()
        
# Final state after reaching altitude
print("\n--- FINAL HOVER STATE ---")
AetherPalace.get_hud_data()

