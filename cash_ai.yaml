import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor, IsolationForest
from datetime import datetime, timedelta

class CashAI:
    def __init__(self):
        self.forecast_model = RandomForestRegressor(n_estimators=100, random_state=42)
        self.anomaly_detector = IsolationForest(contamination=0.05, random_state=42)
        
    def prepare_features(self, df):
        """Converts raw transaction data into ML-ready features."""
        df['date'] = pd.to_datetime(df['date'])
        df['day_of_week'] = df['date'].dt.dayofweek
        df['month'] = df['date'].dt.month
        df['day'] = df['date'].dt.day
        return df

    def train_forecast(self, df):
        """Trains the AI to predict future daily cash positions."""
        df = self.prepare_features(df)
        X = df[['day_of_week', 'month', 'day']]
        y = df['balance']
        self.forecast_model.fit(X, y)
        print("✅ Forecast Model trained successfully.")

    def detect_anomalies(self, df):
        """Identifies suspicious transactions (Kaizen: Zero Defects)."""
        # Features for anomaly: Amount and Day
        X = df[['amount', 'day_of_week']]
        df['is_anomaly'] = self.anomaly_detector.fit_predict(X)
        # -1 indicates an anomaly
        return df[df['is_anomaly'] == -1]

    def predict_future(self, days_ahead=7):
        """Generates a cash flow forecast for the next N days."""
        last_date = datetime.now()
        future_dates = [last_date + timedelta(days=i) for i in range(1, days_ahead + 1)]
        
        future_df = pd.DataFrame({'date': future_dates})
        future_df = self.prepare_features(future_df)
        
        X_future = future_df[['day_of_week', 'month', 'day']]
        predictions = self.forecast_model.predict(X_future)
        
        future_df['predicted_balance'] = predictions
        return future_df[['date', 'predicted_balance']]

# --- Implementation Instance ---
if __name__ == "__main__":
    # Mock Data Generation
    data = {
        'date': pd.date_range(start='2026-01-01', periods=30),
        'amount': np.random.randint(-500, 1500, size=30),
        'balance': np.cumsum(np.random.randint(100, 1000, size=30))
    }
    df_finance = pd.DataFrame(data)

    # Initialize and Execute
    brain = CashAI()
    brain.train_forecast(df_finance)
    
    # Run Forecast
    forecast = brain.predict_future(5)
    print("\n--- 5-Day Cash Forecast ---")
    print(forecast)

    # Check for Anomalies
    anomalies = brain.detect_anomalies(df_finance)
    if not anomalies.empty:
        print("\n⚠️ Anomalies Detected:")
        print(anomalies[['date', 'amount']])



import torch
import torch.nn as nn
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

# Kaizen optimization: GPU acceleration if available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

class CashAttention(nn.Module):
    """Reflecting Uriel's Wisdom: Attention mechanism to focus on critical dates."""
    def __init__(self, hidden_dim):
        super(CashAttention, self).__init__()
        self.attn = nn.Linear(hidden_dim, 1)

    def forward(self, x):
        weights = torch.softmax(self.attn(x), dim=1)
        return torch.sum(weights * x, dim=1)

class AdvancedCashAI(nn.Module):
    def __init__(self, input_dim=5, hidden_dim=64, output_dim=1):
        super(AdvancedCashAI, self).__init__()
        # Michael's Shield: Robust LSTM layers for trend protection
        self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers=2, batch_first=True, dropout=0.2)
        self.attention = CashAttention(hidden_dim)
        self.fc = nn.Sequential(
            nn.Linear(hidden_dim, 32),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(32, output_dim)
        )

    def forward(self, x):
        lstm_out, _ = self.lstm(x)
        attn_out = self.attention(lstm_out)
        return self.fc(attn_out)

# --- High-Performance Pipeline ---
def train_advance_model(data_tensor, target_tensor):
    model = AdvancedCashAI().to(device)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MSELoss()
    
    # Training Loop with zero-defect monitoring
    for epoch in range(100):
        model.train()
        optimizer.zero_grad()
        output = model(data_tensor)
        loss = criterion(output, target_tensor)
        loss.backward()
        optimizer.step()
        if epoch % 20 == 0:
            print(f"Epoch {epoch}: Loss = {loss.item():.6f}")
    return model

# Mock environment setup
scaler = MinMaxScaler()
# Features: [Amount, Prev_Balance, Day_of_Week, Is_Holiday, Market_Index]
mock_features = np.random.rand(100, 10, 5).astype(np.float32) 
mock_targets = np.random.rand(100, 1).astype(np.float32)

x_train = torch.from_numpy(mock_features).to(device)
y_train = torch.from_numpy(mock_targets).to(device)

cash_brain = train_advance_model(x_train, y_train)
