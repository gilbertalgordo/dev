import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Define the efficiency constants and maximum capacities
SOLAR_CAPACITY_KW = 100.0  # Max capacity of the solar farm in kW
WIND_CAPACITY_KW = 150.0   # Max capacity of the wind farm in kW
SOLAR_EFFICIENCY = 0.18    # Conversion efficiency (unitless)
WIND_CUBE_FACTOR = 0.5 * 1.225 * 0.59 # P = 0.5 * rho * A * Cp * v^3 (simplified constant)

# Function to calculate solar power output
def calculate_solar_power(irradiance):
    """
    Calculates power output from solar panels (in kW).
    Driver: Solar Irradiance (W/m^2).
    """
    # Simple model: Power = Irradiance * Efficiency * Panel Area (simplified)
    # We normalize to capacity, assuming irradiance is 0-1000 W/m^2
    max_irradiance = 1000.0
    power_kw = (irradiance / max_irradiance) * SOLAR_CAPACITY_KW
    # Ensure power doesn't exceed capacity
    return np.clip(power_kw, 0, SOLAR_CAPACITY_KW)

# Function to calculate wind power output
def calculate_wind_power(wind_speed_mps):
    """
    Calculates power output from a wind turbine (in kW).
    Driver: Wind Speed (m/s).
    """
    # Simple cubic model: Power is proportional to wind speed cubed (P ‚àù v^3)
    # Cut-in speed (min speed for power) and Cut-out speed (max speed for safety)
    cut_in_speed = 3.0  # m/s
    rated_speed = 12.0  # m/s (speed where it reaches max capacity)
    
    if wind_speed_mps < cut_in_speed:
        return 0.0
    elif wind_speed_mps >= rated_speed:
        return WIND_CAPACITY_KW
    else:
        # P = P_rated * ((v^3 - v_cutin^3) / (v_rated^3 - v_cutin^3)) - Simplified
        # For simplicity, we'll use a straight cubic relation normalized to rated speed
        power_kw = WIND_CAPACITY_KW * (wind_speed_mps / rated_speed)**3
        return np.clip(power_kw, 0, WIND_CAPACITY_KW)

# --- Simulation Data ---
# Create a time series data for one day (hourly)
hours = np.arange(24)
# Simulated "drivers" data:
# Irradiance (W/m^2): peaks at noon (hour 12)
irradiance_data = np.interp(hours, [0, 6, 12, 18, 24], [0, 100, 900, 150, 0])
# Wind Speed (m/s): peaks later in the day
wind_speed_data = np.interp(hours, [0, 8, 16, 24], [5, 3, 15, 8])

# Calculate Outputs
solar_output = [calculate_solar_power(irr) for irr in irradiance_data]
wind_output = [calculate_wind_power(ws) for ws in wind_speed_data]
total_output = np.array(solar_output) + np.array(wind_output)

# --- Visualization ---
df = pd.DataFrame({
    'Hour': hours,
    'Irradiance (W/m^2)': irradiance_data,
    'Wind Speed (m/s)': wind_speed_data,
    'Solar Power (kW)': solar_output,
    'Wind Power (kW)': wind_output,
    'Total Power (kW)': total_output
})

print(df)

plt.figure(figsize=(10, 6))
plt.plot(df['Hour'], df['Solar Power (kW)'], label='Solar Power', marker='o')
plt.plot(df['Hour'], df['Wind Power (kW)'], label='Wind Power', marker='x')
plt.plot(df['Hour'], df['Total Power (kW)'], label='Total Power', linestyle='--', color='k')
plt.title('Simulated Renewable Energy Output Over 24 Hours')
plt.xlabel('Hour of Day')
plt.ylabel('Power Output (kW)')
plt.grid(True)
plt.legend()
plt.xticks(hours)
plt.show()



import pandas as pd
import numpy as np

# --- Configuration Constants ---
REQUIRED_LOAD_KW = 100.0        # The constant load demand of the microgrid
GAS_GEN_COST_PER_KW = 0.15      # Cost to run the gas generator
SOLAR_CAPACITY_KW = 120.0       # Max power from solar farm
MAX_SECURE_TEMP_C = 75.0        # Max safe operating temp (Security Check)

# --- Dispatch Functions ---

def security_check(sensor_data):
    """
    Simulates a basic security/safety check.
    In a real system, this would be an IDS/Antimalware check.
    Here, it checks for anomalous temperature readings.
    """
    if sensor_data['Generator_Temp_C'] > MAX_SECURE_TEMP_C:
        print(f"‚ö†Ô∏è SECURITY ALERT: Generator temperature ({sensor_data['Generator_Temp_C']}¬∞C) is ANOMALOUS. DISPATCH HALTED.")
        return False
    if sensor_data['Network_Packets'] > 5000:
        print(f"‚ö†Ô∏è CYBER ALERT: High network activity ({sensor_data['Network_Packets']}). Proceed with caution.")
    return True

def calculate_solar_output(irradiance_w_m2):
    """Calculates solar power output based on irradiance."""
    # Simplified model: Power = Irradiance / 1000 * Capacity
    max_irradiance = 1000.0
    return np.clip((irradiance_w_m2 / max_irradiance) * SOLAR_CAPACITY_KW, 0, SOLAR_CAPACITY_KW)

def dispatch_energy(irradiance, temp, network_packets):
    """
    Determines power station output based on renewable availability and security status.
    """
    # 1. Gather Inputs
    solar_output = calculate_solar_output(irradiance)
    sensor_data = {
        'Generator_Temp_C': temp,
        'Network_Packets': network_packets
    }

    print(f"\n--- DISPATCH CYCLE ---")
    print(f"Load Demand: {REQUIRED_LOAD_KW:.2f} kW")
    print(f"Solar Availability: {solar_output:.2f} kW")

    # 2. Perform Security Check
    if not security_check(sensor_data):
        # Emergency Shutdown/Limit Power if security fails
        return solar_output, 0.0, "SECURE_FAIL"

    # 3. Calculate Required Deficit
    deficit_kw = REQUIRED_LOAD_KW - solar_output

    # 4. Dispatch Gas Generator if Deficit Exists
    if deficit_kw > 0:
        gas_gen_output = deficit_kw
        total_cost = gas_gen_output * GAS_GEN_COST_PER_KW
        status = f"GAS_DISPATCHED (Cost: ${total_cost:.2f})"
    else:
        gas_gen_output = 0.0
        status = "SOLAR_ONLY (Load Met)"
        
    # 5. Handle Surplus (Export/Battery Charge - simple status update here)
    if deficit_kw < 0:
        status = f"SOLAR_SURPLUS ({(solar_output - REQUIRED_LOAD_KW):.2f} kW Available)"
    
    return solar_output, gas_gen_output, status

# --- Simulation Run ---

# Scenario 1: Sunny Day, Normal Operation
s1_solar, s1_gas, s1_status = dispatch_energy(
    irradiance=850, # High sunlight
    temp=65.0,      # Normal temperature
    network_packets=1200 # Normal activity
)
print(f"RESULT 1: Solar={s1_solar:.2f} kW, Gas={s1_gas:.2f} kW, Status: {s1_status}")

# Scenario 2: Cloudy Day, Gas Required
s2_solar, s2_gas, s2_status = dispatch_energy(
    irradiance=200, # Low sunlight
    temp=70.0,      # Normal temperature
    network_packets=800  # Normal activity
)
print(f"RESULT 2: Solar={s2_solar:.2f} kW, Gas={s2_gas:.2f} kW, Status: {s2_status}")

# Scenario 3: High Temperature Anomaly (Simulating Malware/Fault)
s3_solar, s3_gas, s3_status = dispatch_energy(
    irradiance=500, # Medium sunlight
    temp=80.0,      # High/Anomalous temperature
    network_packets=1500 # Normal activity
)
print(f"RESULT 3: Solar={s3_solar:.2f} kW, Gas={s3_gas:.2f} kW, Status: {s3_status}")

# Scenario 4: Extreme Sunlight (Surplus)
s4_solar, s4_gas, s4_status = dispatch_energy(
    irradiance=1200, # High sunlight (will cap at capacity)
    temp=60.0,      # Normal temperature
    network_packets=1000 # Normal activity
)
print(f"RESULT 4: Solar={s4_solar:.2f} kW, Gas={s4_gas:.2f} kW, Status: {s4_status}")



import numpy as np
import pandas as pd
import time

# --- System Parameters (The "Drivers" for Optimization) ---
REQUIRED_LOAD_MW = 150.0   # Total energy demand of the grid
GAS_GEN_COST_PER_MW = 150.0 # High cost to run the gas power station ($/MWh)
WIND_CAPACITY_MW = 100.0   # Max power from wind farm
SOLAR_CAPACITY_MW = 80.0    # Max power from solar farm
RENEWABLE_COST = 0.0       # Renewable energy is considered "free" to dispatch (already built)

# --- Cyber & Safety Thresholds ---
ANOMALY_THRESHOLD_TEMP_C = 85.0 # Max safe operating temperature for Gas Turbine
ANOMALY_THRESHOLD_CYBER_RATE = 5000 # Max safe control packet rate (e.g., Modbus/DNP3 packets/sec)



def check_ics_security(sensor_data):
    """
    Simulates a centralized security system's check on control and safety metrics.
    A failure here overrides the economic dispatch decision.
    """
    gas_temp = sensor_data.get('Turbine_Temp_C', 0)
    packet_rate = sensor_data.get('Control_Packet_Rate', 0)
    
    # 1. Physical Safety Check (Thermal Anomaly)
    if gas_temp > ANOMALY_THRESHOLD_TEMP_C:
        print(f"üö® ALERT: Turbine Temperature Anomaly ({gas_temp:.1f}¬∞C). Gas generation MUST be minimal.")
        return False, "THERMAL_SHUTDOWN"
        
    # 2. Cyber Behavior Check (Network Anomaly)
    if packet_rate > ANOMALY_THRESHOLD_CYBER_RATE:
        print(f"‚ö†Ô∏è CYBER ALERT: Excessive Control Packet Rate ({packet_rate}). Potential Malicious Control Signal Flood.")
        # In a real scenario, this would trigger an isolation, but here, we halt dispatch.
        return False, "CYBER_ANOMALY"
        
    return True, "SYSTEM_SECURE"



def optimal_dispatch_cycle(wind_power, solar_power, sensor_data):
    """
    The main driver function that decides which generators to run.
    It prioritizes cost-effectiveness but is overridden by security status.
    """
    
    # --- Step 1: Security and Safety Validation ---
    is_secure, security_reason = check_ics_security(sensor_data)
    
    if not is_secure:
        # If the system is compromised or unsafe, stop the gas generator immediately
        # and limit renewable output to prevent grid instability.
        return (solar_power, wind_power, 0.0, "SECURE_FAIL - EMERGENCY LIMIT")

    # --- Step 2: Renewable Dispatch (Always Priority 1) ---
    available_renewable = np.clip(wind_power, 0, WIND_CAPACITY_MW) + \
                          np.clip(solar_power, 0, SOLAR_CAPACITY_MW)
    
    # --- Step 3: Load Calculation and Deficit ---
    load_deficit = REQUIRED_LOAD_MW - available_renewable
    
    # --- Step 4: Gas Power Station Dispatch (Priority 2) ---
    
    if load_deficit > 0:
        # Dispatch the gas generator only to cover the deficit
        gas_gen_output = load_deficit
        total_cost = gas_gen_output * GAS_GEN_COST_PER_MW
        status = f"GAS_DISPATCHED (Cost: ${total_cost:.2f}/hr)"
    else:
        # Renewable energy meets or exceeds the load
        gas_gen_output = 0.0
        if load_deficit < 0:
            status = f"RENEWABLE_SURPLUS ({-load_deficit:.2f} MW Available)"
        else:
            status = "LOAD_MET_EXACTLY"

    return (solar_power, wind_power, gas_gen_output, status)



# --- RUN THE SIMULATION ---

print(f"SYSTEM LOAD DEMAND: {REQUIRED_LOAD_MW} MW")

# Scenario A: Normal Operation (Sunny and Windy)
# Expected: Renewables cover load, Gas = 0.
output_A = optimal_dispatch_cycle(
    wind_power=90.0,
    solar_power=80.0,
    sensor_data={'Turbine_Temp_C': 70.0, 'Control_Packet_Rate': 1500}
)
print("\n--- Scenario A: Normal, Surplus ---")
print(f"Dispatch (S/W/G): {output_A[0]:.1f} / {output_A[1]:.1f} / {output_A[2]:.1f} MW. Status: {output_A[3]}")

# Scenario B: Low Renewables (Cloudy and Calm)
# Expected: Gas generator runs to cover the deficit.
output_B = optimal_dispatch_cycle(
    wind_power=20.0,
    solar_power=10.0,
    sensor_data={'Turbine_Temp_C': 75.0, 'Control_Packet_Rate': 1000}
)
print("\n--- Scenario B: Low Renewables, Gas Required ---")
print(f"Dispatch (S/W/G): {output_B[0]:.1f} / {output_B[1]:.1f} / {output_B[2]:.1f} MW. Status: {output_B[3]}")

# Scenario C: Cyber Anomaly Detected
# Expected: Security check fails, Gas is forced to 0. Load shed may occur (implicit in this model).
output_C = optimal_dispatch_cycle(
    wind_power=90.0,
    solar_power=80.0,
    sensor_data={'Turbine_Temp_C': 70.0, 'Control_Packet_Rate': 6500} # HIGH PACKET RATE
)
print("\n--- Scenario C: High Cyber Activity (Malware/DDoS on Control Network) ---")
print(f"Dispatch (S/W/G): {output_C[0]:.1f} / {output_C[1]:.1f} / {output_C[2]:.1f} MW. Status: {output_C[3]}")

# Scenario D: Physical Safety Failure
# Expected: Security check fails, Gas is forced to 0, regardless of the need.
output_D = optimal_dispatch_cycle(
    wind_power=20.0,
    solar_power=10.0,
    sensor_data={'Turbine_Temp_C': 95.0, 'Control_Packet_Rate': 1000} # HIGH TEMP
)
print("\n--- Scenario D: Turbine Safety Failure (Overheating) ---")
print(f"Dispatch (S/W/G): {output_D[0]:.1f} / {output_D[1]:.1f} / {output_D[2]:.1f} MW. Status: {output_D[3]}")



import time
import random
import numpy as np

# --- SYSTEM CONSTANTS & THRESHOLDS ---
MAX_WIND_SPEED_MPS = 25.0  # Wind speed at which the turbine must feather (cut-out)
PITCH_MAX_ANGLE = 90.0     # Max blade pitch angle (feathered/safe position)
PITCH_MIN_ANGLE = 0.0      # Min blade pitch angle (full power/optimal position)
ANOMALY_THRESHOLD_PITCH_RATE = 10.0 # Degrees per second - Max safe rate of change

# --- Configuration for Controlled Update ---
FIRMWARE_VERSION = "WTC_v2.1.5"
LAST_UPDATE_CHECK_TIMESTAMP = time.time()
UPDATE_CHECK_INTERVAL_HOURS = 24 * 7 # Check for updates only once a week

def turbine_pitch_driver(wind_speed, current_pitch_angle):
    """
    Simulates the core logic for the wind turbine blade pitch actuator driver.
    Its primary 'driver' is the current wind speed.
    """
    
    target_pitch = current_pitch_angle # Default: hold position

    # Logic 1: High Wind Safety (Heavy-Duty Driver)
    if wind_speed >= MAX_WIND_SPEED_MPS:
        # Move blades to feathered position (full safety stop)
        target_pitch = PITCH_MAX_ANGLE
        command = "FEATHERED_SHUTDOWN"
    # Logic 2: Optimal Power Tracking (Heavy-Duty Driver)
    elif wind_speed > 10.0:
        # Simplistic: adjust pitch to shed power and maintain target RPM
        # Target angle increases with wind speed above threshold
        target_pitch = min(PITCH_MAX_ANGLE, (wind_speed - 10.0) * 4)
        command = "REGULATE_POWER"
    else:
        # Optimal position for low/medium wind is usually near 0 degrees
        target_pitch = PITCH_MIN_ANGLE
        command = "MAX_CAPTURE"

    # Limit the rate of change for physical safety
    pitch_change = target_pitch - current_pitch_angle
    max_rate_change = 0.5 # Degrees per simulation cycle (e.g., 0.5 deg/sec)
    
    if abs(pitch_change) > max_rate_change:
        pitch_change = np.sign(pitch_change) * max_rate_change
        
    new_pitch_angle = current_pitch_angle + pitch_change
    
    return np.clip(new_pitch_angle, PITCH_MIN_ANGLE, PITCH_MAX_ANGLE), command



def check_anomaly_and_cyber_threats(pitch_commanded, pitch_actual, pitch_rate_of_change):
    """
    Simulates a basic Industrial Security Monitoring System (IDS/Antimalware Proxy).
    It checks for unexpected or malicious changes to critical physical parameters.
    """
    
    # Check 1: Malicious Command/Setpoint Check
    if abs(pitch_commanded - pitch_actual) > 30.0 and pitch_commanded < PITCH_MAX_ANGLE:
        # If the commanded pitch is drastically different from the actual, and
        # it's NOT a safety shutdown, it could be a malicious attempt to override control.
        print("üö® CYBER WARNING: Large, non-safety pitch deviation detected. Control system integrity check initiated.")
        return False

    # Check 2: Unsafe Rate of Change (Often triggered by rapid, unauthorized commands)
    if pitch_rate_of_change > ANOMALY_THRESHOLD_PITCH_RATE:
        print(f"‚ö†Ô∏è SAFETY/CYBER ALERT: Pitch angle changing too fast ({pitch_rate_of_change:.1f} deg/s). Emergency stop!")
        return False
        
    return True

def controlled_auto_update_check():
    """
    Simulates a highly controlled, non-real-time automated update check typical of ICS.
    This replaces a general 'antimalware auto update' with a safe, scheduled check.
    """
    global LAST_UPDATE_CHECK_TIMESTAMP, FIRMWARE_VERSION
    current_time = time.time()
    
    if (current_time - LAST_UPDATE_CHECK_TIMESTAMP) > (UPDATE_CHECK_INTERVAL_HOURS * 3600):
        print("\n‚öôÔ∏è SYSTEM CHECK: Starting weekly controlled update and integrity validation...")
        
        # In a real system, this would involve connecting to a CERTIFIED server
        # and checking the cryptographic signature of the new firmware/driver.
        new_version_available = random.choice([True, False])
        
        if new_version_available:
            new_version = "WTC_v2.1.6"
            print(f"‚úÖ UPDATE FOUND: New certified version {new_version} detected.")
            print("üö´ UPDATE SCHEDULED: Downloading to secure staging area. **Installation requires operator approval and system shutdown.**")
            # FIRMWARE_VERSION = new_version # Do NOT auto-install!
        else:
            print(f"‚úÖ SYSTEM OK: Current version {FIRMWARE_VERSION} is latest. Integrity verified.")
            
        LAST_UPDATE_CHECK_TIMESTAMP = current_time # Reset timer
    # The check is often *skipped* during high-demand or critical operating periods.



# --- SIMULATION START ---
current_pitch = PITCH_MIN_ANGLE
sim_time_seconds = 0
wind_profile = [8, 12, 22, 15, 5, 26, 11] # Sample wind speeds (m/s)

print(f"--- Wind Turbine Control System Initialized ({FIRMWARE_VERSION}) ---")

for i, wind in enumerate(wind_profile):
    sim_time_seconds += 1
    
    # 1. RUN CORE DRIVER LOGIC
    new_pitch, command = turbine_pitch_driver(wind, current_pitch)
    pitch_rate_of_change = abs(new_pitch - current_pitch)
    
    # 2. RUN SECURITY/ANOMALY CHECK
    is_safe = check_anomaly_and_cyber_threats(new_pitch, current_pitch, pitch_rate_of_change)

    # 3. APPLY COMMAND ONLY IF SAFE
    if is_safe:
        current_pitch = new_pitch
    else:
        # If not safe, always revert to the safest state
        current_pitch = PITCH_MAX_ANGLE 
        command = "SAFETY_OVERRIDE"

    # 4. RUN CONTROLLED AUTO-UPDATE CHECK (Non-Real-Time)
    if sim_time_seconds % 5 == 0:
        # Simulate the time passing far enough for a check (conceptually)
        controlled_auto_update_check() 
        
    # --- REPORT STATUS ---
    print(f"\n[T={sim_time_seconds}s] Wind: {wind:.1f} m/s | New Pitch: {current_pitch:.1f}¬∞ | Command: {command}")
    
    # Simulating the emergency stop in the high wind scenario
    if wind >= MAX_WIND_SPEED_MPS:
        print("üõë SYSTEM SHUTDOWN INITIATED DUE TO HIGH WIND.")
        break
    
    time.sleep(0.01) # Simulate time passing
