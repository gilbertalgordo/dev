# requirements: pip install discord.py python-dotenv
# Create a bot at https://discord.com/developers, add to your server with appropriate permissions.
# Put your BOT_TOKEN in a .env file as DISCORD_TOKEN=...

import os
import re
import asyncio
from dotenv import load_dotenv
import discord
from discord.ext import commands

load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")

intents = discord.Intents.default()
intents.messages = True
intents.guilds = True
intents.message_content = True  # required to read message content (bot must be authorized)

bot = commands.Bot(command_prefix="!", intents=intents, description="Moderation Bot")

# Simple list of solicitation keywords/phrases (tune carefully)
SOLICITATION_PATTERNS = [
    r"\bbuy now\b",
    r"\bfree trial\b",
    r"\bcontact for service\b",
    r"\bpromote my\b",
    r"want to buy",
    r"http[s]?://\S+",  # links — optionally flag/change to whitelist approach
]

combined = re.compile("|".join(f"({p})" for p in SOLICITATION_PATTERNS), re.IGNORECASE)

# Roles that are allowed to post links/promotions - change as needed
WHITELIST_ROLE_NAMES = {"Trusted", "Partner", "Sponsor"}

@bot.event
async def on_ready():
    print(f"Logged in as {bot.user} (id: {bot.user.id})")
    print("Ready to moderate.")

def is_whitelisted(member: discord.Member):
    names = {role.name for role in member.roles}
    return bool(names & WHITELIST_ROLE_NAMES)

@bot.event
async def on_message(message: discord.Message):
    # skip bot messages and DMs
    if message.author.bot or message.guild is None:
        return

    # allow whitelisted roles
    if is_whitelisted(message.author):
        return

    # check message content
    if combined.search(message.content or ""):
        try:
            await message.delete()
            warn = await message.channel.send(
                f"{message.author.mention} Your message was removed: our server disallows solicitation/promotional posts. "
                "If you believe this was a mistake, contact the moderators."
            )
            # optionally log to a moderation channel (replace MOD_LOG_CHANNEL_ID)
            # mod_channel = bot.get_channel(MOD_LOG_CHANNEL_ID)
            # await mod_channel.send(f"Deleted message from {message.author}: {message.content}")
            await asyncio.sleep(8)
            await warn.delete()
        except discord.Forbidden:
            print("Missing permissions to delete messages or send messages in that channel.")
        except Exception as e:
            print("Error moderating message:", e)

    await bot.process_commands(message)

# Example admin command to add a whitelist role name (simplified)
@bot.command()
@commands.has_permissions(administrator=True)
async def add_whitelist_role(ctx, *, role_name: str):
    WHITELIST_ROLE_NAMES.add(role_name)
    await ctx.send(f"Added whitelist role: {role_name}")

# Start
bot.run(TOKEN)


# requirements: pip install Flask qrcode[pil] sqlite3
# Run: python guestlist_app.py

from flask import Flask, request, redirect, url_for, render_template_string, send_file
import sqlite3
import qrcode
import io

app = Flask(__name__)
DB = "guests.db"

# initialize DB
def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS guests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        email TEXT UNIQUE,
        invited INTEGER DEFAULT 1,
        checked_in INTEGER DEFAULT 0
    )""")
    conn.commit()
    conn.close()

init_db()

# templates (simple)
INDEX_HTML = """
<h2>Event Guest List</h2>
<form action="/add" method="post">
  Name: <input name="name" required> Email: <input name="email" type="email" required>
  <button type="submit">Add Guest</button>
</form>
<ul>
{% for g in guests %}
  <li>{{g[1]}} ({{g[2]}}) - invited: {{g[3]}} - checked_in: {{g[4]}} 
    - <a href="/qr/{{g[2]}}">QR</a>
  </li>
{% endfor %}
</ul>
"""

CHECKIN_HTML = """
<h2>Check-in scanner</h2>
<form action="/scan" method="post">
  Email or scan result: <input name="code" required>
  <button type="submit">Check In</button>
</form>
<p>{{message}}</p>
"""

@app.route("/")
def index():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT * FROM guests")
    guests = c.fetchall()
    conn.close()
    return render_template_string(INDEX_HTML, guests=guests)

@app.route("/add", methods=["POST"])
def add_guest():
    name = request.form["name"]
    email = request.form["email"].strip().lower()
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    try:
        c.execute("INSERT INTO guests (name, email) VALUES (?, ?)", (name, email))
        conn.commit()
    except sqlite3.IntegrityError:
        pass
    conn.close()
    return redirect(url_for("index"))

@app.route("/qr/<email>")
def qr(email):
    # generate a simple QR containing the guest email
    img = qrcode.make(email)
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return send_file(buf, mimetype="image/png", download_name=f"{email}.png")

@app.route("/scanner")
def scanner():
    return render_template_string(CHECKIN_HTML, message="")

@app.route("/scan", methods=["POST"])
def scan():
    code = request.form["code"].strip().lower()
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT id, name, invited, checked_in FROM guests WHERE email = ?", (code,))
    row = c.fetchone()
    message = ""
    if row:
        if row[3]:
            message = f"{row[1]} already checked in."
        else:
            c.execute("UPDATE guests SET checked_in=1 WHERE id=?", (row[0],))
            conn.commit()
            message = f"Welcome, {row[1]}! Checked in."
    else:
        message = "Guest not on list — deny entry or escalate to security."
    conn.close()
    return render_template_string(CHECKIN_HTML, message=message)

if __name__ == "__main__":
    app.run(debug=True, port=5000)


   # requirements: pip install Flask scikit-learn joblib flask-httpauth python-dotenv
# NOTE: This is an example for servers you run. Do NOT use against accounts you don't manage.

from flask import Flask, request, jsonify
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
import joblib
import os
import re
import sqlite3
from datetime import datetime
from functools import wraps
from dotenv import load_dotenv

load_dotenv()

# --- Simple persistent log (sqlite) for auditable actions ---
DB = "mod_audit.db"
def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS actions (
        id INTEGER PRIMARY KEY,
        platform TEXT,
        item_id TEXT,
        author TEXT,
        text TEXT,
        score REAL,
        action_taken TEXT,
        reason TEXT,
        timestamp TEXT
    )""")
    conn.commit()
    conn.close()

init_db()

def log_action(platform, item_id, author, text, score, action_taken, reason):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("INSERT INTO actions (platform,item_id,author,text,score,action_taken,reason,timestamp) VALUES (?,?,?,?,?,?,?,?)",
              (platform, item_id, author, text, score, action_taken, reason, datetime.utcnow().isoformat()))
    conn.commit()
    conn.close()

# --- Quick rule engine ---
LINK_RE = re.compile(r'https?://\S+')
PROMO_KEYWORDS = [r'\bbuy now\b', r'\bfree trial\b', r'\bcontact for service\b', r'\bpromote\b', r'\bpartnership\b']

def rule_score(text):
    score = 0.0
    if LINK_RE.search(text): score += 0.4
    for p in PROMO_KEYWORDS:
        if re.search(p, text, re.IGNORECASE):
            score += 0.2
    return min(score, 1.0)

# --- ML model: vectorizer + simple classifier (train offline on labeled examples) ---
MODEL_PATH = "mod_model.joblib"

# If model not present, create a dummy one (you must train with labeled data for production)
if not os.path.exists(MODEL_PATH):
    vect = TfidfVectorizer(ngram_range=(1,2), max_features=5000)
    clf = LogisticRegression()
    # dummy training with tiny examples (replace with real labeled dataset)
    X = vect.fit_transform([
        "Check out my service, buy now",
        "Free trial! click the link",
        "Meeting agenda for Monday",
        "Thanks everyone, see you then",
    ])
    y = [1,1,0,0]
    clf.fit(X,y)
    joblib.dump((vect, clf), MODEL_PATH)

vect, clf = joblib.load(MODEL_PATH)

def ml_score(text):
    x = vect.transform([text])
    p = clf.predict_proba(x)[0][1]  # probability of 'solicitation' class
    return float(p)

# --- Flask webhook receiver ---
app = Flask(__name__)
API_KEY = os.getenv("MOD_API_KEY", "replace_with_secret")

def require_api_key(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        key = request.headers.get("X-API-KEY", "")
        if key != API_KEY:
            return jsonify({"error":"unauthorized"}), 401
        return f(*args, **kwargs)
    return decorated

# Decision thresholds (tune)
AUTO_DELETE_THRESHOLD = 0.9
HOLD_FOR_REVIEW_THRESHOLD = 0.6

@app.route("/webhook/<platform>", methods=["POST"])
@require_api_key
def webhook(platform):
    payload = request.json or {}
    # Normalize fields from different platforms into text, item_id, author
    text = payload.get("text") or payload.get("message") or ""
    item_id = payload.get("id") or payload.get("item_id") or str(datetime.utcnow().timestamp())
    author = payload.get("author") or payload.get("user") or "unknown"

    # rule + ml scoring
    rscore = rule_score(text)
    mscore = ml_score(text)
    final_score = min(1.0, 0.6*mscore + 0.4*rscore)  # weighted ensemble

    action = "allow"
    reason = ""
    if final_score >= AUTO_DELETE_THRESHOLD:
        action = "auto_delete"
        reason = f"high_score ({final_score:.2f})"
        # TAKE ACTION: call platform API to remove the item (only if you are admin)
        # Example placeholder: remove_item_on_platform(platform, item_id)
    elif final_score >= HOLD_FOR_REVIEW_THRESHOLD:
        action = "hold_for_review"
        reason = f"moderation_queue ({final_score:.2f})"
        # push to moderator queue (send to Slack/Discord mod channel)
    else:
        action = "allow"
        reason = f"low_risk ({final_score:.2f})"

    log_action(platform, item_id, author, text[:200], final_score, action, reason)
    return jsonify({"status":"ok","score":final_score,"action":action,"reason":reason})

if __name__ == "__main__":
    app.run(port=8000)


    # requirements: pip install Flask pyjwt qrcode[pil] sqlite3 python-dotenv
import sqlite3, qrcode, io, os
from flask import Flask, request, send_file, jsonify
import jwt
from datetime import datetime, timedelta
from dotenv import load_dotenv

load_dotenv()
SECRET = os.getenv("JWT_SECRET", "replace_with_strong_secret")
DB = "event_tokens.db"
app = Flask(__name__)

def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS tokens (
        id INTEGER PRIMARY KEY,
        email TEXT UNIQUE,
        token TEXT,
        used INTEGER DEFAULT 0,
        expires_at TEXT
    )""")
    conn.commit()
    conn.close()

init_db()

def issue_token(email, valid_minutes=60):
    payload = {"sub": email, "iat": datetime.utcnow().timestamp(), "exp": (datetime.utcnow() + timedelta(minutes=valid_minutes)).timestamp()}
    token = jwt.encode(payload, SECRET, algorithm="HS256")
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO tokens (email, token, used, expires_at) VALUES (?,?,0,?)",
              (email, token, (datetime.utcnow() + timedelta(minutes=valid_minutes)).isoformat()))
    conn.commit(); conn.close()
    return token

@app.route("/generate_qr", methods=["POST"])
def generate_qr():
    data = request.json or {}
    email = data.get("email")
    if not email:
        return jsonify({"error":"email required"}), 400
    token = issue_token(email, valid_minutes=30)
    # generate QR for the token string
    img = qrcode.make(token)
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    buf.seek(0)
    return send_file(buf, mimetype="image/png", download_name=f"{email}.png")

@app.route("/scan_token", methods=["POST"])
def scan_token():
    token = request.json.get("token")
    try:
        payload = jwt.decode(token, SECRET, algorithms=["HS256"])
        email = payload.get("sub")
    except jwt.ExpiredSignatureError:
        return jsonify({"status":"invalid","reason":"expired"}), 400
    except jwt.InvalidTokenError:
        return jsonify({"status":"invalid","reason":"invalid token"}), 400

    conn = sqlite3.connect(DB)
    c = conn.cursor()
    row = c.execute("SELECT id, used FROM tokens WHERE token = ?", (token,)).fetchone()
    if not row:
        conn.close()
        return jsonify({"status":"invalid","reason":"unknown token"}), 400
    if row[1]:
        conn.close()
        return jsonify({"status":"invalid","reason":"already used"}), 400

    # mark used
    c.execute("UPDATE tokens SET used=1 WHERE id=?", (row[0],))
    conn.commit()
    conn.close()
    return jsonify({"status":"ok","email":email})

if __name__ == "__main__":
    app.run(port=5001)


    {
  "prompt": "A cinematic, animation-style scene illustrating secure protection of digital and physical spaces through symbolic imagery. In the foreground, a glowing, translucent barrier rises like a protective wall of light, filled with swirling runes and data patterns representing moderation and anti-solicitation filters. On one side of the barrier, chaotic red glitch shapes attempt to breach, symbolizing unwanted solicitation and unauthorized access. On the other side, serene blue and gold environments depict private executive spaces and high-profile gatherings, with silhouettes of attendees bathed in calm, dignified light. Floating holographic icons—shields, locks, network graphs—reinforce the theme of lawful protection without depicting harm to any person. The atmosphere is dramatic, futuristic, and polished, with soft motion-blur streaks that give the feeling of animation in a single frame. No specific people or real-world logos appear.",
  "size": "1024x1024"
}
